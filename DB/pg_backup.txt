pg_start_backup() is a function we execute to start a base backup. It was part of the original API for physical backup introduced in PostgreSQL 8.0. It’s now been mostly superceded by the replication command BASE_BACKUP,
 which is most frequently executed by the pg_basebackup utility.

So what does a base backup actually do? Well, first we execute a checkpoint so that as many changed data blocks are on disk as possible. Next we force full page writes to occur, even if full_page_writes = off, 
because we need to see the whole page for any changes. Lastly, we record the starting point of the backup. That’s all.

Base backup does NOT prevent writes to the data directory. It’s designed to be “fully online” so it doesn’t take locks on objects, doesn’t interefere with the operation of the database apart from some details 
if you try to shut it down while taking a backup.

pg_stop_backup() is the end marker for that backup.

The key point is that the base backup is NOT a consistent copy of the database. You might have copied every file, but all the data is taken at different times. So its wrong. Until you recover the database with the WAL changes 
that occurred between the start backup and the stop backup.

Which is why you’ll be wanting to use a command like this

pg_basebackup –xlog-method=stream

or use a utility that does everything for you, like Barman.





postgresql-13主从 streaming复制 同步模式
===========================================================================================================================
1 概念和原理
一.物理流复制
物理流复制是一种数据库主备同步技术，该特性同步的数据是数据库中物理页面变化数据（WAL），该模式备库的底层数据页面状态和主库完全相同，这样的实现方案让数据库主备以及同步状态都非常稳定。
二.流复制中的角色
1. 主库 backend 进程，它负责执行用户的 SQL，在修改数据前会先记录 WAL（Write-Ahead Logging）日志。这些日志中事物提交日志（CommitTransaction）由 backend 进程负责写到磁盘。
2. 主库 WALsender 进程，负责把 WAL 日志发送给备库的 WALreceiver 进程。
3. 备库 WALreceiver 进程，负责接收 WALsender 发送的 WAL 日志，并持久化到存储。
4. 备库 startup 进程，负责恢复 WALsender 写到磁盘上的 WAL 日志，把数据 apply 到数据页面上。
异步流复制和同步流复制
一.异步流复制
默认状态下的流复制是以异步方式工作的，也就是说主库写本地数据和 WAL 日志，WALsender 异步的把数据发送给备库，备库收到数据后再异步的做数据恢复。
异步模式可以做到较好的性能，它的劣势是：极端情况下，主库如果当机，被库被激活成主库，部分 WAL 没有发送到备库，可能造成数据丢失。
二.同步流复制
相对于异步模式，PostgreSQL 还支持同步模式的流复制。同模模式可以细分为三级
1. REMOTE_WRITE 保证该事务的所有数据被备库收到（备库收到数据并调用 write 写磁盘，但并未持久化到磁盘）
2. REMOTE_FLUSH 保证该事务的所有数据在备库持久化到磁盘（调用 flush，但只读查询看不到）
3. REMOTE_APPLY 保证该事务的所有数据在备库被恢复到数据页面（恢复进程读取并解析 WAL，再 APPLY 到数据页面，在备库上执行的只读查询能看到数据的变化）
三. 同步流复制源码解析
1. MVCC 机制和数据可见性
简单的说 PostgreSQL ACID 是基于 MVCC 和 WAL 技术。数据的修改过程可以简单描述为
1. 首先 backend 开启是一个事务,获得一个事务号 XID;
2. 在这个事务中对数据的任意修改，都被 XID 标记。
3. 其他 backend 在扫描数据时，会看到被这个 XID 修改过的数据，根据当前的隔离级别，选择对这些数据是否可见（默认的读已提交隔离级别看不到这些数据）。
4. 只有当此 XID 最后被标记成 commit （写 WAL commit log 和写 clog）后，其他的 backend 才能看到这个 XID 修改的数据。
2. 同模流复制的关键点
总结一下，实现流复制的同步模式，关键点在每个事务提交或回滚时，保证它产生的所有数据变化日志，即 WAL 都“同步”到备库。最后一条 WAL commit log 尤为关键。
3. 如何实现同步流复制
铺垫完所有概念和前提技术，我们看看同步模式具体是怎么实现的。以事务提交流程为例：
1. [主库 backend 进程]调用 RecordTransactionCommit 中写 WAL commit log，获得这条日志在在 WAL 中的位置 XLogRecPtr
2. [主库 backend 进程]完成写 WAL 后，进入 SyncRepWaitForLSN 等待 WAL 日志“同步”到备库。具体做法是:在共享内存中创建一个等待队列 SHMQueue 记录 XLogRecPtr，并调动 WaitLatch，让出 CPU 等待被唤醒。
3. [主库 WALsender 进程]相应所有备库的 WALreceiver 拉取 WAL 的请求。把 WAL 发送给所有备库。
4. [备库 WALreceiver 进程]写 WAL 的偏移（LogstreamResult.Write）和持久化 WAL 偏移（LogstreamResult.Flush）记录下来。
5. [备库 startup 进程]不断的恢复数据，把当前恢复到的 WAL 位点放在共享内存 xlogctl->lastReplayedEndRecPtr 中。
6. [备库 WALreceiver 进程]不断通过 r 报文和主库 WALsender 进程同步的状态，即 XLOGWRITELSN XLOGREMOTELSN XLOGAPPLYLSN（XLogWalRcvSendReply）
7. [主库 WALsender 进程]收到备库发送的 r 报文后，检查共享内存中的等待队列 SHMQueue, 根据备库反馈的位点结合 SHMQueue，唤醒那些等待队列中睡眠的 主库 backend 进程（WalSndWaitForWal）。
8. [主库 backend 进程]被唤醒，当前事务成功提交，SQL 执行完成返回给客户端。
===========================================================================================================================
PostgreSQL V12中没有了recovery.conf
从向后兼容的观点来看，PostgreSQL v12中最大的变化是recovery.conf文件中的参数放到了postgresql.conf配置文件中。

放弃recovery.conf
在PG12以前，如果数据目录存在recovery.conf文件，当PG实例启动时将进入恢复模式（recovery或standby）,该文件包含了用于配置恢复的所有参数，例如：
standby_mode：确定这是正常的归档恢复还是standby模式
restore_command：此命令恢复已归档的WAL段
recovery_target*：此参数确定要恢复到的点
primary_conninfo：如何连接到流复制主服务器
长期以来，recovery.conf一直被认为是一个缺陷，因为配置参数分布在多个不同的文件中是不合理的，另外还不能使用ALTER SYSTEM命令对参数进行修改。

从PG12开始，由于该文件不存在，由下面两个新文件进行替换：
recovery.signal：告诉PostgreSQL进入正常的归档恢复
standby.signal：告诉PostgreSQL进入standby模式
如果两个文件都存在，则standby.signal优先。


2 配置
# Install the repository RPM:
sudo yum install -y https://download.postgresql.org/pub/repos/yum/reporpms/EL-7-x86_64/pgdg-redhat-repo-latest.noarch.rpm

# Install PostgreSQL:
sudo yum install -y postgresql13-server

# Optionally initialize the database and enable automatic start:
sudo /usr/pgsql-13/bin/postgresql-13-setup initdb
sudo systemctl enable postgresql-13
sudo systemctl start postgresql-13

环境变量
export PATH=/usr/pgsql-13/bin:$PATH
export PGDATA=/var/lib/postgresql/data

cat /etc/hosts
127.0.0.1   localhost localhost.localdomain localhost4 localhost4.localdomain4
::1         localhost localhost.localdomain localhost6 localhost6.localdomain6
10.67.39.58  postgres-1
10.67.39.59  postgres-2

------主库操作
1 初始化数据库
postgresql-setup --initdb

2 在pg_hba.conf增加一行
host    replication     repl            postgres-2              trust

3 修改postgresql.conf
listen_addresses = '*'
synchronous_standby_names = '*'    同步模式的设置
synchronous_commit = on    默认设置，可以用select * from pg_settings where name='synchronous_commit';验证
# - Archiving -
archive_mode = on              
archive_command = 'test ! -f /opt/archivedir/%f && cp %p /opt/archivedir/%f'

4 重启postgresql
5 创建复制用户
create user repl replication LOGIN CONNECTION LIMIT 30 ENCRYPTED PASSWORD 'Foxconn123';

---------从库操作
从库只安装数据库软件，不进行数据库初始化
/usr/pgsql-13/bin/pg_basebackup --pgdata=$PGDATA --format=p --write-recovery-conf --checkpoint=fast --label=mffb --progress --host=postgres-1 --port=5432 --username=repl
***在PG12之前，-R备份结束之后会自动生成recovery.conf文件，用来做流复制判断主从同步的信息。但是从PG12开始，这个文件已经不需要了。***
***只需要在参数文件postgresql.conf中配置primary_conninfo参数即可。***

修改potgresql.conf， 这个配置文件从主库复制来
primary_conninfo = 'host=10.67.39.58 port=5432 user=repl password=Foxconn123'
primary_slot_name = 'postgres2_slot'

---------主库操作
在主库创建replication slot
***Slots can be created and dropped either via the streaming replication protocol (see Section 53.4) or via SQL functions (see Section 9.27.6).***
select * from pg_create_physical_replication_slot('postgres2_slot');
select slot_name,slot_type,active,wal_status from pg_replication_slots;

---------从库操作
systemctl start postgresql-13
如果从库设置正确的话，可以从log里看到
2021-07-14 06:07:25.820 UTC [852] LOG:  started streaming WAL from primary at 0/3000000 on timeline 1

---------在主库再次检查
postgres=# select slot_name,slot_type,active,wal_status from pg_replication_slots;
   slot_name    | slot_type | active | wal_status
----------------+-----------+--------+------------
 standby_slot   | physical  | f      |
 postgres2_slot | physical  | t      | reserved
---------观察进程
从库进程
-bash-4.2$ ps -ef |grep wal
postgres   852 17759  0 06:07 ?        00:00:01 postgres: walreceiver streaming 0/302FA60
主库进程
-bash-4.2$ ps -ef|grep wal
postgres  2481 18063  0 06:07 ?        00:00:00 postgres: walsender repl 10.67.39.59(38252) streaming 0/302FA60

--------主库观察同步状态
postgres=# select * from pg_stat_replication;
-[ RECORD 1 ]----+------------------------------
pid              | 2481
usesysid         | 16384
usename          | repl
application_name | walreceiver
client_addr      | 10.67.39.59
client_hostname  | postgres-2
client_port      | 38252
backend_start    | 2021-07-14 06:07:28.239589+00
backend_xmin     |
state            | streaming
sent_lsn         | 0/4000148
write_lsn        | 0/4000148
flush_lsn        | 0/4000148
replay_lsn       | 0/4000148
write_lag        |
flush_lag        |
replay_lag       |
sync_priority    | 1
sync_state       | sync    同步方式
reply_time       | 2021-07-14 07:05:54.037038+00

--------从库观察同步状态
postgres=# select * from pg_stat_wal_receiver;
-[ RECORD 1 ]---------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
pid                   | 852
status                | streaming
receive_start_lsn     | 0/3000000
receive_start_tli     | 1
written_lsn           | 0/4000148
flushed_lsn           | 0/4000148
received_tli          | 1
last_msg_send_time    | 2021-07-14 07:04:26.345695+00
last_msg_receipt_time | 2021-07-14 07:04:23.79761+00
latest_end_lsn        | 0/4000148
latest_end_time       | 2021-07-14 06:40:52.494625+00
slot_name             | postgres2_slot
sender_host           | postgres-1
sender_port           | 5432
conninfo              | user=repl passfile=/var/lib/pgsql/.pgpass channel_binding=prefer dbname=replication host=postgres-1 port=5432 fallback_application_name=walreceiver sslmode=prefer sslcompression=0 ssl_min_protocol_version=TLSv1.2 gssencmode=prefer krbsrvname=postgres target_session_attrs=any

 ---------测试
 在主库create table, 从库观察
 
postgres=# select pg_is_in_recovery();       主库是f代表false ；备库是t，代表true
 pg_is_in_recovery
-------------------
 t


切归档
[root@postgres-1 archivedir]# ls -lh
total 33M
-rw-------. 1 postgres postgres 16M Jul 13 09:20 000000010000000000000001
-rw-------. 1 postgres postgres 16M Jul 13 09:20 000000010000000000000002
-rw-------. 1 postgres postgres 316 Jul 13 09:20 000000010000000000000002.00000028.backup

postgres=# select pg_switch_wal();
 pg_switch_wal
---------------
 0/302FA78
(1 row)

[root@postgres-1 archivedir]# ls -lh
total 49M
-rw-------. 1 postgres postgres 16M Jul 13 09:20 000000010000000000000001
-rw-------. 1 postgres postgres 16M Jul 13 09:20 000000010000000000000002
-rw-------. 1 postgres postgres 316 Jul 13 09:20 000000010000000000000002.00000028.backup
-rw-------. 1 postgres postgres 16M Jul 14 06:36 000000010000000000000003
或者
postgres=# select * from pg_stat_get_archiver();
-[ RECORD 1 ]------+-----------------------------
archived_count     | 11
last_archived_wal  | 000000010000000000000008
last_archived_time | 2021-07-14 09:07:57.06432+00
failed_count       | 0
last_failed_wal    |
last_failed_time   |
stats_reset        | 2021-07-13 08:26:45.98489+00

postgres=# select pg_switch_wal();
-[ RECORD 1 ]-+----------
pg_switch_wal | 0/901BD78

postgres=# select * from pg_stat_get_archiver();
-[ RECORD 1 ]------+------------------------------
archived_count     | 12
last_archived_wal  | 000000010000000000000009
last_archived_time | 2021-07-15 06:21:10.562539+00
failed_count       | 0
last_failed_wal    |
last_failed_time   |
stats_reset        | 2021-07-13 08:26:45.98489+00

####Rollback from Synchronous to Asynchronous PostgreSQL Replication
Postgresql.conf注释下面两行
#synchronous_standby_names = 'pgsql_0_node_0'
#synchronous_commit = on
And restart the database service.
$ systemctl restart postgresql-13

#### pgbackrest
安装
yum install postgresql13-server postgresql13-contrib pgbackrest

配置
[root@pg01 ~]# cat /etc/pgbackrest.conf
[global]
repo1-path=/var/lib/pgbackrest
repo1-retention-full=2
log-level-console=info
log-level-file=debug

repo2-path=/repo
repo2-type=s3
repo2-s3-endpoint=repo-centos.local
repo2-s3-bucket=pgbackrest
repo2-s3-key=admin
repo2-s3-key-secret=vSTJ456789
repo2-s3-region=default
repo2-retention-full=1
repo2-s3-uri-style=path
repo2-storage-verify-tls=n
repo2-storage-port=9000

process-max=2
start-fast=y
delta=y

[main]
pg1-path=/var/lib/pgsql/13/data


-bash-4.2$ cat postgresql.conf |egrep -i '^listen|^password_en|^archive_'
listen_addresses = '*'
password_encryption = scram-sha-256             # md5 or scram-sha-256
archive_mode = on
archive_command = 'pgbackrest --stanza=main archive-push %p'

 
# 全备
pgbackrest --stanza=main --type=full backup
恢复的话，要把$PGDATA里的数据都删掉
pgbackrest --stanza=main --delta restore

使用minio全备和恢复
-bash-4.2$ pgbackrest --stanza=main --type=full --repo=2 backup
2021-09-28 08:45:38.174 P00   INFO: backup command begin 2.35: --delta --exec-id=5087-b0ef3e33 --log-level-console=info --log-level-file=debug --pg1-path=/var/lib/pgsql/13/data --process-max=2 --repo=2 --repo1-path=/var/lib/pgbackrest --repo2-path=/repo --repo1-retention-full=2 --repo2-retention-full=1 --repo2-s3-bucket=pgbackrest --repo2-s3-endpoint=repo-centos.local --repo2-s3-key=<redacted> --repo2-s3-key-secret=<redacted> --repo2-s3-region=default --repo2-s3-uri-style=path --repo2-storage-port=9000 --no-repo2-storage-verify-tls --repo2-type=s3 --stanza=main --start-fast --type=full
2021-09-28 08:45:38.924 P00   INFO: execute non-exclusive pg_start_backup(): backup begins after the requested immediate checkpoint completes
2021-09-28 08:45:39.428 P00   INFO: backup start archive = 00000003000000000000000D, lsn = 0/D000028
2021-09-28 08:45:45.140 P00   INFO: execute non-exclusive pg_stop_backup() and wait for all WAL segments to archive
2021-09-28 08:45:45.444 P00   INFO: backup stop archive = 00000003000000000000000D, lsn = 0/D000138
2021-09-28 08:45:45.452 P00   INFO: check archive for segment(s) 00000003000000000000000D:00000003000000000000000D
2021-09-28 08:45:45.944 P00   INFO: new backup label = 20210928-084538F
2021-09-28 08:45:46.020 P00   INFO: full backup size = 24MB, file total = 940
2021-09-28 08:45:46.020 P00   INFO: backup command end: completed successfully (7851ms)
2021-09-28 08:45:46.020 P00   INFO: expire command begin 2.35: --exec-id=5087-b0ef3e33 --log-level-console=info --log-level-file=debug --repo=2 --repo1-path=/var/lib/pgbackrest --repo2-path=/repo --repo1-retention-full=2 --repo2-retention-full=1 --repo2-s3-bucket=pgbackrest --repo2-s3-endpoint=repo-centos.local --repo2-s3-key=<redacted> --repo2-s3-key-secret=<redacted> --repo2-s3-region=default --repo2-s3-uri-style=path --repo2-storage-port=9000 --no-repo2-storage-verify-tls --repo2-type=s3 --stanza=main
2021-09-28 08:45:46.061 P00   INFO: repo2: 13-1 remove archive, start = 00000003000000000000000C, stop = 00000003000000000000000C
2021-09-28 08:45:46.065 P00   INFO: expire command end: completed successfully (45ms)

-bash-4.2$ pgbackrest --stanza=main --repo=2 --delta restore
2021-09-28 09:17:48.153 P00   INFO: restore command begin 2.35: --delta --exec-id=5197-e962d863 --log-level-console=info --log-level-file=debug --pg1-path=/var/lib/pgsql/13/data --process-max=2 --repo=2 --repo1-path=/var/lib/pgbackrest --repo2-path=/repo --repo2-s3-bucket=pgbackrest --repo2-s3-endpoint=repo-centos.local --repo2-s3-key=<redacted> --repo2-s3-key-secret=<redacted> --repo2-s3-region=default --repo2-s3-uri-style=path --repo2-storage-port=9000 --no-repo2-storage-verify-tls --repo2-type=s3 --stanza=main
WARN: --delta or --force specified but unable to find 'PG_VERSION' or 'backup.manifest' in '/var/lib/pgsql/13/data' to confirm that this is a valid $PGDATA directory.  --delta and --force have been disabled and if any files exist in the destination directories the restore will be aborted.
2021-09-28 09:17:48.252 P00   INFO: repo2: restore backup set 20210928-084538F
2021-09-28 09:17:51.516 P00   INFO: write updated /var/lib/pgsql/13/data/postgresql.auto.conf
2021-09-28 09:17:51.528 P00   INFO: restore global/pg_control (performed last to ensure aborted restores cannot be started)
2021-09-28 09:17:51.530 P00   INFO: restore size = 24MB, file total = 940
2021-09-28 09:17:51.534 P00   INFO: restore command end: completed successfully (3385ms)


****minio with ssl ****
[root@repo-centos ~]# cd .minio/certs
[root@repo-centos certs]# certgen -ca -host "repo-centos.local,10.67.51.164,172.17.0.2"
2021/09/28 16:27:59 wrote public.crt
2021/09/28 16:27:59 wrote private.key
[root@repo-centos web]# cat minio.sh
docker run -d \
--name myminio \
-e MINIO_ACCESS_KEY=admin \
-e MINIO_SECRET_KEY=vSTJ456789 \
-v /mrepo/minio:/data \
-v /root/.minio:/root/.minio \
-p 443:443 \
-p 9000:9000 \
minio/minio server /data --console-address ":443"



# PITR
-bash-4.2$ pgbackrest --stanza=main --type=diff backup
2021-09-27 09:33:04.180 P00   INFO: backup command begin 2.35: --exec-id=1000-4e0ae149 --log-level-console=info --log-level-file=debug --pg1-path=/var/lib/pgsql/13/data --repo1-path=/var/lib/pgbackrest --repo1-retention-full=2 --stanza=main --type=diff
2021-09-27 09:33:04.977 P00   INFO: last backup label = 20210927-090555F, version = 2.35
2021-09-27 09:33:04.977 P00   INFO: execute non-exclusive pg_start_backup(): backup begins after the next regular checkpoint completes
2021-09-27 09:33:10.688 P00   INFO: backup start archive = 000000020000000000000009, lsn = 0/9000028
WARN: a timeline switch has occurred since the 20210927-090555F backup, enabling delta checksum
      HINT: this is normal after restoring from backup or promoting a standby.
2021-09-27 09:33:12.243 P00   INFO: execute non-exclusive pg_stop_backup() and wait for all WAL segments to archive
2021-09-27 09:33:12.548 P00   INFO: backup stop archive = 000000020000000000000009, lsn = 0/9000100
2021-09-27 09:33:12.554 P00   INFO: check archive for segment(s) 000000020000000000000009:000000020000000000000009
2021-09-27 09:33:13.036 P00   INFO: new backup label = 20210927-090555F_20210927-093304D
2021-09-27 09:33:13.131 P00   INFO: diff backup size = 24MB, file total = 939
2021-09-27 09:33:13.131 P00   INFO: backup command end: completed successfully (8954ms)
2021-09-27 09:33:13.132 P00   INFO: expire command begin 2.35: --exec-id=1000-4e0ae149 --log-level-console=info --log-level-file=debug --repo1-path=/var/lib/pgbackrest --repo1-retention-full=2 --stanza=main
2021-09-27 09:33:13.139 P00   INFO: expire command end: completed successfully (8ms)
-bash-4.2$ psql -c "select * from t1"
 id
-----
   1
   2
   3
  ...
  100
-bash-4.2$ psql -c "select current_timestamp"
       current_timestamp
-------------------------------
 2021-09-27 09:33:46.013798+00
(1 row)

-bash-4.2$ psql -c "delete from t1 where id>90"
DELETE 10
-bash-4.2$ psql -c "select * from t1"
 id
----
  1
  2
  3
  ...
  90  
[root@pg01 etc]# systemctl stop postgresql-13
[root@pg01 etc]# su - postgres
Last login: Mon Sep 27 09:09:09 UTC 2021
-bash-4.2$ pgbackrest --stanza=main --delta --type=time "--target=2021-09-27 09:33:46.013798+00" --target-action=promote restore
2021-09-27 09:35:52.160 P00   INFO: restore command begin 2.35: --delta --exec-id=1056-a9541000 --log-level-console=info --log-level-file=debug --pg1-path=/var/lib/pgsql/13/data --repo1-path=/var/lib/pgbackrest --stanza=main --target="2021-09-27 09:33:46.013798+00" --target-action=promote --type=time
2021-09-27 09:35:52.248 P00   INFO: repo1: restore backup set 20210927-090555F_20210927-093304D
2021-09-27 09:35:52.252 P00   INFO: remove invalid files/links/paths from '/var/lib/pgsql/13/data'
2021-09-27 09:35:53.649 P00   INFO: write updated /var/lib/pgsql/13/data/postgresql.auto.conf
2021-09-27 09:35:53.661 P00   INFO: restore global/pg_control (performed last to ensure aborted restores cannot be started)
2021-09-27 09:35:53.664 P00   INFO: restore size = 24MB, file total = 939
2021-09-27 09:35:53.666 P00   INFO: restore command end: completed successfully (1509ms)
[root@pg01 etc]# systemctl start postgresql-13
[root@pg01 etc]# su - postgres
Last login: Mon Sep 27 09:35:48 UTC 2021
-bash-4.2$ psql -c "select * from t1 where id>89"
 id
-----
  90
  91
  92
  93
  94
  95
  96
  97
  98
  99
 100
  
## pg_receivewal  以streaming方式进行本地/远程备份wal
This client program will open a replication connection to PostgreSQL and stream WAL, just like streaming replication does. 
But instead of applying the information to a standby server, it writes it to disk. This way, it creates a copy of the WAL segments in real time. 
The partial WAL segment that pg_receivewal is currently writing has the extension .partial to distinguish it from completed WAL archives. 
Once the segment is complete, pg_receivewal will rename it.
pg_receivewal is an alternative to WAL archiving that avoids the gap between the current and the archived WAL location. It is a bit more complicated to manage and monitor, 
because it is a separate process and should run on a different machine.
pg_receivewal默认以异步的方式接收主库的wal，会损失几秒钟的事务

以下命令指定主库的复制槽standy_slot，以sync模式接收主库的wal，如同streaming replication，但是此时不会replay
注意:如果只有一个机器以同步模式接受主库的wal,如果机器死机，主库会hang住，不会提交任何事务了，要保证同时有两台机器接受主库的wal

-bash-4.2$ pg_receivewal -D wal_remotebk/ -v -S standby_slot --synchronous -h 10.67.39.58 -p 5432 -U repl -W
Password:
pg_receivewal: starting log streaming at 2/9000000 (timeline 1)
pg_receivewal: finished segment at 2/A000000 (timeline 1)
pg_receivewal: finished segment at 2/B000000 (timeline 1)
pg_receivewal: finished segment at 2/C000000 (timeline 1)
pg_receivewal: finished segment at 2/D000000 (timeline 1)
pg_receivewal: finished segment at 2/E000000 (timeline 1)
pg_receivewal: finished segment at 2/F000000 (timeline 1)


使用restore_command恢复数据库，这里用了nfs挂载
restore_command = 'cp /walarchive/%f %p || cp /walarchive/%f.partial %p'

重要提示，可以使用pg_receivewal实现多副本redolog的功能，类似oracle的redo log group


######  barman
工作原理
物理全備+歸檔備份（WAL日誌備份），從而達到任意時間點的恢復。即恢復全備後，通過指定WAL日誌的時間點、LSN等即可恢復到資料庫的任意時間點。
barman备份方法
backup_method = postgres  # streaming backup方式   使用了工具pg_basebackup+pg_receivewal
backup_method = rysnc     # rsync/ssh 方式    barman2.0之前的备份方式，支持增量备份

# 配置过程

一、配置需要备份的远程PG
1 修改postgresql.conf配置
listen_addresses = '*'
port = 5432
wal_level = replica  #11版本後改爲replica
archive_mode = on
archive_command = 'cp %p /var/lib/pgsql/13/data/pg_archive/%f'
max_wal_senders = 10  #建議大於等於3
synchronous_standby_names = '*'        #这个设置会造成事务提交hang主，需要临时再设置一下 synchronous_commit = local
hot_standby = on
log_filename = 'postgresql-%Y%m%d_%H%M.log'
2 修改pg_hba.conf配置

local   all             all                                       trust
host    all             all               0.0.0.0/0               md5
host    all             all               ::1/128                 trust
host    replication     barman            0.0.0.0/0               md5
host    replication     streaming_barman  0.0.0.0/0               md5
3 創建pg_archive，並設置用戶組

mkdir -p /var/lib/pgsql/13/data/pg_archive
chown postgres:postgres /var/lib/pgsql/13/data/pg_archive -R

4 啓動postgresql

systemctl enable postgresql-13
systemctl start postgresql-13

5 創建barman和barman_streaming用戶

su postgres
createuser -s -P barman
#設置密碼
createuser -P --replication streaming_barman
#設置密碼

二、barman安装和配置

在备份服务器上安装barman
yum install barman barman-cli
yum install postgresql13-contrib

修改barman的公共配置
vi /etc/barman.conf

parallel_jobs = 2   #併發數
immediate_checkpoint = true   #在執行back時是否會自動執行checkpoint

-bash-4.2$ cat /etc/barman.d/pga.conf |egrep -v ';|^$'
[pga]
description =  "Example of PostgreSQL Database (Streaming-Only)"
conninfo = host=pga user=barman dbname=postgres
streaming_conninfo = host=pga user=streaming_barman
backup_method = postgres
streaming_archiver = on
slot_name = barman

barman账号设置
su - barman
-bash-4.2$ cat .bashrc
export PATH="/usr/local/bin:/bin:/usr/bin:/usr/local/sbin:/usr/sbin:/usr/pgsql-13/bin:/usr/pgsql-13/bin"
export PGDATA="/var/lib/pgsql/13/data"

配置.pgpass免密
-bash-4.2$ cat .pgpass
pga:5432:*:streaming_barman:Foxconn123
pga:5432:*:barman:123456

barman账号下做免密验证
-bash-4.2$ psql -c 'select version()' -U barman -h pga postgres
                                                 version
---------------------------------------------------------------------------------------------------------
 PostgreSQL 13.4 on x86_64-pc-linux-gnu, compiled by gcc (GCC) 4.8.5 20150623 (Red Hat 4.8.5-44), 64-bit
(1 row)

-bash-4.2$ psql -c 'select version()' -U streaming_barman -h pga postgres
                                                 version
---------------------------------------------------------------------------------------------------------
 PostgreSQL 13.4 on x86_64-pc-linux-gnu, compiled by gcc (GCC) 4.8.5 20150623 (Red Hat 4.8.5-44), 64-bit
(1 row)


运行barman
-bash-4.2$ barman receive-wal --create-slot pga    创建slot
-bash-4.2$ barman cron         启用wal archiving,streaming archiver for 待备份的PG服务器
-bash-4.2$ barman check pga   验证远程服务器pga的各种条件

barman安装错误汇总
-bash-4.2$ barman check pga
Server pga:
        WAL archive: FAILED (please make sure WAL shipping is setup)
        PostgreSQL: OK
        superuser or standard user with backup privileges: OK
        PostgreSQL streaming: OK
        wal_level: OK
        replication slot: OK
        directories: OK
        retention policy settings: OK
        backup maximum age: OK (no last_backup_maximum_age provided)
        compression settings: OK
        failed backups: OK (there are 0 failed backups)
        minimum redundancy requirements: OK (have 0 backups, expected at least 0)
        pg_basebackup: OK
        pg_basebackup compatible: OK
        pg_basebackup supports tablespaces mapping: OK
        systemid coherence: OK (no system Id stored on disk)
        pg_receivexlog: OK
        pg_receivexlog compatible: OK
        receive-wal running: FAILED (See the Barman log file for more details)
        archiver errors: OK
碰到上述错误		
1 打开 wal archiving,streaming archiver for server pga
-bash-4.2$ barman cron
Starting WAL archiving for server pga
Starting streaming archiver for server pga
  

2 切换pga的wal file
-bash-4.2$ barman switch-wal --force --archive pga
The WAL file 000000010000000000000053 has been closed on server 'pga'
Waiting for the WAL file 000000010000000000000053 from server 'pga' (max: 30 seconds)
Processing xlog segments from streaming for pga
        000000010000000000000053
-bash-4.2$ barman check pga
Server pga:
        PostgreSQL: OK
        superuser or standard user with backup privileges: OK
        PostgreSQL streaming: OK
        wal_level: OK
        replication slot: OK
        directories: OK
        retention policy settings: OK
        backup maximum age: OK (no last_backup_maximum_age provided)
        compression settings: OK
        failed backups: OK (there are 0 failed backups)
        minimum redundancy requirements: OK (have 0 backups, expected at least 0)
        pg_basebackup: OK
        pg_basebackup compatible: OK
        pg_basebackup supports tablespaces mapping: OK
        systemid coherence: OK (no system Id stored on disk)
        pg_receivexlog: OK
        pg_receivexlog compatible: OK
        receive-wal running: OK
        archiver errors: OK
-bash-4.2$ barman replication-status pga
Status of streaming clients for server 'pga':
  Current LSN on master: 0/54000148
  Number of streaming clients: 1

  1. #1 Sync WAL streamer
     Application name: barman_receive_wal
     Sync stage      : 3/3 Remote write
     Communication   : TCP/IP
     IP Address      : 10.152.219.158 / Port: 53830 / Host: -
     User name       : streaming_barman
     Current state   : streaming (sync)
     Replication slot: barman
     WAL sender PID  : 1122
     Started at      : 2021-10-16 09:18:04.610226+00:00
     Sent LSN   : 0/54000148 (diff: 0 B)
     Write LSN  : 0/54000148 (diff: 0 B)
     Flush LSN  : 0/54000148 (diff: 0 B)
		
3 如果只是命令找不到路径，需要安装postgresql13-contrib包，并配置环境变量PATH
declare -x PATH="/usr/local/bin:/bin:/usr/bin:/usr/local/sbin:/usr/sbin:/usr/pgsql-13/bin:/usr/pgsql-13/bin"

# 开始备份
-bash-4.2$ barman backup pga
Starting backup using postgres method for server pga in /var/lib/barman/pga/base/20211016T092814
Backup start at LSN: 0/54000148 (000000010000000000000054, 00000148)
Starting backup copy via pg_basebackup for 20211016T092814
Copy done (time: 18 seconds)
Finalising the backup.
This is the first backup for server pga
WAL segments preceding the current backup have been found:
        000000010000000000000053 from server pga has been removed
Backup size: 2.8 GiB
Backup end at LSN: 0/56000000 (000000010000000000000055, 00000000)
Backup completed (start time: 2021-10-16 09:28:14.274585, elapsed time: 18 seconds)
Processing xlog segments from streaming for pga
        000000010000000000000054
        000000010000000000000055

-bash-4.2$ barman list-backup pga
pga 20211016T092814 - Sat Oct 16 09:28:32 2021 - Size: 2.8 GiB - WAL Size: 0 B
target可以为data, wal, full, standalone
-bash-4.2$ barman list-files --target data pga 20211016T092814
/var/lib/barman/pga/base/20211016T092814/backup.info
/var/lib/barman/pga/base/20211016T092814/data/pg_hba.conf
/var/lib/barman/pga/base/20211016T092814/data/postgresql.auto.conf
/var/lib/barman/pga/base/20211016T092814/data/postgresql.conf
/var/lib/barman/pga/base/20211016T092814/data/backup_label
/var/lib/barman/pga/base/20211016T092814/data/pg_ident.conf
/var/lib/barman/pga/base/20211016T092814/data/backup_manifest
/var/lib/barman/pga/base/20211016T092814/data/current_logfiles
/var/lib/barman/pga/base/20211016T092814/data/PG_VERSION
/var/lib/barman/pga/base/20211016T092814/data/pg_xact/0000
/var/lib/barman/pga/base/20211016T092814/data/pg_logical/replorigin_checkpoint
/var/lib/barman/pga/base/20211016T092814/data/log/postgresql-Sat.log
/var/lib/barman/pga/base/20211016T092814/data/pg_archive/000000010000000000000014
/var/lib/barman/pga/base/20211016T092814/data/pg_archive/00000001000000000000000E
/var/lib/barman/pga/base/20211016T092814/data/pg_archive/000000010000000000000026
。。。
/var/lib/barman/pga/base/20211016T092814/data/base/14174/2679
/var/lib/barman/pga/base/20211016T092814/data/base/14174/2703
/var/lib/barman/pga/base/20211016T092814/data/base/14174/3456
/var/lib/barman/pga/base/20211016T092814/data/pg_multixact/offsets/0000
/var/lib/barman/pga/base/20211016T092814/data/pg_multixact/members/0000
-bash-4.2$ barman list-files --target wal pga 20211016T092814
/var/lib/barman/pga/wals/0000000100000000/000000010000000000000055

-bash-4.2$ barman show-backup pga 20211016T092814
Backup 20211016T092814:
  Server Name            : pga
  System Id              : 7019560887058907630
  Status                 : DONE
  PostgreSQL Version     : 130004
  PGDATA directory       : /var/lib/pgsql/13/data

  Base backup information:
    Disk usage           : 2.8 GiB (2.8 GiB with WALs)
    Incremental size     : 2.8 GiB (-0.00%)
    Timeline             : 1
    Begin WAL            : 000000010000000000000055
    End WAL              : 000000010000000000000055
    WAL number           : 1
    Begin time           : 2021-10-16 09:28:14+00:00
    End time             : 2021-10-16 09:28:32.392481+00:00
    Copy time            : 18 seconds
    Estimated throughput : 159.0 MiB/s
    Begin Offset         : 40
    End Offset           : 0
    Begin LSN           : 0/55000028
    End LSN             : 0/56000000

  WAL information:
    No of files          : 0
    Disk usage           : 0 B
    Last available       : 000000010000000000000055

  Catalog information:
    Retention Policy     : not enforced
    Previous Backup      : - (this is the oldest base backup)
    Next Backup          : - (this is the latest base backup)

错误  -bash-4.2$ barman backup pga
ERROR: reuse_backup option is not supported by postgres backup_method
resue_backup只能和rysnc配合       reuse_backup做增量备份	

恢复
模拟pga故障
pga上操作
postgres=# drop database pgbench;
DROP DATABASE
然后停掉PG服务

barman上操作
-bash-4.2$ barman recover --target-time="2021-10-18 05:17:05.751485+00:00" --remote-ssh-command "ssh postgres@pga" pga 20211018T051648 $PGDATA
Starting remote restore for server pga using backup 20211018T051648
Destination directory: /var/lib/pgsql/13/data
Remote command: ssh postgres@pga
Doing PITR. Recovery target time: '2021-10-18 05:17:05.751485+00:00'
Copying the base backup.
Copying required WAL segments.
Generating recovery configuration
Identify dangerous settings in destination directory.

IMPORTANT
These settings have been modified to prevent data losses

postgresql.conf line 238: archive_command = false

Recovery completed (start time: 2021-10-19 01:10:33.923761, elapsed time: 36 seconds)

Your PostgreSQL server has been successfully prepared for recovery!

pga上操作
[root@pga ~]# systemctl start postgresql-13
[root@pga ~]# su - postgres
Last login: Tue Oct 19 01:13:49 UTC 2021
-bash-4.2$ psql
psql (13.4)
Type "help" for help.

postgres=# \l
                             List of databases
   Name    |  Owner   | Encoding  | Collate | Ctype |   Access privileges
-----------+----------+-----------+---------+-------+-----------------------
 pgbench   | postgres | SQL_ASCII | C       | C     |
 postgres  | postgres | SQL_ASCII | C       | C     |
 template0 | postgres | SQL_ASCII | C       | C     | =c/postgres          +
           |          |           |         |       | postgres=CTc/postgres
 template1 | postgres | SQL_ASCII | C       | C     | =c/postgres          +
           |          |           |         |       | postgres=CTc/postgres
(4 rows)

postgres=# \c pgbench
You are now connected to database "pgbench" as user "postgres".
pgbench=# \d
              List of relations
 Schema |       Name       | Type  |  Owner
--------+------------------+-------+----------
 public | pgbench_accounts | table | postgres
 public | pgbench_branches | table | postgres
 public | pgbench_history  | table | postgres
 public | pgbench_tellers  | table | postgres

 -bash-4.2$ /usr/pgsql-13/bin/pg_controldata
pg_control version number:            1300
Catalog version number:               202007201
Database system identifier:           7019560887058907630
Database cluster state:               in archive recovery           #不是生产模式，需删除recovery.signal文件后重启PG，才能变为in production，这里有个问题
pg_control last modified:             Tue Oct 19 01:22:39 2021
Latest checkpoint location:           0/58000100
Latest checkpoint's REDO location:    0/580000C8
Latest checkpoint's REDO WAL file:    000000010000000000000058
Latest checkpoint's TimeLineID:       1
Latest checkpoint's PrevTimeLineID:   1
Latest checkpoint's full_page_writes: on
Latest checkpoint's NextXID:          0:504
Latest checkpoint's NextOID:          24579
Latest checkpoint's NextMultiXactId:  1
Latest checkpoint's NextMultiOffset:  0
Latest checkpoint's oldestXID:        479
Latest checkpoint's oldestXID's DB:   1
Latest checkpoint's oldestActiveXID:  504
Latest checkpoint's oldestMultiXid:   1
Latest checkpoint's oldestMulti's DB: 1
Latest checkpoint's oldestCommitTsXid:0
Latest checkpoint's newestCommitTsXid:0
Time of latest checkpoint:            Mon Oct 18 05:21:49 2021
Fake LSN counter for unlogged rels:   0/3E8
Minimum recovery ending location:     0/58000320

实际操作过程中，如果删除recovery.signal文件后重启PG，restore and recovery就白做了
-bash-4.2$ mv recovery.signal recovery.signal.bk
-bash-4.2$ logout
[root@pga ~]# systemctl restart postgresql-13
[root@pga ~]# su - postgres
Last login: Tue Oct 19 07:45:25 UTC 2021
-bash-4.2$ psql
psql (13.4)
Type "help" for help.

postgres=# \l
                             List of databases
   Name    |  Owner   | Encoding  | Collate | Ctype |   Access privileges
-----------+----------+-----------+---------+-------+-----------------------
 postgres  | postgres | SQL_ASCII | C       | C     |
 template0 | postgres | SQL_ASCII | C       | C     | =c/postgres          +
           |          |           |         |       | postgres=CTc/postgres
 template1 | postgres | SQL_ASCII | C       | C     | =c/postgres          +
           |          |           |         |       | postgres=CTc/postgres
(3 rows)

log:    barman恢复后重启postgresql  starting point-in-time recovery to 2021-10-18 05:17:05.751485+00
2021-10-19 07:45:21.138 UTC [15977] LOG:  starting PostgreSQL 13.4 on x86_64-pc-linux-gnu, compiled by gcc (GCC) 4.8.5 20150623 (Red Hat 4.8.5-44), 64-bit
2021-10-19 07:45:21.140 UTC [15977] LOG:  listening on IPv4 address "0.0.0.0", port 5432
2021-10-19 07:45:21.140 UTC [15977] LOG:  listening on IPv6 address "::", port 5432
2021-10-19 07:45:21.142 UTC [15977] LOG:  listening on Unix socket "/var/run/postgresql/.s.PGSQL.5432"
2021-10-19 07:45:21.147 UTC [15977] LOG:  listening on Unix socket "/tmp/.s.PGSQL.5432"
2021-10-19 07:45:21.159 UTC [15979] LOG:  database system was interrupted; last known up at 2021-10-18 05:16:49 UTC
2021-10-19 07:45:21.159 UTC [15979] LOG:  creating missing WAL directory "pg_wal/archive_status"
cp: cannot stat 'barman_wal/00000002.history': No such file or directory
2021-10-19 07:45:21.255 UTC [15979] LOG:  starting point-in-time recovery to 2021-10-18 05:17:05.751485+00
2021-10-19 07:45:21.291 UTC [15979] LOG:  restored log file "000000010000000000000057" from archive
2021-10-19 07:45:21.301 UTC [15979] LOG:  redo starts at 0/57000028
2021-10-19 07:45:21.303 UTC [15979] LOG:  consistent recovery state reached at 0/57000138
2021-10-19 07:45:21.306 UTC [15977] LOG:  database system is ready to accept read only connections
2021-10-19 07:45:21.341 UTC [15979] LOG:  restored log file "000000010000000000000058" from archive
2021-10-19 07:45:21.345 UTC [15979] LOG:  recovery stopping before commit of transaction 504, time 2021-10-19 01:01:37.105917+00
2021-10-19 07:45:21.345 UTC [15979] LOG:  pausing at the end of recovery
2021-10-19 07:45:21.345 UTC [15979] HINT:  Execute pg_wal_replay_resume() to promote.
.......下面的操作是删除recovery.signal文件后重启PG,database system was shut down in recovery at 2021-10-19 07:46:19 UTC
2021-10-19 07:46:19.387 UTC [15977] LOG:  received fast shutdown request
2021-10-19 07:46:19.389 UTC [15977] LOG:  aborting any active transactions
2021-10-19 07:46:19.395 UTC [15982] LOG:  shutting down
2021-10-19 07:46:19.447 UTC [15977] LOG:  database system is shut down
2021-10-19 07:46:19.571 UTC [16043] LOG:  starting PostgreSQL 13.4 on x86_64-pc-linux-gnu, compiled by gcc (GCC) 4.8.5 20150623 (Red Hat 4.8.5-44), 64-bit
2021-10-19 07:46:19.571 UTC [16043] LOG:  listening on IPv4 address "0.0.0.0", port 5432
2021-10-19 07:46:19.572 UTC [16043] LOG:  listening on IPv6 address "::", port 5432
2021-10-19 07:46:19.575 UTC [16043] LOG:  listening on Unix socket "/var/run/postgresql/.s.PGSQL.5432"
2021-10-19 07:46:19.579 UTC [16043] LOG:  listening on Unix socket "/tmp/.s.PGSQL.5432"
2021-10-19 07:46:19.589 UTC [16045] LOG:  database system was shut down in recovery at 2021-10-19 07:46:19 UTC
2021-10-19 07:46:19.591 UTC [16045] LOG:  database system was not properly shut down; automatic recovery in progress
2021-10-19 07:46:19.596 UTC [16045] LOG:  redo starts at 0/580000C8
2021-10-19 07:46:19.840 UTC [16045] LOG:  redo done at 0/58000AD8
2021-10-19 07:46:19.879 UTC [16043] LOG:  database system is ready to accept connections

正确做法是，不手动删除recovery.signal文件
在psql中执行
postgres=# select pg_wal_replay_resume();
 pg_wal_replay_resume
----------------------

(1 row)

postgres=# \l
                             List of databases
   Name    |  Owner   | Encoding  | Collate | Ctype |   Access privileges
-----------+----------+-----------+---------+-------+-----------------------
 pgbench   | postgres | SQL_ASCII | C       | C     |                                   #DB还在
 postgres  | postgres | SQL_ASCII | C       | C     |
 template0 | postgres | SQL_ASCII | C       | C     | =c/postgres          +
           |          |           |         |       | postgres=CTc/postgres
 template1 | postgres | SQL_ASCII | C       | C     | =c/postgres          +
           |          |           |         |       | postgres=CTc/postgres
(4 rows)

日志：
2021-10-19 08:49:27.947 UTC [16405] LOG:  selected new timeline ID: 2
2021-10-19 08:49:28.112 UTC [16405] LOG:  archive recovery complete
cp: cannot stat 'barman_wal/00000001.history': No such file or directory
2021-10-19 08:49:28.170 UTC [16403] LOG:  database system is ready to accept connections
-bash-4.2$ ls -lh
total 201K
-rw------- 1 postgres postgres 16M Oct 19 08:47 000000010000000000000058
-rw------- 1 postgres postgres  51 Oct 19 08:49 00000002.history
-rw------- 1 postgres postgres 16M Oct 19 08:49 000000020000000000000058       timelineid变成2
-rw------- 1 postgres postgres 16M Oct 19 08:47 000000020000000000000059
drwx------ 2 postgres postgres   4 Oct 19 08:49 archive_status

-bash-4.2$ cat pg_wal/00000002.history
1       0/58000320      before 2021-10-19 01:01:37.105917+00


# 恢复数据到另一台DB
另一台DB  pgb的前提条件
1 安装postgresql-13, rsync, openssh-server包
2 从barman服务器上的barman账号免密登录 ssh postgres@pgb
-bash-4.2$ barman recover --target-time="2021-10-18 05:17:05.751485+00:00" --remote-ssh-command "ssh postgres@pgb" pga 20211018T051648 $PGDATA
Starting remote restore for server pga using backup 20211018T051648
Destination directory: /var/lib/pgsql/13/data
Remote command: ssh postgres@pgb
Doing PITR. Recovery target time: '2021-10-18 05:17:05.751485+00:00'
Copying the base backup.
Copying required WAL segments.
Generating recovery configuration
Identify dangerous settings in destination directory.

IMPORTANT
These settings have been modified to prevent data losses

postgresql.conf line 238: archive_command = false

Recovery completed (start time: 2021-10-19 02:57:16.605443, elapsed time: 39 seconds)

Your PostgreSQL server has been successfully prepared for recovery!

pgb上检查
[root@pgb ~]# systemctl start postgresql-13
[root@pgb ~]# su - postgres
Last login: Tue Oct 19 02:53:16 UTC 2021
-bash-4.2$ psql
psql (13.4)
Type "help" for help.

postgres=# \l
                             List of databases
   Name    |  Owner   | Encoding  | Collate | Ctype |   Access privileges
-----------+----------+-----------+---------+-------+-----------------------
 pgbench   | postgres | SQL_ASCII | C       | C     |
 postgres  | postgres | SQL_ASCII | C       | C     |
 template0 | postgres | SQL_ASCII | C       | C     | =c/postgres          +
           |          |           |         |       | postgres=CTc/postgres
 template1 | postgres | SQL_ASCII | C       | C     | =c/postgres          +
           |          |           |         |       | postgres=CTc/postgres
(4 rows)

postgres=# \c pgbench
You are now connected to database "pgbench" as user "postgres".
pgbench=# \d
              List of relations
 Schema |       Name       | Type  |  Owner
--------+------------------+-------+----------
 public | pgbench_accounts | table | postgres
 public | pgbench_branches | table | postgres
 public | pgbench_history  | table | postgres
 public | pgbench_tellers  | table | postgres
(4 rows)

pgbench=# select * from pgbench_accounts limit 2;
 aid | bid | abalance |                                        filler
-----+-----+----------+--------------------------------------------------------------------------------------
   1 |   1 |        0 |
   2 |   1 |        0 |
(2 rows)

-bash-4.2$ /usr/pgsql-13/bin/pg_controldata
pg_control version number:            1300
Catalog version number:               202007201
Database system identifier:           7019560887058907630
Database cluster state:               in archive recovery      不是生产模式
pg_control last modified:             Tue Oct 19 02:58:58 2021
Latest checkpoint location:           0/57000060
Latest checkpoint's REDO location:    0/57000028
Latest checkpoint's REDO WAL file:    000000010000000000000057
Latest checkpoint's TimeLineID:       1
Latest checkpoint's PrevTimeLineID:   1
Latest checkpoint's full_page_writes: on
Latest checkpoint's NextXID:          0:504
Latest checkpoint's NextOID:          24579
Latest checkpoint's NextMultiXactId:  1
Latest checkpoint's NextMultiOffset:  0
Latest checkpoint's oldestXID:        479
Latest checkpoint's oldestXID's DB:   1
Latest checkpoint's oldestActiveXID:  504
Latest checkpoint's oldestMultiXid:   1
Latest checkpoint's oldestMulti's DB: 1
Latest checkpoint's oldestCommitTsXid:0
Latest checkpoint's newestCommitTsXid:0
Time of latest checkpoint:            Mon Oct 18 05:16:49 2021
Fake LSN counter for unlogged rels:   0/3E8
Minimum recovery ending location:     0/57000138

-bash-4.2$ cat postgresql.auto.conf
# Do not edit this file manually!
# It will be overwritten by the ALTER SYSTEM command.
restore_command = 'cp barman_wal/%f %p'
recovery_end_command = 'rm -fr barman_wal'
recovery_target_time = '2021-10-18 05:17:05.751485+00:00'

如果要变成生产模式，直接  select pg_wal_replay_resume();

#后续。。。
pga在恢复后继续做barman backup会出错
需要以下几步
重新创建slot
-bash-4.2$ barman receive-wal --create-slot pga
重建partial文件
-bash-4.2$ barman receive-wal --reset pga
Resetting receive-wal directory status
Removing status file /var/lib/barman/pga/streaming/000000010000000000000059.partial
Creating status file /var/lib/barman/pga/streaming/000000020000000000000059.partial
重新运行barman cron
-bash-4.2$ barman cron
Starting WAL archiving for server pga
Starting streaming archiver for server pga
-bash-4.2$ barman check pga
Server pga:
        PostgreSQL: OK
        superuser or standard user with backup privileges: OK
        PostgreSQL streaming: OK
        wal_level: OK
        replication slot: OK
        directories: OK
        retention policy settings: OK
        backup maximum age: OK (no last_backup_maximum_age provided)
        compression settings: OK
        failed backups: OK (there are 0 failed backups)
        minimum redundancy requirements: OK (have 2 backups, expected at least 0)
        pg_basebackup: OK
        pg_basebackup compatible: OK
        pg_basebackup supports tablespaces mapping: OK
        systemid coherence: OK
        pg_receivexlog: OK
        pg_receivexlog compatible: OK
        receive-wal running: OK
        archiver errors: OK
继续做barman backup会hang住
-bash-4.2$ barman backup pga
Starting backup using postgres method for server pga in /var/lib/barman/pga/base/20211020T065732
Backup start at LSN: 0/590001D8 (000000020000000000000059, 000001D8)
Starting backup copy via pg_basebackup for 20211020T065732





^CERROR: Backup failed copying files.
DETAILS: KeyboardInterrupt

原因是：did recovery after the first backup operation. Then Barman set a string #BARMAN# ahead archive_command = 'barman-wal-archive backup pg %p' command into the postgresql.conf file
删除#BARMAN#，改成
archive_command = 'cp %p /var/lib/pgsql/13/data/pg_archive/%f'          # command to use to archive a logfile segment
#archive_command = false

然后重启PG，重新做barman backup
-bash-4.2$ barman backup pga
Starting backup using postgres method for server pga in /var/lib/barman/pga/base/20211020T092328
Backup start at LSN: 0/CF0000D8 (0000000200000000000000CF, 000000D8)
Starting backup copy via pg_basebackup for 20211020T092328
Copy done (time: 36 seconds)
Finalising the backup.
Backup size: 6.0 GiB
Backup end at LSN: 0/D1000060 (0000000200000000000000D1, 00000060)
Backup completed (start time: 2021-10-20 09:23:28.928455, elapsed time: 36 seconds)
Processing xlog segments from streaming for pga
        0000000200000000000000D0
        0000000200000000000000D1
		
-bash-4.2$ barman list-backup pga
pga 20211020T092328 - Wed Oct 20 09:24:05 2021 - Size: 6.0 GiB - WAL Size: 0 B
pga 20211020T091708 - FAILED
pga 20211020T071448 - FAILED
pga 20211020T065732 - FAILED
pga 20211018T051648 - Mon Oct 18 05:17:05 2021 - Size: 2.9 GiB - WAL Size: 16.0 MiB
pga 20211016T092814 - Sat Oct 16 09:28:32 2021 - Size: 2.8 GiB - WAL Size: 32.0 MiB
-bash-4.2$ barman status pga
Server pga:
        Description: Example of PostgreSQL Database (Streaming-Only)
        Active: True
        Disabled: False
        PostgreSQL version: 13.4
        Cluster state: in production
        pgespresso extension: Not available
        Current data size: 2.7 GiB
        PostgreSQL Data directory: /var/lib/pgsql/13/data
        Current WAL segment: 0000000200000000000000D2
        Passive node: False
        Retention policies: enforced (mode: auto, retention: REDUNDANCY 3, WAL retention: MAIN)
        No. of available backups: 3
        First available backup: 20211016T092814
        Last available backup: 20211020T092328
        Minimum redundancy requirements: satisfied (3/0)
再备份一次，测试retention policy		
-bash-4.2$ barman backup pga
Starting backup using postgres method for server pga in /var/lib/barman/pga/base/20211020T092717
Backup start at LSN: 0/D21E95F0 (0000000200000000000000D2, 001E95F0)
Starting backup copy via pg_basebackup for 20211020T092717
Copy done (time: 38 seconds)
Finalising the backup.
Backup size: 6.0 GiB
Backup end at LSN: 0/D4000000 (0000000200000000000000D3, 00000000)
Backup completed (start time: 2021-10-20 09:27:17.449045, elapsed time: 38 seconds)
Processing xlog segments from streaming for pga
        0000000200000000000000D2
        0000000200000000000000D3
根据retention policy,最旧的backup  pga 20211016T092814	被删除	
-bash-4.2$ barman list-backup pga
pga 20211020T092717 - Wed Oct 20 09:27:55 2021 - Size: 6.0 GiB - WAL Size: 0 B
pga 20211020T092328 - Wed Oct 20 09:24:05 2021 - Size: 6.0 GiB - WAL Size: 32.0 MiB
pga 20211020T091708 - FAILED
pga 20211020T071448 - FAILED
pga 20211020T065732 - FAILED
pga 20211018T051648 - Mon Oct 18 05:17:05 2021 - Size: 2.9 GiB - WAL Size: 16.0 MiB



The archive_command is the traditional method to archive WAL files.

The value of this PostgreSQL configuration parameter must be a shell command to be executed by the PostgreSQL server 
to copy the WAL files to the Barman incoming directory.
-bash-4.2$ ps -ef |grep bar
postgres  3003  2953  0 08:37 ?        00:00:03 postgres: walsender streaming_barman 10.152.219.158(40616) streaming 0/57000000
incoming目录是archive_command 发过来的日志, wals目录是 pg_receivwal发过来的streaming日志
-bash-4.2$ du -sh incoming/ wals
133M    incoming/
133M    wals





########### repmgr高可用
架构
-----------------------------
rep01          primary
rep02          standby
repwitness     witness
-----------------------------
0 前提准备
安装  yum install repmgr_13
配置双向ssh免密登录  
从rep01上   ssh postgres@rep02
从rep02上   ssh postgres@rep01

1 配置primary节点
1.1 初始化DB /usr/pgsql-13/bin/postgresql-13-setup initdb
systemctl enable --now postgresql-13

1.2 配置postgresql参数
listen_addresses = '*' 
max_wal_senders = 10
max_replication_slots = 10
wal_level = 'replica'
wal_log_hints = on
hot_standby = on
archive_mode = on
archive_command = '/bin/true'
重启PG

1.3 创建repmgr 数据库及用户
psql:  create user repmgr with password 'repmgr' superuser replication;
psql:  create database repmgr owner repmgr;
psql:  ALTER USER repmgr SET search_path TO repmgr, public;

vi postgresql.conf 加入
shared_preload_libraries = 'repmgr'

1.4 配置repmgr服务
-bash-4.2$ tail -10 /etc/repmgr/13/repmgr.conf

node_id=1
node_name='rep01'
conninfo='host=rep01 port=5432 dbname=repmgr user=repmgr connect_timeout=2'
data_directory='/var/lib/pgsql/13/data'
pg_bindir='/usr/pgsql-13/bin'
config_directory='/var/lib/pgsql/13/data'
log_level=INFO
log_facility=STDERR
log_file='/var/lib/pgsql/13/data/log/repmgr.log'

1.5 配置pg_hba.conf
-bash-4.2$ cat pg_hba.conf |grep trust
local repmgr            repmgr                                  trust
local replication            repmgr                                  trust
host repmgr            repmgr          0.0.0.0/0                trust
host repmgr            repmgr          127.0.0.1/32                trust
host replication            repmgr          0.0.0.0/0                trust
host replication            repmgr          127.0.0.1/32                trust
重启PG
在standby节点rep02验证是否可以访问rep01
-bash-4.2$ psql 'host=rep01 user=repmgr dbname=repmgr connect_timeout=2'
psql (13.4)
Type "help" for help.

repmgr=#

1.6 向repmgr注册primary节点
-bash-4.2$ /usr/pgsql-13/bin/repmgr primary register
INFO: connecting to primary database...
NOTICE: attempting to install extension "repmgr"
NOTICE: "repmgr" extension successfully installed
NOTICE: primary node record (ID: 1) registered
查看状态
-bash-4.2$ /usr/pgsql-13/bin/repmgr service status
 ID | Name  | Role    | Status    | Upstream | repmgrd     | PID | Paused? | Upstream last seen
----+-------+---------+-----------+----------+-------------+-----+---------+--------------------
 1  | rep01 | primary | * running |          | not running | n/a | n/a     | n/a

repmgr=# select * from repmgr.nodes;
 node_id | upstream_node_id | active | node_name |  type   | location | priority |                             conninfo
   | repluser | slot_name |        config_file
---------+------------------+--------+-----------+---------+----------+----------+---------------------------------------------------------------
---+----------+-----------+----------------------------
       1 |                  | t      | rep01     | primary | default  |      100 | host=rep01 port=5432 dbname=repmgr user=repmgr connect_timeout
=2 | repmgr   |           | /etc/repmgr/13/repmgr.conf
(1 row)
repmgr=# select * from pg_stat_replication;    此时没有主备流复制
 pid | usesysid | usename | application_name | client_addr | client_hostname | client_port | backend_start | backend_xmin | state | sent_lsn | wr
ite_lsn | flush_lsn | replay_lsn | write_lag | flush_lag | replay_lag | sync_priority | sync_state | reply_time
-----+----------+---------+------------------+-------------+-----------------+-------------+---------------+--------------+-------+----------+---
--------+-----------+------------+-----------+-----------+------------+---------------+------------+------------
(0 rows)

2 克隆standby节点
2.1 配置repmgr服务
-bash-4.2$ tail -10 /etc/repmgr/13/repmgr.conf
node_id=2
node_name='rep02'
conninfo='host=rep02 port=5432 dbname=repmgr user=repmgr connect_timeout=2'
data_directory='/var/lib/pgsql/13/data'
pg_bindir='/usr/pgsql-13/bin'
config_directory='/var/lib/pgsql/13/data'
log_level=INFO
log_facility=STDERR
log_file='/var/lib/pgsql/13/data/log/repmgr.log'

2.2 standby clone dry run
/usr/pgsql-13/bin/repmgr -h rep01 -U repmgr -d repmgr standby clone --dry-run

2.3 正式standby clone
/usr/pgsql-13/bin/repmgr -h rep01 -U repmgr -d repmgr standby clone

standby clone做完后就能查看流复制是否工作
检查备机的流复制状态
postgres=# select * from pg_stat_wal_receiver;
-[ RECORD 1 ]---------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
pid                   | 642
status                | streaming
receive_start_lsn     | 0/4000000
receive_start_tli     | 1
written_lsn           | 0/40007E0
flushed_lsn           | 0/40007E0
received_tli          | 1
last_msg_send_time    | 2021-10-22 05:35:42.836854+00
last_msg_receipt_time | 2021-10-22 05:35:42.837077+00
latest_end_lsn        | 0/40007E0
latest_end_time       | 2021-10-22 05:35:42.836854+00
slot_name             |                             没有用到复制槽
sender_host           | rep01
sender_port           | 5432

****************************
To enable repmgr to use replication slots, set the boolean parameter use_replication_slots in repmgr.conf:

       use_replication_slots=true
Replication slots must be enabled in postgresql.conf by setting the parameter max_replication_slots to at least the number of expected standbys (changes to this parameter require a server restart).

When cloning a standby, repmgr will automatically generate an appropriate slot name, which is stored in the repmgr.nodes table, and create the slot on the upstream node:

    repmgr=# SELECT node_id, upstream_node_id, active, node_name, type, priority, slot_name
               FROM repmgr.nodes ORDER BY node_id;
     node_id | upstream_node_id | active | node_name |  type   | priority |   slot_name
    ---------+------------------+--------+-----------+---------+----------+---------------
           1 |                  | t      | node1     | primary |      100 | repmgr_slot_1
           2 |                1 | t      | node2     | standby |      100 | repmgr_slot_2
           3 |                1 | t      | node3     | standby |      100 | repmgr_slot_3
     (3 rows)
****************************

2.4 启动PG，并向repmgr注册standby节点
/usr/pgsql-13/bin/repmgr -h rep01 -U repmgr -d repmgr standby register
2.5 查看集群状态
-bash-4.2$ /usr/pgsql-13/bin/repmgr -h rep01 -U repmgr -d repmgr cluster show
 ID | Name  | Role    | Status    | Upstream | Location | Priority | Timeline | Connection string
----+-------+---------+-----------+----------+----------+----------+----------+------------------------------------------------------------------
 1  | rep01 | primary | * running |          | default  | 100      | 1        | host=rep01 port=5432 dbname=repmgr user=repmgr connect_timeout=2
 2  | rep02 | standby |   running | rep01    | default  | 100      | 1        | host=rep02 port=5432 dbname=repmgr user=repmgr connect_timeout=2

conninfo              | user=repmgr passfile=/var/lib/pgsql/.pgpass channel_binding=prefer connect_timeout=2 dbname=replication host=rep01 port=5432 application_name=rep02 fallback_application_name=walreceiver sslmode=prefer sslcompression=0 ssl_min_protocol_version=TLSv1.2 gssencmode=prefer krbsrvname=postgres target_session_attrs=any

 到此 流复制服务配置完成

# 集群主备switchover
 -bash-4.2$ /usr/pgsql-13/bin/repmgr -h rep01 -U repmgr -d repmgr standby switchover
WARNING: following problems with command line parameters detected:
  database connection parameters not required when executing STANDBY SWITCHOVER
NOTICE: executing switchover on node "rep02" (ID: 2)
NOTICE: attempting to pause repmgrd on 2 nodes
NOTICE: repmgrd not running on node "rep02" (ID: 2), not pausing
NOTICE: local node "rep02" (ID: 2) will be promoted to primary; current primary "rep01" (ID: 1) will be demoted to standby
NOTICE: stopping current primary node "rep01" (ID: 1)
NOTICE: issuing CHECKPOINT on node "rep01" (ID: 1)
DETAIL: executing server command "/usr/pgsql-13/bin/pg_ctl  -D '/var/lib/pgsql/13/data' -W -m fast stop"
INFO: checking for primary shutdown; 1 of 60 attempts ("shutdown_check_timeout")
INFO: checking for primary shutdown; 2 of 60 attempts ("shutdown_check_timeout")
NOTICE: current primary has been cleanly shut down at location 0/5000028
NOTICE: promoting standby to primary
DETAIL: promoting server "rep02" (ID: 2) using pg_promote()
NOTICE: waiting up to 60 seconds (parameter "promote_check_timeout") for promotion to complete
NOTICE: STANDBY PROMOTE successful
DETAIL: server "rep02" (ID: 2) was successfully promoted to primary
NOTICE: node "rep02" (ID: 2) promoted to primary, node "rep01" (ID: 1) demoted to standby
NOTICE: switchover was successful
DETAIL: node "rep02" is now primary and node "rep01" is attached as standby
NOTICE: STANDBY SWITCHOVER has completed successfully
-bash-4.2$ /usr/pgsql-13/bin/repmgr -h rep01 -U repmgr -d repmgr cluster show
 ID | Name  | Role    | Status    | Upstream | Location | Priority | Timeline | Connection string
----+-------+---------+-----------+----------+----------+----------+----------+------------------------------------------------------------------
 1  | rep01 | standby |   running | rep02    | default  | 100      | 1        | host=rep01 port=5432 dbname=repmgr user=repmgr connect_timeout=2
 2  | rep02 | primary | * running |          | default  | 100      | 2        | host=rep02 port=5432 dbname=repmgr user=repmgr connect_timeout=2

主备切换log on rep02 
2021-10-22 05:47:11.361 UTC [642] LOG:  replication terminated by primary server
2021-10-22 05:47:11.361 UTC [642] DETAIL:  End of WAL reached on timeline 1 at 0/50000A0.
2021-10-22 05:47:11.361 UTC [642] FATAL:  could not send end-of-streaming message to primary: no COPY in progress
2021-10-22 05:47:11.362 UTC [638] LOG:  invalid record length at 0/50000A0: wanted 24, got 0
2021-10-22 05:47:11.369 UTC [742] FATAL:  could not connect to the primary server: could not connect to server: Connection refused
                Is the server running on host "rep01" (10.152.219.175) and accepting
                TCP/IP connections on port 5432?
2021-10-22 05:47:12.488 UTC [638] LOG:  received promote request
2021-10-22 05:47:12.488 UTC [638] LOG:  redo done at 0/5000028
2021-10-22 05:47:12.488 UTC [638] LOG:  last completed transaction was at log time 2021-10-22 05:35:40.888136+00
2021-10-22 05:47:12.494 UTC [638] LOG:  selected new timeline ID: 2          # timeline id变成2
2021-10-22 05:47:12.658 UTC [638] LOG:  archive recovery complete
2021-10-22 05:47:12.675 UTC [636] LOG:  database system is ready to accept connections

-bash-4.2$ ls pg_wal
000000010000000000000005.partial  00000002.history  000000020000000000000005  000000020000000000000006  archive_status

主备切换log on rep01
2021-10-22 05:47:11.159 UTC [1264] LOG:  received fast shutdown request
2021-10-22 05:47:11.160 UTC [1264] LOG:  aborting any active transactions
2021-10-22 05:47:11.160 UTC [1275] FATAL:  terminating connection due to administrator command
2021-10-22 05:47:11.161 UTC [1515] FATAL:  terminating connection due to administrator command
2021-10-22 05:47:11.171 UTC [1264] LOG:  background worker "logical replication launcher" (PID 1273) exited with exit code 1
2021-10-22 05:47:11.173 UTC [1267] LOG:  shutting down
2021-10-22 05:47:11.175 UTC [1973] FATAL:  the database system is shutting down
2021-10-22 05:47:11.363 UTC [1264] LOG:  database system is shut down
2021-10-22 05:47:14.018 UTC [1986] LOG:  starting PostgreSQL 13.4 on x86_64-pc-linux-gnu, compiled by gcc (GCC) 4.8.5 20150623 (Red Hat 4.8.5-44), 64-bit
2021-10-22 05:47:14.018 UTC [1986] LOG:  listening on IPv4 address "0.0.0.0", port 5432
2021-10-22 05:47:14.018 UTC [1986] LOG:  listening on IPv6 address "::", port 5432
2021-10-22 05:47:14.020 UTC [1986] LOG:  listening on Unix socket "/var/run/postgresql/.s.PGSQL.5432"
2021-10-22 05:47:14.026 UTC [1986] LOG:  listening on Unix socket "/tmp/.s.PGSQL.5432"
2021-10-22 05:47:14.036 UTC [1988] LOG:  database system was shut down at 2021-10-22 05:47:11 UTC
2021-10-22 05:47:14.037 UTC [1988] LOG:  entering standby mode
2021-10-22 05:47:14.045 UTC [1988] LOG:  consistent recovery state reached at 0/50000A0
2021-10-22 05:47:14.045 UTC [1988] LOG:  invalid record length at 0/50000A0: wanted 24, got 0
2021-10-22 05:47:14.049 UTC [1986] LOG:  database system is ready to accept read only connections
2021-10-22 05:47:14.072 UTC [1992] LOG:  fetching timeline history file for timeline 2 from primary server
2021-10-22 05:47:14.078 UTC [1992] LOG:  started streaming WAL from primary at 0/5000000 on timeline 1
2021-10-22 05:47:14.078 UTC [1992] LOG:  replication terminated by primary server
2021-10-22 05:47:14.078 UTC [1992] DETAIL:  End of WAL reached on timeline 1 at 0/50000A0.
2021-10-22 05:47:14.080 UTC [1988] LOG:  new target timeline is 2
2021-10-22 05:47:14.081 UTC [1992] LOG:  restarted WAL streaming at 0/5000000 on timeline 2
2021-10-22 05:47:14.305 UTC [1988] LOG:  redo starts at 0/50000A0

rep02上的repmgr.events信息
repmgr=# select * from events;
 node_id |           event           | successful |        event_timestamp        |                                      details
---------+---------------------------+------------+-------------------------------+-----------------------------------------------------------------------------------
       1 | cluster_created           | t          | 2021-10-22 03:40:53.385727+00 |
       1 | primary_register          | t          | 2021-10-22 03:40:53.404635+00 |
       1 | repmgrd_start             | t          | 2021-10-22 05:21:33.882816+00 | monitoring cluster primary "rep01" (ID: 1)
       2 | standby_clone             | t          | 2021-10-22 05:31:39.50342+00  | cloned from host "rep01", port 5432; backup method: pg_basebackup; --force: N
       2 | standby_register          | t          | 2021-10-22 05:33:39.629399+00 | standby registration succeeded; upstream node ID is 1
       1 | child_node_new_connect    | t          | 2021-10-22 05:33:45.265582+00 | new standby "rep02" (ID: 2) has connected
       2 | standby_promote           | t          | 2021-10-22 05:47:13.495569+00 | server "rep02" (ID: 2) was successfully promoted to primary
       2 | standby_switchover        | t          | 2021-10-22 05:47:14.192874+00 | node "rep02" (ID: 2) promoted to primary, node "rep01" (ID: 1) demoted to standby
       1 | repmgrd_standby_reconnect | t          | 2021-10-22 05:47:23.178747+00 | node has become a standby, monitoring connection to upstream node 2
(9 rows)

# witness节点配置
rep01和rep02需要免密 ssh postgres@repwitness

[root@repwitness ~]# cat /etc/hosts
127.0.1.1       repwitness
127.0.0.1   localhost localhost.localdomain localhost4 localhost4.localdomain4
::1         localhost localhost.localdomain localhost6 localhost6.localdomain6
10.152.219.175   rep01
10.152.219.75    rep02
10.152.219.3     repwitness


1 初始化PG
/usr/pgsql-13/bin/postgresql-13-setup initdb

2 配置PG
2.1 配置pg_hba.conf
# TYPE  DATABASE        USER            ADDRESS                 METHOD
# "local" is for Unix domain socket connections only
local repmgr            repmgr                                  trust
local replication            repmgr                                  trust
local   all             all                                     peer
# IPv4 local connections:
host repmgr            repmgr          0.0.0.0/0                trust
host repmgr            repmgr          127.0.0.1/32                trust
host replication            repmgr          0.0.0.0/0                trust
host replication            repmgr          127.0.0.1/32                trust
host    all             all             127.0.0.1/32            scram-sha-256
# IPv6 local connections:
host    all             all             ::1/128                 scram-sha-256
# Allow replication connections from localhost, by a user with the
# replication privilege.
local   replication     all                                     peer
host    replication     all             127.0.0.1/32            scram-sha-256
host    replication     all             ::1/128                 scram-sha-256

2.2 配置postgresql.conf
listen_addresses = '*'          # what IP address(es) to listen on;
shared_preload_libraries = 'repmgr'     # (change requires restart)
重启PG

3 配置repmgr服务
-bash-4.2$ tail -10 /etc/repmgr/13/repmgr.conf
node_id=4
node_name='repwitness'
conninfo='host=repwitness port=5432 dbname=repmgr user=repmgr connect_timeout=2'
data_directory='/var/lib/pgsql/13/data'
pg_bindir='/usr/pgsql-13/bin'
config_directory='/var/lib/pgsql/13/data'
log_level=INFO
log_facility=STDERR
log_file='/var/lib/pgsql/13/data/log/repmgr.log'


-bash-4.2$ /usr/pgsql-13/bin/repmgr -h rep02 -U repmgr -d repmgr witness register
INFO: connecting to witness node "repwitness" (ID: 4)
INFO: connecting to primary node
NOTICE: attempting to install extension "repmgr"
NOTICE: "repmgr" extension successfully installed
INFO: witness registration complete
NOTICE: witness node "repwitness" (ID: 4) successfully registered
-bash-4.2$ /usr/pgsql-13/bin/repmgr cluster show
 ID | Name       | Role    | Status    | Upstream | Location | Priority | Timeline | Connection string
----+------------+---------+-----------+----------+----------+----------+----------+-----------------------------------------------------------------------
 1  | rep01      | standby |   running | rep02    | default  | 100      | 2        | host=rep01 port=5432 dbname=repmgr user=repmgr connect_timeout=2
 2  | rep02      | primary | * running |          | default  | 100      | 2        | host=rep02 port=5432 dbname=repmgr user=repmgr connect_timeout=2
 4  | repwitness | witness | * running | rep02    | default  | 0        | n/a      | host=repwitness port=5432 dbname=repmgr user=repmgr connect_timeout=2
witness服务配置完成

# 手动故障切换
1 停主库  此时repo02是主库
[root@rep02 ~]# systemctl stop postgresql-13
rep01上查看
/usr/pgsql-13/bin/repmgr cluster show
 ID | Name       | Role    | Status        | Upstream | Location | Priority | Timeline | Connection string                                       
----+------------+---------+---------------+----------+----------+----------+----------+-----------------------------------------------------------------------
 1  | rep01      | standby |   running     | ? rep02  | default  | 100      | 2        | host=rep01 port=5432 dbname=repmgr user=repmgr connect_timeout=2
 2  | rep02      | primary | ? unreachable | ?        | default  | 100      |          | host=rep02 port=5432 dbname=repmgr user=repmgr connect_timeout=2
 4  | repwitness | witness | * running     | ? rep02  | default  | 0        | n/a      | host=repwitness port=5432 dbname=repmgr user=repmgr connect_timeout=2

WARNING: following issues were detected
  - unable to connect to node "rep01" (ID: 1)'s upstream node "rep02" (ID: 2)
  - unable to determine if node "rep01" (ID: 1) is attached to its upstream node "rep02" (ID: 2)
  - unable to connect to node "rep02" (ID: 2)
  - node "rep02" (ID: 2) is registered as an active primary but is unreachable
  - unable to connect to node "repwitness" (ID: 4)'s upstream node "rep02" (ID: 2)

HINT: execute with --verbose option to see connection error messages

2 手动提升standby
-bash-4.2$ /usr/pgsql-13/bin/repmgr standby promote
WARNING: 1 sibling nodes found, but option "--siblings-follow" not specified
DETAIL: these nodes will remain attached to the current primary:
  repwitness (node ID: 4, witness server)
NOTICE: promoting standby to primary
DETAIL: promoting server "rep01" (ID: 1) using pg_promote()
NOTICE: waiting up to 60 seconds (parameter "promote_check_timeout") for promotion to complete
NOTICE: STANDBY PROMOTE successful
DETAIL: server "rep01" (ID: 1) was successfully promoted to primary
-bash-4.2$ /usr/pgsql-13/bin/repmgr cluster show
 ID | Name       | Role    | Status    | Upstream | Location | Priority | Timeline | Connection string                                           
----+------------+---------+-----------+----------+----------+----------+----------+-----------------------------------------------------------------------
 1  | rep01      | primary | * running |          | default  | 100      | 3        | host=rep01 port=5432 dbname=repmgr user=repmgr connect_timeout=2
 2  | rep02      | primary | - failed  | ?        | default  | 100      |          | host=rep02 port=5432 dbname=repmgr user=repmgr connect_timeout=2
 4  | repwitness | witness | * running | ? rep02  | default  | 0        | n/a      | host=repwitness port=5432 dbname=repmgr user=repmgr connect_timeout=2

WARNING: following issues were detected
  - unable to connect to node "rep02" (ID: 2)
  - unable to connect to node "repwitness" (ID: 4)'s upstream node "rep02" (ID: 2)

HINT: execute with --verbose option to see connection error messages

3 原主库rep02重新加入集群
-bash-4.2$ /usr/pgsql-13/bin/repmgr -h rep01 -U repmgr -d repmgr node rejoin --force-rewind
NOTICE: rejoin target is node "rep01" (ID: 1)
NOTICE: pg_rewind execution required for this node to attach to rejoin target node 1
DETAIL: rejoin target server's timeline 3 forked off current database system timeline 2 before current recovery point 0/7000028
NOTICE: executing pg_rewind
DETAIL: pg_rewind command is "/usr/pgsql-13/bin/pg_rewind -D '/var/lib/pgsql/13/data' --source-server='host=rep01 port=5432 dbname=repmgr user=repmgr connect_timeout=2'"
NOTICE: 0 files copied to /var/lib/pgsql/13/data
NOTICE: setting node 2's upstream to node 1
WARNING: unable to ping "host=rep02 port=5432 dbname=repmgr user=repmgr connect_timeout=2"
DETAIL: PQping() returned "PQPING_NO_RESPONSE"
NOTICE: starting server using "/usr/pgsql-13/bin/pg_ctl  -w -D '/var/lib/pgsql/13/data' start"
NOTICE: NODE REJOIN successful
DETAIL: node 2 is now attached to node 1
-bash-4.2$ /usr/pgsql-13/bin/repmgr -h rep01 -U repmgr -d repmgr cluster show
 ID | Name       | Role    | Status    | Upstream | Location | Priority | Timeline | Connection string
----+------------+---------+-----------+----------+----------+----------+----------+-----------------------------------------------------------------------
 1  | rep01      | primary | * running |          | default  | 100      | 3        | host=rep01 port=5432 dbname=repmgr user=repmgr connect_timeout=2
 2  | rep02      | standby |   running | rep01    | default  | 100      | 2        | host=rep02 port=5432 dbname=repmgr user=repmgr connect_timeout=2
 4  | repwitness | witness | * running | rep02    | default  | 0        | n/a      | host=repwitness port=5432 dbname=repmgr user=repmgr connect_timeout=2

# 自动故障切换
当前主库为rep01
-bash-4.2$ /usr/pgsql-13/bin/pg_ctl -D /var/lib/pgsql/13/data -m immediate stop
waiting for server to shut down.... done

rep02上查看，rep02由standby提升为primary了
-bash-4.2$ /usr/pgsql-13/bin/repmgr -h rep01 -U repmgr -d repmgr cluster show
WARNING: the following problems were found in the configuration file:
  monitoring_interval_secs='5': unknown name/value pair provided; ignoring
 ID | Name       | Role    | Status    | Upstream | Location | Priority | Timeline | Connection string
----+------------+---------+-----------+----------+----------+----------+----------+-----------------------------------------------------------------------
 1  | rep01      | primary | - failed  | ?        | default  | 100      |          | host=rep01 port=5432 dbname=repmgr user=repmgr connect_timeout=2
 2  | rep02      | primary | * running |          | default  | 100      | 4        | host=rep02 port=5432 dbname=repmgr user=repmgr connect_timeout=2
 4  | repwitness | witness | * running | rep02    | default  | 0        | n/a      | host=repwitness port=5432 dbname=repmgr user=repmgr connect_timeout=2

主库的恢复        
在rep01上，node rejoin rewind操作，让rep01变成rep02的从库
-bash-4.2$  /usr/pgsql-13/bin/repmgr -h rep02 -U repmgr -d repmgr node rejoin --force-rewind
WARNING: the following problems were found in the configuration file:
  monitoring_interval_secs='5': unknown name/value pair provided; ignoring
NOTICE: rejoin target is node "rep02" (ID: 2)
NOTICE: pg_rewind execution required for this node to attach to rejoin target node 2
DETAIL: rejoin target server's timeline 4 forked off current database system timeline 3 before current recovery point 0/8000028
NOTICE: executing pg_rewind
DETAIL: pg_rewind command is "/usr/pgsql-13/bin/pg_rewind -D '/var/lib/pgsql/13/data' --source-server='host=rep02 port=5432 dbname=repmgr user=repmgr connect_timeout=2'"
NOTICE: 0 files copied to /var/lib/pgsql/13/data
NOTICE: setting node 1's upstream to node 2
WARNING: unable to ping "host=rep01 port=5432 dbname=repmgr user=repmgr connect_timeout=2"
DETAIL: PQping() returned "PQPING_NO_RESPONSE"
NOTICE: starting server using "/usr/pgsql-13/bin/pg_ctl  -w -D '/var/lib/pgsql/13/data' start"
NOTICE: NODE REJOIN successful
DETAIL: node 1 is now attached to node 2
-bash-4.2$  /usr/pgsql-13/bin/repmgr -h rep02 -U repmgr -d repmgr cluster show
WARNING: the following problems were found in the configuration file:
  monitoring_interval_secs='5': unknown name/value pair provided; ignoring
 ID | Name       | Role    | Status    | Upstream | Location | Priority | Timeline | Connection string                                           
----+------------+---------+-----------+----------+----------+----------+----------+-----------------------------------------------------------------------
 1  | rep01      | standby |   running | rep02    | default  | 100      | 3        | host=rep01 port=5432 dbname=repmgr user=repmgr connect_timeout=2
 2  | rep02      | primary | * running |          | default  | 100      | 4        | host=rep02 port=5432 dbname=repmgr user=repmgr connect_timeout=2
 4  | repwitness | witness | * running | rep02    | default  | 0        | n/a      | host=repwitness port=5432 dbname=repmgr user=repmgr connect_timeout=2

 如果直接起主库的话，就会有两个running的主库
 从rep01上看
/usr/pgsql-13/bin/repmgr cluster show
WARNING: the following problems were found in the configuration file:
  monitoring_interval_secs='5': unknown name/value pair provided; ignoring
 ID | Name       | Role    | Status               | Upstream | Location | Priority | Timeline | Connection string                                
----+------------+---------+----------------------+----------+----------+----------+----------+-----------------------------------------------------------------------
 1  | rep01      | primary | * running            |          | default  | 100      | 3        | host=rep01 port=5432 dbname=repmgr user=repmgr connect_timeout=2
 2  | rep02      | standby | ! running as primary |          | default  | 100      | 4        | host=rep02 port=5432 dbname=repmgr user=repmgr connect_timeout=2
 4  | repwitness | witness | * running            | rep02    | default  | 0        | n/a      | host=repwitness port=5432 dbname=repmgr user=repmgr connect_timeout=2

WARNING: following issues were detected
  - node "rep02" (ID: 2) is registered as standby but running as primary
从rep02上看
-bash-4.2$ /usr/pgsql-13/bin/repmgr -h rep01 -U repmgr -d repmgr cluster show
WARNING: the following problems were found in the configuration file:
  monitoring_interval_secs='5': unknown name/value pair provided; ignoring
 ID | Name       | Role    | Status    | Upstream | Location | Priority | Timeline | Connection string
----+------------+---------+-----------+----------+----------+----------+----------+-----------------------------------------------------------------------
 1  | rep01      | primary | ! running |          | default  | 100      | 3        | host=rep01 port=5432 dbname=repmgr user=repmgr connect_timeout=2
 2  | rep02      | primary | * running |          | default  | 100      | 4        | host=rep02 port=5432 dbname=repmgr user=repmgr connect_timeout=2
 4  | repwitness | witness | * running | rep02    | default  | 0        | n/a      | host=repwitness port=5432 dbname=repmgr user=repmgr connect_timeout=2

WARNING: following issues were detected
  - node "rep01" (ID: 1) is running but the repmgr node record is inactive
  
简介： PostgreSQL pg_rewind，时间线修复，脑裂修复，flashback - 从库开启读写后，回退为只读从库。异步主从发生角色切换后，主库rewind为新主库的从库
背景
1、PG物理流复制的从库，当激活后，可以开启读写，使用pg_rewind可以将从库回退为只读从库的角色。而不需要重建整个从库。

2、当异步主从发生角色切换后，主库的wal目录中可能还有没完全同步到从库的内容，因此老的主库无法直接切换为新主库的从库。使用pg_rewind可以修复老的主库，使之成为新主库的只读从库。而不需要重建整个从库。

3、如果没有pg_rewind，遇到以上情况，需要完全重建从库。或者你可以使用存储层快照，回退回脑裂以前的状态。又或者可以使用文件系统快照，回退回脑裂以前的状态。

原理与修复步骤
1、使用pg_rewind功能的前提条件：必须开启full page write，必须开启wal hint或者data block checksum。

2、需要被修复的库：从激活点开始，所有的WAL必须存在pg_wal目录中。如果WAL已经被覆盖，只要有归档，拷贝到pg_wal目录即可。

3、新的主库，从激活点开始，产生的所有WAL必须存在pg_wal目录中，或者已归档，并且被修复的库可以使用restore_command访问到这部分WAL。

4、修改(source db)新主库或老主库配置，允许连接。

5、修复时，连接新主库，得到切换点。或连接老主库，同时比对当前要修复的新主库的TL与老主库进行比对，得到切换点。

6、解析需要被修复的库的从切换点到现在所有的WAL。同时连接source db(新主库（或老主库）)，进行回退操作（被修改或删除的BLOCK从source db获取并覆盖，新增的BLOCK，直接抹除。）回退到切换点的状态。

7、修改被修复库(target db)的recovery.conf, postgresql.conf配置。

8、启动target db，连接source db接收WAL，或restore_command配置接收WAL，从切换点开始所有WAL，进行apply。

9、target db现在是source db的从库。 