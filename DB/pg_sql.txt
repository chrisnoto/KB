用docker跑个测试
docker run -d \
    --name postgres-mongo-fdw \
	-p 5432:5432 \
    -e POSTGRES_PASSWORD=Foxconn123 \
    -e PGDATA=/var/lib/postgresql/data/pgdata \
    fuww/postgresql-mongodb-fdw:latest

#########  概念 ##########
在 Postgresql中是以下的關係
Computer -> Cluter -> Catalog -> Schema -> Database Object (Table/View 等等)

一台電腦可以有多個 Cluster,在 Oracle 叫 Instance
一個 Cluster 可以有多個 Catalog ,包含Postgresql在內,許多資料庫會另外稱作 Database.
一個 Database 可以有多個 Schema, 又叫做  namespace of relations (關聯式物件), 還有相關存取規則(ACL).	
postgres=# \l
                                  List of databases
   Name    |  Owner   | Encoding |   Collate   |    Ctype    |   Access privileges
-----------+----------+----------+-------------+-------------+-----------------------
 postgres  | postgres | UTF8     | en_US.UTF-8 | en_US.UTF-8 |
 template0 | postgres | UTF8     | en_US.UTF-8 | en_US.UTF-8 | =c/postgres          +
           |          |          |             |             | postgres=CTc/postgres
 template1 | postgres | UTF8     | en_US.UTF-8 | en_US.UTF-8 | =c/postgres          +
           |          |          |             |             | postgres=CTc/postgres
(3 rows)

postgres=# select * from information_schema.information_schema_catalog_name;
 catalog_name
--------------
 postgres
(1 row)

两个隐藏schema   pg_catalog和information_schema
postgres=# \dn      隐藏的看不到
  List of schemas
  Name  |  Owner
--------+----------
 public | postgres
(1 row)

postgres=# select table_schema
postgres-#   from information_schema.tables
postgres-#  group by table_schema;
    table_schema
--------------------
 public
 pg_catalog
 information_schema

postgres=# \dn pg_catalog
    List of schemas
    Name    |  Owner
------------+----------
 pg_catalog | postgres
(1 row)

postgres=# \dn information_schema
        List of schemas
        Name        |  Owner
--------------------+----------
 information_schema | postgres
(1 row)
	
	
如果想知道这些快捷命令后面用了什么SQL，可以开启-E选项
-bash-4.2$ psql -E
psql (13.3)
Type "help" for help.

postgres=# \l
********* QUERY **********
SELECT d.datname as "Name",
       pg_catalog.pg_get_userbyid(d.datdba) as "Owner",
       pg_catalog.pg_encoding_to_char(d.encoding) as "Encoding",
       d.datcollate as "Collate",
       d.datctype as "Ctype",
       pg_catalog.array_to_string(d.datacl, E'\n') AS "Access privileges"
FROM pg_catalog.pg_database d
ORDER BY 1;
**************************

                                  List of databases
   Name    |  Owner   | Encoding |   Collate   |    Ctype    |   Access privileges
-----------+----------+----------+-------------+-------------+-----------------------
 postgres  | postgres | UTF8     | en_US.UTF-8 | en_US.UTF-8 |
 template0 | postgres | UTF8     | en_US.UTF-8 | en_US.UTF-8 | =c/postgres          +
           |          |          |             |             | postgres=CTc/postgres
 template1 | postgres | UTF8     | en_US.UTF-8 | en_US.UTF-8 | =c/postgres          +
           |          |          |             |             | postgres=CTc/postgres
或者postgres=# \set ECHO_HIDDEN on

# 自增数据类型 serial
postgres=# create table t2(id serial not null,name text);
CREATE TABLE

# 数据类型 enum
create type color_t as enum('blue', 'red', 'gray', 'black');

drop table if exists cars;

create table cars (
  brand text
, model text
, color color_t
);

insert into cars(brand, model, color) values 
('ferari', 'testarosa', 'red'),
('aston martin', 'db2', 'blue'),
('bentley', 'mulsanne', 'gray'),
('ford', 'T', 'black');

# 数据类型domain
接著來看一個 Create Domain 的例子,為了與 Oracle Date 資料型態相容.
CREATE DOMAIN tdate
    AS timestamp(0) without time zone;

使用了基本資料型態 timestamp(0) without time zone

在psql 使用 \dD ,可以列出現在Database 的 自定義 Domain

List of domains
+-[ RECORD 1 ]-------------------------------+
| Schema    | miku                           |
| Name      | tdate                          |
| Type      | timestamp(0) without time zone |
| Collation |                                |
| Nullable  |                                |
| Default   |                                |
| Check     |                                |
+-----------+--------------------------------+

這樣就能很容易了解到 定義 Domain 是基於其他基本資料型態,可以定義新的 Collation , 
這樣我們就能指定 Collation 方便排序使用.
還有指定 Nullable , Default, 還有建立前面提到過的 Check 運算式.

create domain 是 ANSI SQL 標準.
有了 domain, 我們可以很方便的定義 domain specific type, 讓我們開發系統時,
有符合領域特性的 type system.

接著我們來看實例

create domain md5 as
text not null
check (
    length(value) = 32
);

create table ithelp191002 (
  fname text
, checksum md5
);

insert into ithelp191002 values
('passwd', 'abcd123xxx');

ERROR:  23514: value for domain md5 violates check constraint "md5_check"
SCHEMA NAME:  miku
DATATYPE NAME:  md5
CONSTRAINT NAME:  md5_check

回報錯誤了...

insert into ithelp191002 values
('passwd', '76a2173be6393254e72ffa4d6df1030a');

這樣就正確了.

# 生成列 由其他列计算而来
postgres=# create table tax1(salary numeric,taxindex numeric,tax numeric generated always as (salary*taxindex) stored);
CREATE TABLE
postgres=# insert into tax1 values(10000,0.13);
INSERT 0 1
postgres=# select * from tax1;
-[ RECORD 1 ]-----
salary   | 10000
taxindex | 0.13
tax      | 1300.00

# hstore类型
postgres=# CREATE TABLE books (
postgres(#    id serial primary key,
postgres(#    title VARCHAR (255),
postgres(#    attr hstore
postgres(# );
CREATE TABLE
postgres=# INSERT INTO books (title, attr)
postgres-# VALUES
postgres-#    (
postgres(#       'PostgreSQL Tutorial',
postgres(#       '"paperback" => "243",
postgres'#       "publisher" => "postgresqltutorial.com",
postgres'#       "language"  => "English",
postgres'#       "ISBN-13"   => "978-1449370000",
postgres'#        "weight"   => "11.2 ounces"'
postgres(#    );
INSERT 0 1
postgres=# INSERT INTO books (title, attr)
postgres-# VALUES
postgres-#    (
postgres(#       'PostgreSQL Cheat Sheet',
postgres(#       '
postgres'# "paperback" => "5",
postgres'# "publisher" => "postgresqltutorial.com",
postgres'# "language"  => "English",
postgres'# "ISBN-13"   => "978-1449370001",
postgres'# "weight"    => "1 ounces"'
postgres(#    );
INSERT 0 1
postgres=# select * from books;
 id |         title          |                                                                  attr
----+------------------------+----------------------------------------------------------------------------------------------------------------------------------------
  1 | PostgreSQL Tutorial    | "weight"=>"11.2 ounces", "ISBN-13"=>"978-1449370000", "language"=>"English", "paperback"=>"243", "publisher"=>"postgresqltutorial.com"
  2 | PostgreSQL Cheat Sheet | "weight"=>"1 ounces", "ISBN-13"=>"978-1449370001", "language"=>"English", "paperback"=>"5", "publisher"=>"postgresqltutorial.com"
(2 rows)

返回hstore列所有key
postgres=# select akeys(attr) from books;
                     akeys
-----------------------------------------------
 {weight,ISBN-13,language,paperback,publisher}
 {weight,ISBN-13,language,paperback,publisher}
(2 rows)
或者使用skeys()函数返回key集合：
postgres=# select skeys(attr) from books;
   skeys
-----------
 weight
 ISBN-13
 language
 paperback
 publisher
 weight
 ISBN-13
 language
 paperback
 publisher

返回hstore列所有value
postgres=# select avals(attr) from books;
或者使用svals()函数返回结果集：
postgres=# select svals(attr) from books;

转换hstore为json
postgres=# select title,hstore_to_json(attr) from books;
         title          |                                                              hstore_to_json
------------------------+------------------------------------------------------------------------------------------------------------------------------------------
 PostgreSQL Tutorial    | {"weight": "11.2 ounces", "ISBN-13": "978-1449370000", "language": "English", "paperback": "243", "publisher": "postgresqltutorial.com"}
 PostgreSQL Cheat Sheet | {"weight": "1 ounces", "ISBN-13": "978-1449370001", "language": "English", "paperback": "5", "publisher": "postgresqltutorial.com"}
(2 rows)


each函数转换hstore数据为结果集
postgres=# select title,(each(attr)).* from books;
         title          |    key    |         value
------------------------+-----------+------------------------
 PostgreSQL Tutorial    | weight    | 11.2 ounces
 PostgreSQL Tutorial    | ISBN-13   | 978-1449370000
 PostgreSQL Tutorial    | language  | English
 PostgreSQL Tutorial    | paperback | 243
 PostgreSQL Tutorial    | publisher | postgresqltutorial.com
 PostgreSQL Cheat Sheet | weight    | 1 ounces
 PostgreSQL Cheat Sheet | ISBN-13   | 978-1449370001
 PostgreSQL Cheat Sheet | language  | English
 PostgreSQL Cheat Sheet | paperback | 5
 PostgreSQL Cheat Sheet | publisher | postgresqltutorial.com


查询特定key的值
postgres=# select attr->'ISBN-13' AS isbn from books;
      isbn
----------------
 978-1449370000
 978-1449370001
(2 rows)
where子句
postgres=# SELECT
postgres-#    attr -> 'weight' AS weight
postgres-# FROM
postgres-#    books
postgres-# WHERE
postgres-#    attr -> 'ISBN-13' = '978-1449370000';
   weight
-------------
 11.2 ounces
(1 row)

增
UPDATE books
SET attr = attr || '"freeshipping"=>"yes"' :: hstore;
删
UPDATE books 
SET attr = delete(attr, 'freeshipping');
改
UPDATE books
SET attr = attr || '"freeshipping"=>"no"' :: hstore;


# 查询postgres 参数
postgres=# select * from pg_settings where name in ('wal_level','archive_mode','archive_command');

# 导出select查询
Either: 
 SELECT * FROM table \g filename
to just output to the file 'filename', or:
 select * from lineshoot \g |cat >> /solsolute/path/filename
to append to the file. Both in psql, or:
 echo 'SELECT * FROM table' | psql database >> test.out
from your terminal.


# centos8 上安装pgsql 12

[root@c8-cilent1 ~]# dnf module list postgresql
Last metadata expiration check: 1:04:36 ago on Fri 13 Aug 2021 02:48:24 PM CST.
CentOS-8 - AppStream
Name                           Stream                     Profiles                               Summary
postgresql                     10 [d]                     client, server [d]                     PostgreSQL server and client module
postgresql                     12                         client, server [d]                     PostgreSQL server and client module
postgresql                     9.6                        client, server [d]                     PostgreSQL server and client module

Hint: [d]efault, [e]nabled, [x]disabled, [i]nstalled
默认安装10版本，现enable 12版本，进行12版本的安装
[root@c8-cilent1 ~]# dnf module enable postgresql:12
Last metadata expiration check: 1:05:26 ago on Fri 13 Aug 2021 02:48:24 PM CST.
Dependencies resolved.
========================================================================================================================================================
 Package                             Arch                               Version                               Repository                           Size
========================================================================================================================================================
Enabling module streams:
 postgresql                                                             12

Transaction Summary
========================================================================================================================================================

Is this ok [y/N]: y
Complete!

Switching module streams does not alter installed packages (see 'module enable' in dnf(8) for details)
[root@c8-cilent1 ~]# dnf module list postgresql
Last metadata expiration check: 1:05:39 ago on Fri 13 Aug 2021 02:48:24 PM CST.
CentOS-8 - AppStream
Name                           Stream                     Profiles                               Summary
postgresql                     10 [d]                     client, server [d]                     PostgreSQL server and client module
postgresql                     12 [e]                     client, server [d]                     PostgreSQL server and client module
postgresql                     9.6                        client, server [d]                     PostgreSQL server and client module

Hint: [d]efault, [e]nabled, [x]disabled, [i]nstalled
[root@c8-cilent1 ~]# dnf install postgresql-server
Last metadata expiration check: 1:06:19 ago on Fri 13 Aug 2021 02:48:24 PM CST.
Dependencies resolved.
========================================================================================================================================================
 Package                             Arch                     Version                                                 Repository                   Size
========================================================================================================================================================
Installing:
 postgresql-server                   x86_64                   12.1-2.module_el8.1.0+273+979c16e6                      AppStream                   5.5 M
Installing dependencies:
 libpq                               x86_64                   12.4-1.el8_2                                            AppStream                   195 k
 postgresql                          x86_64                   12.1-2.module_el8.1.0+273+979c16e6                      AppStream                   1.4 M

Transaction Summary
========================================================================================================================================================
Install  3 Packages

Total download size: 7.1 M
Installed size: 30 M
Is this ok [y/N]:y

[root@c8-cilent1 ~]# postgresql-setup --initdb
 * Initializing database in '/var/lib/pgsql/data'
 * Initialized, logs are in /var/lib/pgsql/initdb_postgresql.log
[root@c8-cilent1 ~]# systemctl enable --now postgresql









postgresql-13主从 streaming复制
===========================================================================================================================
1 概念和原理
一.物理流复制
物理流复制是一种数据库主备同步技术，该特性同步的数据是数据库中物理页面变化数据（WAL），该模式备库的底层数据页面状态和主库完全相同，这样的实现方案让数据库主备以及同步状态都非常稳定。
二.流复制中的角色
1. 主库 backend 进程，它负责执行用户的 SQL，在修改数据前会先记录 WAL（Write-Ahead Logging）日志。这些日志中事物提交日志（CommitTransaction）由 backend 进程负责写到磁盘。
2. 主库 WALsender 进程，负责把 WAL 日志发送给备库的 WALreceiver 进程。
3. 备库 WALreceiver 进程，负责接收 WALsender 发送的 WAL 日志，并持久化到存储。
4. 备库 startup 进程，负责恢复 WALsender 写到磁盘上的 WAL 日志，把数据 apply 到数据页面上。
异步流复制和同步流复制
一.异步流复制
默认状态下的流复制是以异步方式工作的，也就是说主库写本地数据和 WAL 日志，WALsender 异步的把数据发送给备库，备库收到数据后再异步的做数据恢复。
异步模式可以做到较好的性能，它的劣势是：极端情况下，主库如果当机，被库被激活成主库，部分 WAL 没有发送到备库，可能造成数据丢失。
二.同步流复制
相对于异步模式，PostgreSQL 还支持同步模式的流复制。同模模式可以细分为三级
1. REMOTE_WRITE 保证该事务的所有数据被备库收到（备库收到数据并调用 write 写磁盘，但并未持久化到磁盘）
2. REMOTE_FLUSH 保证该事务的所有数据在备库持久化到磁盘（调用 flush，但只读查询看不到）
3. REMOTE_APPLY 保证该事务的所有数据在备库被恢复到数据页面（恢复进程读取并解析 WAL，再 APPLY 到数据页面，在备库上执行的只读查询能看到数据的变化）
三. 同步流复制源码解析
1. MVCC 机制和数据可见性
简单的说 PostgreSQL ACID 是基于 MVCC 和 WAL 技术。数据的修改过程可以简单描述为
1. 首先 backend 开启是一个事务,获得一个事务号 XID;
2. 在这个事务中对数据的任意修改，都被 XID 标记。
3. 其他 backend 在扫描数据时，会看到被这个 XID 修改过的数据，根据当前的隔离级别，选择对这些数据是否可见（默认的读已提交隔离级别看不到这些数据）。
4. 只有当此 XID 最后被标记成 commit （写 WAL commit log 和写 clog）后，其他的 backend 才能看到这个 XID 修改的数据。
2. 同模流复制的关键点
总结一下，实现流复制的同步模式，关键点在每个事务提交或回滚时，保证它产生的所有数据变化日志，即 WAL 都“同步”到备库。最后一条 WAL commit log 尤为关键。
3. 如何实现同步流复制
铺垫完所有概念和前提技术，我们看看同步模式具体是怎么实现的。以事务提交流程为例：
1. [主库 backend 进程]调用 RecordTransactionCommit 中写 WAL commit log，获得这条日志在在 WAL 中的位置 XLogRecPtr
2. [主库 backend 进程]完成写 WAL 后，进入 SyncRepWaitForLSN 等待 WAL 日志“同步”到备库。具体做法是:在共享内存中创建一个等待队列 SHMQueue 记录 XLogRecPtr，并调动 WaitLatch，让出 CPU 等待被唤醒。
3. [主库 WALsender 进程]相应所有备库的 WALreceiver 拉取 WAL 的请求。把 WAL 发送给所有备库。
4. [备库 WALreceiver 进程]写 WAL 的偏移（LogstreamResult.Write）和持久化 WAL 偏移（LogstreamResult.Flush）记录下来。
5. [备库 startup 进程]不断的恢复数据，把当前恢复到的 WAL 位点放在共享内存 xlogctl->lastReplayedEndRecPtr 中。
6. [备库 WALreceiver 进程]不断通过 r 报文和主库 WALsender 进程同步的状态，即 XLOGWRITELSN XLOGREMOTELSN XLOGAPPLYLSN（XLogWalRcvSendReply）
7. [主库 WALsender 进程]收到备库发送的 r 报文后，检查共享内存中的等待队列 SHMQueue, 根据备库反馈的位点结合 SHMQueue，唤醒那些等待队列中睡眠的 主库 backend 进程（WalSndWaitForWal）。
8. [主库 backend 进程]被唤醒，当前事务成功提交，SQL 执行完成返回给客户端。
===========================================================================================================================
2 配置
# Install the repository RPM:
sudo yum install -y https://download.postgresql.org/pub/repos/yum/reporpms/EL-7-x86_64/pgdg-redhat-repo-latest.noarch.rpm

# Install PostgreSQL:
sudo yum install -y postgresql13-server

# Optionally initialize the database and enable automatic start:
sudo /usr/pgsql-13/bin/postgresql-13-setup initdb
sudo systemctl enable postgresql-13
sudo systemctl start postgresql-13

环境变量
export PATH=/usr/pgsql-13/bin:$PATH
export PGDATA=/var/lib/postgresql/data

cat /etc/hosts
127.0.0.1   localhost localhost.localdomain localhost4 localhost4.localdomain4
::1         localhost localhost.localdomain localhost6 localhost6.localdomain6
10.67.39.58  postgres-1
10.67.39.59  postgres-2

------主库操作
1 初始化数据库
postgresql-setup --initdb

2 在pg_hba.conf增加一行
host    replication     repl            postgres-2              trust

3 修改postgresql.conf
listen_addresses = '*'
synchronous_standby_names = '*'
# - Archiving -
archive_mode = on              
archive_command = 'test ! -f /opt/archivedir/%f && cp %p /opt/archivedir/%f'

4 重启postgresql
5 创建复制用户
create user repl replication LOGIN CONNECTION LIMIT 30 ENCRYPTED PASSWORD 'Foxconn123';

---------从库操作
从库只安装数据库软件，不进行数据库初始化
/usr/pgsql-13/bin/pg_basebackup --pgdata=$PGDATA --format=p --write-recovery-conf --checkpoint=fast --label=mffb --progress --host=postgres-1 --port=5432 --username=repl
***在PG12之前，-R备份结束之后会自动生成recovery.conf文件，用来做流复制判断主从同步的信息。但是从PG12开始，这个文件已经不需要了。***
***只需要在参数文件postgresql.conf中配置primary_conninfo参数即可。***

修改potgresql.conf， 这个配置文件从主库复制来
primary_conninfo = 'host=10.67.39.58 port=5432 user=repl password=Foxconn123'
primary_slot_name = 'postgres2_slot'

---------主库操作
在主库创建replication slot
select * from pg_create_physical_replication_slot('postgres2_slot');
select slot_name,slot_type,active,wal_status from pg_replication_slots;

---------从库操作
systemctl start postgresql-13
如果从库设置正确的话，可以从log里看到
2021-07-14 06:07:25.820 UTC [852] LOG:  started streaming WAL from primary at 0/3000000 on timeline 1

---------在主库再次检查
postgres=# select slot_name,slot_type,active,wal_status from pg_replication_slots;
   slot_name    | slot_type | active | wal_status
----------------+-----------+--------+------------
 standby_slot   | physical  | f      |
 postgres2_slot | physical  | t      | reserved
---------观察进程
从库进程
-bash-4.2$ ps -ef |grep wal
postgres   852 17759  0 06:07 ?        00:00:01 postgres: walreceiver streaming 0/302FA60
主库进程
-bash-4.2$ ps -ef|grep wal
postgres  2481 18063  0 06:07 ?        00:00:00 postgres: walsender repl 10.67.39.59(38252) streaming 0/302FA60

--------主库观察同步状态
postgres=# select * from pg_stat_replication;
-[ RECORD 1 ]----+------------------------------
pid              | 2481
usesysid         | 16384
usename          | repl
application_name | walreceiver
client_addr      | 10.67.39.59
client_hostname  | postgres-2
client_port      | 38252
backend_start    | 2021-07-14 06:07:28.239589+00
backend_xmin     |
state            | streaming
sent_lsn         | 0/4000148
write_lsn        | 0/4000148
flush_lsn        | 0/4000148
replay_lsn       | 0/4000148
write_lag        |
flush_lag        |
replay_lag       |
sync_priority    | 1
sync_state       | sync
reply_time       | 2021-07-14 07:05:54.037038+00

--------从库观察同步状态
postgres=# select * from pg_stat_wal_receiver;
-[ RECORD 1 ]---------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
pid                   | 852
status                | streaming
receive_start_lsn     | 0/3000000
receive_start_tli     | 1
written_lsn           | 0/4000148
flushed_lsn           | 0/4000148
received_tli          | 1
last_msg_send_time    | 2021-07-14 07:04:26.345695+00
last_msg_receipt_time | 2021-07-14 07:04:23.79761+00
latest_end_lsn        | 0/4000148
latest_end_time       | 2021-07-14 06:40:52.494625+00
slot_name             | postgres2_slot
sender_host           | postgres-1
sender_port           | 5432
conninfo              | user=repl passfile=/var/lib/pgsql/.pgpass channel_binding=prefer dbname=replication host=postgres-1 port=5432 fallback_application_name=walreceiver sslmode=prefer sslcompression=0 ssl_min_protocol_version=TLSv1.2 gssencmode=prefer krbsrvname=postgres target_session_attrs=any

 ---------测试
 在主库create table, 从库观察
 
postgres=# select pg_is_in_recovery();       主库是f代表false ；备库是t，代表true
 pg_is_in_recovery
-------------------
 t


切归档
[root@postgres-1 archivedir]# ls -lh
total 33M
-rw-------. 1 postgres postgres 16M Jul 13 09:20 000000010000000000000001
-rw-------. 1 postgres postgres 16M Jul 13 09:20 000000010000000000000002
-rw-------. 1 postgres postgres 316 Jul 13 09:20 000000010000000000000002.00000028.backup

postgres=# select pg_switch_wal();
 pg_switch_wal
---------------
 0/302FA78
(1 row)

[root@postgres-1 archivedir]# ls -lh
total 49M
-rw-------. 1 postgres postgres 16M Jul 13 09:20 000000010000000000000001
-rw-------. 1 postgres postgres 16M Jul 13 09:20 000000010000000000000002
-rw-------. 1 postgres postgres 316 Jul 13 09:20 000000010000000000000002.00000028.backup
-rw-------. 1 postgres postgres 16M Jul 14 06:36 000000010000000000000003
或者
postgres=# select * from pg_stat_get_archiver();
-[ RECORD 1 ]------+-----------------------------
archived_count     | 11
last_archived_wal  | 000000010000000000000008
last_archived_time | 2021-07-14 09:07:57.06432+00
failed_count       | 0
last_failed_wal    |
last_failed_time   |
stats_reset        | 2021-07-13 08:26:45.98489+00

postgres=# select pg_switch_wal();
-[ RECORD 1 ]-+----------
pg_switch_wal | 0/901BD78

postgres=# select * from pg_stat_get_archiver();
-[ RECORD 1 ]------+------------------------------
archived_count     | 12
last_archived_wal  | 000000010000000000000009
last_archived_time | 2021-07-15 06:21:10.562539+00
failed_count       | 0
last_failed_wal    |
last_failed_time   |
stats_reset        | 2021-07-13 08:26:45.98489+00

# 数据库之外创建用户和数据库
createuser --pwprompt zabbix
createdb -O zabbix -E Unicode -T template0 zabbix

# 创建用户和赋权
zabbix=# create user chensen with password 'chensen';

zabbix=# grant select on users to chensen;
GRANT
zabbix=# \dp+ users;
                               Access privileges
 Schema | Name  | Type  |   Access privileges   | Column privileges | Policies
--------+-------+-------+-----------------------+-------------------+----------
 public | users | table | zabbix=arwdDxt/zabbix+|                   |
        |       |       | chensen=r/zabbix      |                   |
(1 row)

zabbix=# grant update,insert,delete,truncate on users to chensen;
GRANT
zabbix=# \dp+ users;
                               Access privileges
 Schema | Name  | Type  |   Access privileges   | Column privileges | Policies
--------+-------+-------+-----------------------+-------------------+----------
 public | users | table | zabbix=arwdDxt/zabbix+|                   |
        |       |       | chensen=arwdD/zabbix  |                   |
(1 row)


## copy命令进行导入导出
# 导出
copy 表名 to '文件名' with csv;
copy (select a.hostid,a.name,c.name from hosts as a inner join hosts_groups as b on a.hostid=b.hostid inner join hstgrp as c on b.groupid=c.groupid where a.name not like 'Template%') to '/tmp/zabbixhost.csv' with csv;
# 导入
postgres=# create table staff(name text,team text,position text,height integer,weight integer,age numeric);
CREATE TABLE

postgres=# \copy staff from '/var/lib/pgsql/sample2.csv' with csv header delimiter ',' encoding 'UTF8';
COPY 1034
窗口函数
select groupid,hostid,hostgroupid,row_number() over(partition by groupid order by hostgroupid) as hostgroupid_asc from hosts_groups;
 groupid | hostid | hostgroupid | hostgroupid_asc
---------+--------+-------------+-----------------
       4 |  10084 |          92 |               1
       8 |  10093 |         175 |               1
       8 |  10095 |         177 |               2
       8 |  10094 |         178 |               3
       8 |  10096 |         179 |               4
       8 |  10097 |         180 |               5
       8 |  10098 |         181 |               6
       8 |  10099 |         182 |               7
       8 |  10100 |         183 |               8
       8 |  10101 |         184 |               9
       8 |  10102 |         185 |              10
       8 |  10103 |         186 |              11
       8 |  10050 |         187 |              12
       8 |  10183 |         209 |              13

# 绑定变量和执行计划
create table t3(id serial,t text);
\d t3
insert into t3(t) select 'Linux' from generate_series(1,100);
select * from t3;
insert into t3(t) select 'Windows' from generate_series(1,50);
select * from t3;
create index idx_t3_t on t3(t);
analyze t3;
explain select count(*) from t3 where t='Linux';
prepare mypan(text) as select count(*) from t3 where t=$1;
explain execute mypan('Linux');

##############################  FDW ############################
FDW的安装
# Install the repository RPM:
sudo yum install -y https://download.postgresql.org/pub/repos/yum/reporpms/EL-7-x86_64/pgdg-redhat-repo-latest.noarch.rpm
# postgresql自带的fdw 如 file_fdw,  postgrel_fdw
yum install postgresql13-contrib
# 其他的fdw，安装包如下
[root@postgres-1 ~]# rpm -qa |grep fdw
mysql_fdw_13-2.6.0-1.rhel7.x86_64
redis_fdw_13-1.1-1.rhel7.x86_64
sqlite_fdw_13-2.0.0-1.rhel7.x86_64
mongo_fdw13-5.2.7-1.rhel7.x86_64
	   
#####   mysql_fdw
postgres@u1804:~$ psql
psql (10.18 (Ubuntu 10.18-0ubuntu0.18.04.1))
Type "help" for help.

postgres=# create extension mysql_fdw;
CREATE EXTENSION
postgres=# create server zabbixdb
postgres-# foreign data wrapper mysql_fdw
postgres-# options (host '10.67.51.113',port '3306');
CREATE SERVER
postgres=# create user mapping for chensen
server zabbixdb
options (username 'root',password 'vSTJ456');
CREATE USER MAPPING
postgres=# create foreign table tf_interface(interfaceid bigint,hostid bigint,main int,type int,useip int,ip varchar(64),dns varchar(64),port varchar(64)) server zabbixdb options (dbname 'zabbix',table_name 'interface');
CREATE FOREIGN TABLE
postgres=# \dew
                 List of foreign-data wrappers
   Name    |  Owner   |      Handler      |      Validator
-----------+----------+-------------------+---------------------
 mysql_fdw | postgres | mysql_fdw_handler | mysql_fdw_validator
(1 row)

postgres=# \des
          List of foreign servers
   Name   |  Owner   | Foreign-data wrapper
----------+----------+----------------------
 zabbixdb | postgres | mysql_fdw
(1 row)

postgres=# \des+ zabbixdb
                                                      List of foreign servers
   Name   |  Owner   | Foreign-data wrapper | Access privileges | Type | Version |            FDW options             | Description
----------+----------+----------------------+-------------------+------+---------+------------------------------------+-------------
 zabbixdb | postgres | mysql_fdw            |                   |      |         | (host '10.67.51.113', port '3306') |
(1 row)

postgres=# \dE
                List of relations
 Schema |     Name     |     Type      |  Owner
--------+--------------+---------------+----------
 public | tf_interface | foreign table | postgres
(1 row)

postgres=> \d tf_interface
                        Foreign table "public.tf_interface"
   Column    |         Type          | Collation | Nullable | Default | FDW options
-------------+-----------------------+-----------+----------+---------+-------------
 interfaceid | bigint                |           |          |         |
 hostid      | bigint                |           |          |         |
 main        | integer               |           |          |         |
 type        | integer               |           |          |         |
 useip       | integer               |           |          |         |
 ip          | character varying(64) |           |          |         |
 dns         | character varying(64) |           |          |         |
 port        | character varying(64) |           |          |         |
Server: zabbixdb
FDW options: (dbname 'zabbix', table_name 'interface')
	   
#####  redis_fdw
postgres=# create extension redis_fdw;
CREATE EXTENSION

postgres=# create server redis_51164
foreign data wrapper redis_fdw
options(host '10.67.51.164',port '6379');
CREATE SERVER

postgres=# create foreign table redis_db0(key text,value text)
postgres-# server redis_51164
postgres-# options (database '0');
CREATE FOREIGN TABLE
postgres-# create user mapping for chensen server redis_51164;
postgres-# create foreign table redis_ansible(key text,value text)server redis_51164 options (database '0',tabletype 'string');
postgres-# grant select,insert,update,delete on myredis_s_hash to chensen;
postgres=> select * from redis_ansible where key='mongo';        # using user chensen  （读redis）
  key  |         value
-------+------------------------
 mongo | This is mongo cookbook
(1 row)
postgres=> insert into redis_ansible values('oracle','oracle is great');      (写入redis)
INSERT 0 1
10.67.51.164:6379> keys *               （查看redis）
 1) "mongo"
 2) "elasticsearch"
 3) "ansible_facts10.21.0.15"
 4) "ansible_facts10.21.0.20"
 5) "ansible_facts10.21.0.14"
 6) "ansible_facts10.21.0.21"
 7) "TiDB"
 8) "mysql"
 9) "oracle"

postgres=> create table dbs as select key,value from redis_ansible where key='mongo';
SELECT 1
postgres=> select * from dbs;
-[ RECORD 1 ]-----------------
key   | mongo
value | This is mongo cookbook

postgres=> insert into dbs select key,value from redis_ansible where key='mysql';
INSERT 0 1
postgres=> select * from dbs;
-[ RECORD 1 ]-----------------
key   | mongo
value | This is mongo cookbook
-[ RECORD 2 ]-----------------
key   | mysql
value | I like mysql

postgres=> \d redis_ansible
             Foreign table "public.redis_ansible"
 Column | Type | Collation | Nullable | Default | FDW options
--------+------+-----------+----------+---------+-------------
 key    | text |           |          |         |
 value  | text |           |          |         |
Server: redis_51164
FDW options: (tabletype 'string')
	   
#####  sqlite_fdw
postgres=# create extension sqlite_fdw;
CREATE EXTENSION
postgres=# create server sqlite_server foreign data wrapper sqlite_fdw options (database '/var/lib/pgsql/inv.db');
CREATE SERVER
postgres=# create foreign table server(id integer options(key 'true'),type text,name text) server sqlite_server options(table 'server');
CREATE FOREIGN TABLE
postgres=# grant select,insert,update,delete on server to chensen;
GRANT
postgres=> select * from server;                        # user chensen 查询
 id |    type    |     name
----+------------+--------------
  1 | k8s        | 10.67.36.58
postgres=> insert into server values(44,'sep','10.67.51.24');        # user chensen 插入    数据已经写入到sqlite3里了
INSERT 0 1

postgres=> \d server
                  Foreign table "public.server"
 Column |  Type   | Collation | Nullable | Default | FDW options
--------+---------+-----------+----------+---------+--------------
 id     | integer |           |          |         | (key 'true')
 type   | text    |           |          |         |
 name   | text    |           |          |         |
Server: sqlite_server
FDW options: ("table" 'server')

##### file_fdw
前提是安装了postgresql13-contrib
postgres=# create extension file_fdw;
CREATE EXTENSION
postgres=# create server pglog foreign data wrapper file_fdw;
CREATE SERVER

postgres=# CREATE FOREIGN TABLE pglog (
  log_time timestamp(3) with time zone,
  user_name text,
  database_name text,
  process_id integer,
  connection_from text,
  session_id text,
  session_line_num bigint,
  command_tag text,
  session_start_time timestamp with time zone,
  virtual_transaction_id text,
  transaction_id bigint,
  error_severity text,
  sql_state_code text,
  message text,
  detail text,
  hint text,
  internal_query text,
  internal_query_pos integer,
  context text,
  query text,
  query_pos integer,
  location text,
  application_name text,
  backend_type text
  SERVER pglog
  OPTIONS (
  program $$cat $PGDATA/$(psql -d postgres -qtAX -c "select 'log/' || name from pg_ls_logdir() where name ~ 'csv$' order by modification")$$,
  format 'csv'
  );
CREATE FOREIGN TABLE
/* 也可以这样，但只能指定单一文件 OPTIONS (filename '/home/pg13/emp.csv', format 'csv' ); 
或者这样，利用find命令  OPTIONS ( program 'find $PGDATA/log -type f -name "*.csv" -mtime -1 -exec cat {} \;', format 'csv' ); */
postgres=# grant select on pglog to public;
GRANT
客户端查询
postgres=>   select log_time,user_name,database_name,message,query from pglog limit 2;
          log_time          | user_name | database_name |                                                     message                                                      | query
----------------------------+-----------+---------------+------------------------------------------------------------------------------------------------------------------+-------
 2021-08-23 09:16:04.319+00 |           |               | starting PostgreSQL 13.3 on x86_64-pc-linux-gnu, compiled by gcc (GCC) 4.8.5 20150623 (Red Hat 4.8.5-44), 64-bit |
 2021-08-23 09:16:04.32+00  |           |               | listening on IPv4 address "0.0.0.0", port 5432                                                                   |

 
##### mongo_fdw
postgres=# create extension mongo_fdw;
ERROR:  could not load library "/usr/pgsql-13/lib/mongo_fdw.so": /usr/pgsql-13/lib/mongo_fdw.so: undefined symbol: mongoc_collection_find_with_opts
另外下载docker image fuww/postgresql-mongodb-fdw:latest 解决
postgres=# create extension mongo_fdw;
CREATE EXTENSION
postgres=# create server mongo_server foreign data wrapper mongo_fdw
postgres-# options(address '10.67.36.58',port '27017');
CREATE SERVER
postgres=# create user mapping for postgres server mongo_server options(username 'root', password 'example');
CREATE USER MAPPING
postgres=# create foreign table warehouse(_id NAME, warehouse_id int, warehouse_name text, warehouse_created timestamptz) server mongo_server options (database 'test', collection 'warehouse');
CREATE FOREIGN TABLE
postgres=# select * from warehouse;
 _id | warehouse_id | warehouse_name | warehouse_created
-----+--------------+----------------+-------------------
(0 rows)

postgres=# INSERT INTO warehouse values (0, 1, 'UPS', '2014-12-12T07:12:10Z');
INSERT 0 1
postgres=# INSERT INTO warehouse values (0, 2, 'Server', '2015-10-02T17:32:10Z');
INSERT 0 1
postgres=# select * from warehouse;
           _id            | warehouse_id | warehouse_name |   warehouse_created
--------------------------+--------------+----------------+------------------------
 612712f8bd6f18005c276452 |            1 | UPS            | 2014-12-12 07:12:10+00
 6127138bbd6f18005c276453 |            2 | Server         | 2015-10-02 17:32:10+00
(2 rows)

mongo中查看collection warehouse 
test> db.warehouse.find();
[
  {
    _id: ObjectId("612712f8bd6f18005c276452"),
    warehouse_id: 1,
    warehouse_name: 'UPS',
    warehouse_created: ISODate("2014-12-12T07:12:10.000Z")
  },
  {
    _id: ObjectId("6127138bbd6f18005c276453"),
    warehouse_id: 2,
    warehouse_name: 'Server',
    warehouse_created: ISODate("2015-10-02T17:32:10.000Z")
  }
]
mongo_fdw 還支援把整個 JSON 以 PostgreSQL 的 JSON 欄位來裝資料。不過要注意的是，這個欄位名稱「限定」叫做 __doc，JSON 型態（JSONB 不可以）；還有，這功能的目標指用來「擷取」資料，不包含用這個欄位寫資料進去 MongoDB：
conn_mongo=> CREATE FOREIGN TABLE test2mongo(__doc json)
    SERVER mongo_server
    OPTIONS (database 'test', collection 'testc2');
CREATE FOREIGN TABLE
conn_mongo=> select * from test2mongo;
                                      __doc                                        
-------------------------------------------------------------------------------------
 { "_id" : { "$oid" : "5850b7888dad99b6c35390d6" }, "i" : 0, "datafrom" : "test" }
 { "_id" : { "$oid" : "5850b7888dad99b6c35390d7" }, "i" : 1, "datafrom" : "test" }
 { "_id" : { "$oid" : "5850b7888dad99b6c35390d8" }, "i" : 2, "datafrom" : "test" }
(3 rows) 