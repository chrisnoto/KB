#########  逻辑概念 ##########
在 Postgresql中是以下的關係
Computer -> Cluter -> Catalog -> Schema -> Database Object (Table/View 等等)

一台電腦可以有多個 Cluster,在 Oracle 叫 Instance
一個 Cluster 可以有多個 Catalog ,包含Postgresql在內,許多資料庫會另外稱作 Database.
一個 Database 可以有多個 Schema, 又叫做  namespace of relations (關聯式物件), 還有相關存取規則(ACL).	

## schema
postgres=# create schema authorization chensen;    为用户创建schema
CREATE SCHEMA
postgres=# \dn
  List of schemas
  Name   |  Owner
---------+----------
 chensen | chensen

# information_schema
postgres=# select * from information_schema.information_schema_catalog_name;
 catalog_name
--------------
 postgres
(1 row)


两个隐藏schema   pg_catalog和information_schema
postgres=# \dn      隐藏的看不到       *** 可以加S来查看全部schema， \dnS ***
  List of schemas
  Name  |  Owner
--------+----------
 public | postgres
(1 row)

postgres=# select table_schema
postgres-#   from information_schema.tables
postgres-#  group by table_schema;
    table_schema
--------------------
 public
 pg_catalog
 information_schema

postgres=# \dn pg_catalog
    List of schemas
    Name    |  Owner
------------+----------
 pg_catalog | postgres
(1 row)

postgres=# \dn information_schema
        List of schemas
        Name        |  Owner
--------------------+----------
 information_schema | postgres
(1 row)

Postgresql独特的术语
a tuple or an item                is a synonym for a row
a relation                        is a synonym for a table
a filenode                        is an id which represent a reference to a table or an index.
a block and page                  are equals and they represent a 8kb segment information the file storing the table.
a heap                            refer to heap file. Heap files are lists of unordered records of variable size. Although sharing a similar name, heap files are different from heap data structure.
CTID                              represent the physical location of the row version within its table. CTID is also a special column available for every tables but not visible unless specifically mentioned. It consists of a page number and the index of an item identifier.
OID                               stands for Object Identifier.
database cluster                  we call a database cluster the storage area on disk. A database cluster is a collection of databases that is managed by a single instance of a running database server.
VACCUM                            PostgreSQL databases require periodic maintenance known as vacuuming	

###### oid  filenode
shell命令找出db与oid的映射关系
-bash-4.2$ oid2name
All databases:
    Oid  Database Name  Tablespace
----------------------------------
  14172       postgres  pg_default
  14171      template0  pg_default
      1      template1  pg_default
-bash-4.2$ oid2name -s
All tablespaces:
    Oid  Tablespace Name
------------------------
   1663       pg_default
   1664        pg_global
  16719           mtbs01

-bash-4.2$ oid2name -d postgres -i 包括表，索引，序列
From database "postgres":
  Filenode    Table Name
------------------------
     16669         books
     16667  books_id_seq
     16676    books_pkey
     16472           dbs
     16462         facts
     16460  facts_id_seq
     16469    facts_pkey
     16715      idx_t3_t
     16385            it
     16391           it1
     16521         staff
     16402            t2
     16400     t2_id_seq
     16713            t3
     16416     t3_id_seq
     16427            t4
     16409          tax1
     16397          tbl1
	  
sql命令找出db与oid的映射关系
postgres=# select oid, datname from pg_database;
  oid  |  datname
-------+-----------
 14172 | postgres
     1 | template1
 14171 | template0
 
sql命令找出表的存放路径	  
postgres=# select pg_relation_filepath('books');
 pg_relation_filepath
----------------------
 base/14172/16669
(1 row)
shell命令找出表的filenode
-bash-4.2$ oid2name -d postgres -t books
From database "postgres":
  Filenode  Table Name
----------------------
     16669       books
注意：A table's filenode often matches its OID, this is not necessarily the case
postgres=# select oid,relname,relfilenode from pg_class where relname='books';
  oid  | relname | relfilenode
-------+---------+-------------
 16669 | books   |       16669
 server是外部表
postgres=# select oid,relname,relfilenode from pg_class where relname='server';
  oid  | relname | relfilenode
-------+---------+-------------
 16487 | server  |           0
	
如果想知道这些快捷命令后面用了什么SQL，可以开启-E选项
-bash-4.2$ psql -E
psql (13.3)
Type "help" for help.

postgres=# \l
********* QUERY **********
SELECT d.datname as "Name",
       pg_catalog.pg_get_userbyid(d.datdba) as "Owner",
       pg_catalog.pg_encoding_to_char(d.encoding) as "Encoding",
       d.datcollate as "Collate",
       d.datctype as "Ctype",
       pg_catalog.array_to_string(d.datacl, E'\n') AS "Access privileges"
FROM pg_catalog.pg_database d
ORDER BY 1;
**************************

                                  List of databases
   Name    |  Owner   | Encoding |   Collate   |    Ctype    |   Access privileges
-----------+----------+----------+-------------+-------------+-----------------------
 postgres  | postgres | UTF8     | en_US.UTF-8 | en_US.UTF-8 |
 template0 | postgres | UTF8     | en_US.UTF-8 | en_US.UTF-8 | =c/postgres          +
           |          |          |             |             | postgres=CTc/postgres
 template1 | postgres | UTF8     | en_US.UTF-8 | en_US.UTF-8 | =c/postgres          +
           |          |          |             |             | postgres=CTc/postgres
或者postgres=# \set ECHO_HIDDEN on

####### 物理概念 ###########
tablespace
postgres=# select oid,* from pg_tablespace;
 oid  | oid  |  spcname   | spcowner | spcacl | spcoptions
------+------+------------+----------+--------+------------
 1663 | 1663 | pg_default |       10 |        |
 1664 | 1664 | pg_global  |       10 |        |
pg_default默认的表空间                        The location of the pg_default tablespace is $PGDATA\base
pg_global 存放'database cluster' level的表    The location of the pg_global tablespace is $PGDATA\global
查看pg_global表空间的表有哪些
postgres=# select oid,relname,reltablespace from pg_class where  reltablespace=1664;
 oid  |                 relname                 | reltablespace
------+-----------------------------------------+---------------
 4175 | pg_toast_1260                           |          1664
 4176 | pg_toast_1260_index                     |          1664
...........
 4185 | pg_toast_1213                           |          1664
 4186 | pg_toast_1213_index                     |          1664
 2676 | pg_authid_rolname_index                 |          1664
 2677 | pg_authid_oid_index                     |          1664
 2694 | pg_auth_members_role_member_index       |          1664
 2695 | pg_auth_members_member_role_index       |          1664
 2671 | pg_database_datname_index               |          1664
 2672 | pg_database_oid_index                   |          1664
 2397 | pg_shdescription_o_c_index              |          1664
 1232 | pg_shdepend_depender_index              |          1664
 1233 | pg_shdepend_reference_index             |          1664
 2697 | pg_tablespace_oid_index                 |          1664
 2698 | pg_tablespace_spcname_index             |          1664
 2965 | pg_db_role_setting_databaseid_rol_index |          1664
 3593 | pg_shseclabel_object_index              |          1664
 6001 | pg_replication_origin_roiident_index    |          1664
 6002 | pg_replication_origin_roname_index      |          1664
 6114 | pg_subscription_oid_index               |          1664
 6115 | pg_subscription_subname_index           |          1664
 1260 | pg_authid                               |          1664
 6100 | pg_subscription                         |          1664
 1262 | pg_database                             |          1664
 2964 | pg_db_role_setting                      |          1664
 1213 | pg_tablespace                           |          1664
 1261 | pg_auth_members                         |          1664
 1214 | pg_shdepend                             |          1664
 2396 | pg_shdescription                        |          1664
 6000 | pg_replication_origin                   |          1664
 3592 | pg_shseclabel                           |          1664
(43 rows)
用户表空间
不要建在$PGDATA目录里
postgres=# create tablespace mtbs01 location '/data01';           
CREATE TABLESPACE
postgres=# select oid,* from pg_tablespace;
  oid  |  oid  |  spcname   | spcowner | spcacl | spcoptions
-------+-------+------------+----------+--------+------------
  1663 |  1663 | pg_default |       10 |        |
  1664 |  1664 | pg_global  |       10 |        |
 16719 | 16719 | mtbs01     |       10 |        |

在$PGDATA/pg_tblspc 目录下有指向/data01的链接
-bash-4.2$ ll $PGDATA/pg_tblspc
total 0
lrwxrwxrwx. 1 postgres postgres 7 Sep 11 03:23 16719 -> /data01
******* 创建tbs，导致从库down掉， 注意!
-bash-4.2$ cat postgresql-Sat.log          -postgres-2
2021-09-11 03:19:58.281 UTC [14107] FATAL:  directory "/data01" does not exist
2021-09-11 03:19:58.281 UTC [14107] HINT:  Create this directory for the tablespace before restarting the server.
2021-09-11 03:19:58.281 UTC [14107] CONTEXT:  WAL redo at 1/3D12500 for Tablespace/CREATE: 16719 "/data01"
2021-09-11 03:19:58.296 UTC [14104] LOG:  startup process (PID 14107) exited with exit code 1
2021-09-11 03:19:58.296 UTC [14104] LOG:  terminating any other active server processes
2021-09-11 03:19:58.341 UTC [14104] LOG:  database system is shut down


修改用户表空间的位置：  手动新建目录，拷贝原表空间的数据，用ln -s命令做新的链接(要停postgres)
#####  查看page ########
postgresql的表为堆表,表是page/block的集合，而page是row/tuple/item的集合
一个page为8k，一个表太大的话就会产生数据分片，一个分片最大1G，block/page数量为131072
A Pointer to an item is called CTID (ItemPointer), created by PostgreSQL, it consists of a page number and the index of an item identifier.
inside a page the pointers to the row are stored at the starts and the tuples (rows) are stored at the end of the page. 一个page里，指针在前，tuples在后

postgres=# select ctid,* from t3;
   ctid   |  id  |          t
----------+------+---------------------
 (0,1)    |  156 | Adam Donachie
 (0,2)    |  157 | Paul Bako
 (0,3)    |  158 | Ramon Hernandez
 (0,4)    |  159 | Kevin Millar
 (0,5)    |  160 | Chris Gomez

postgres=# \! ls -lh 13/data/base/14172/16427*
-rw-------. 1 postgres postgres 1.0G Aug  6 00:25 13/data/base/14172/16427
-rw-------. 1 postgres postgres 1.0G Aug  6 00:29 13/data/base/14172/16427.1
-rw-------. 1 postgres postgres 441M Aug  6 00:32 13/data/base/14172/16427.2
-rw-------. 1 postgres postgres 648K Aug  6 00:32 13/data/base/14172/16427_fsm
-rw-------. 1 postgres postgres  80K Aug  6 00:32 13/data/base/14172/16427_vm
postgres=# select oid,relname,relpages,reltuples from pg_class where relname='t4';
  oid  | relname | relpages |   reltuples
-------+---------+----------+---------------
 16427 | t4      |   318472 | 5.0000104e+07

page header结构
---------------------------------------------------------------------------------------------------------
Field	            Type	        Length	    Description
pd_lsn	            PageXLogRecPtr	8 bytes	    LSN: next byte after last byte of WAL record for last change to this page
pd_checksum	        uint16	        2 bytes	    Page checksum
pd_flags	        uint16	        2 bytes	    Flag bits
pd_lower	        LocationIndex	2 bytes	    Offset to start of free space
pd_upper	        LocationIndex	2 bytes   	Offset to end of free space
pd_special	        LocationIndex	2 bytes	    Offset to start of special space
pd_pagesize_version	uint16	        2 bytes   	Page size and layout version number information
pd_prune_xid	    TransactionId	4 bytes  	Oldest unpruned XMAX on page, or zero if none
---------------------------------------------------------------------------------------------------------
HeapTupleHeaderData结构
---------------------------------------------------------------------------------------------------------
Field	            Type	     	Length	    Description
t_xmin	            TransactionId	4 bytes	    insert XID stamp
t_xmax	            TransactionId	4 bytes	    delete XID stamp
t_cid	            CommandId	    4 bytes	    insert and/or delete CID stamp (overlays with t_xvac)
t_xvac	            TransactionId	4 bytes	    XID for VACUUM operation moving a row version
t_ctid	            ItemPointerData	6 bytes	    current TID of this or newer row version
t_infomask2         uint16		    2 bytes	    number of attributes, plus various flag bits
t_infomask	        uint16		    2 bytes	    various flag bits
t_hoff            	uint8	     	1 byte	    offset to user data
---------------------------------------------------------------------------------------------------------
postgres=# create extension pageinspect ;
CREATE EXTENSION
postgres=# select * from page_header(get_raw_page('t3',0));
    lsn    | checksum | flags | lower | upper | special | pagesize | version | prune_xid
-----------+----------+-------+-------+-------+---------+----------+---------+-----------
 1/3B99988 |        0 |     0 |   636 |  2072 |    8192 |     8192 |       4 |       567(一个删除的事务)

postgres=# select count(*) from t3;
 count
-------
   151
postgres=# select * from heap_page_items(get_raw_page('t3',0));
 lp  | lp_off | lp_flags | lp_len | t_xmin | t_xmax | t_field3 | t_ctid  | t_infomask2 | t_infomask | t_hoff | t_bits | t_oid |           t_data
-----+--------+----------+--------+--------+--------+----------+---------+-------------+------------+--------+--------+-------+----------------------------

 147 |   2312 |        1 |     36 |    499 |      0 |        0 | (0,147) |           2 |       2306 |     24 |        |       | \x930000001157696e646f7773
 148 |   2272 |        1 |     36 |    499 |      0 |        0 | (0,148) |           2 |       2306 |     24 |        |       | \x940000001157696e646f7773
 149 |   2232 |        1 |     36 |    499 |    568 |        0 | (0,153) |           2 |        258 |     24 |        |       | \x950000001157696e646f7773
 150 |   2192 |        1 |     36 |    499 |    567 |        0 | (0,150) |        8194 |       1282 |     24 |        |       | \x960000001157696e646f7773
 151 |   2152 |        1 |     36 |    565 |      0 |        0 | (0,151) |           2 |       2306 |     24 |        |       | \x9700000011536f6c61726973
 152 |   2112 |        1 |     35 |    566 |      0 |        0 | (0,152) |           2 |       2306 |     24 |        |       | \x980000000f43656e744f53
 153 |   2072 |        1 |     36 |    568 |      0 |        0 | (0,153) |           2 |      10242 |     24 |        |       | \x950000001146726565425344

事务568：  postgres=# update t3 set t='FreeBSD' where id=149;      \x950000001146726565425344
事务567：  postgres=# delete from t3 where id=150;
事务566：  postgres=# insert into t3(t) values('CentOS');          \x980000000f43656e744f53
事务565：  postgres=# insert into t3(t) values('Solaris');         \x9700000011536f6c61726973

通过lower能算出指针的数量。表中的指针数为(636-24)/4= 153 ，但实际表的数据只有151行。 指针有153个，lp 150代表delete，lp 149和153 代表update
空间没有减少。
现在vacuum表t3
postgres=# vacuum verbose t3;

postgres=# select * from page_header(get_raw_page('t3',0));
    lsn    | checksum | flags | lower | upper | special | pagesize | version | prune_xid
-----------+----------+-------+-------+-------+---------+----------+---------+-----------
 1/3B9BE38 |        0 |     5 |   636 |  2152 |    8192 |     8192 |       4 |         0
(1 row)

postgres=# select * from heap_page_items(get_raw_page('t3',0));
 lp  | lp_off | lp_flags | lp_len | t_xmin | t_xmax | t_field3 | t_ctid  | t_infomask2 | t_infomask | t_hoff | t_bits | t_oid |           t_data
 147 |   2312 |        1 |     36 |    499 |      0 |        0 | (0,147) |           2 |       2306 |     24 |        |       | \x930000001157696e646f7773
 148 |   2272 |        1 |     36 |    499 |      0 |        0 | (0,148) |           2 |       2306 |     24 |        |       | \x940000001157696e646f7773
 149 |      0 |        0 |      0 |        |        |          |         |             |            |        |        |       |
 150 |      0 |        0 |      0 |        |        |          |         |             |            |        |        |       |
 151 |   2232 |        1 |     36 |    565 |      0 |        0 | (0,151) |           2 |       2306 |     24 |        |       | \x9700000011536f6c61726973
 152 |   2192 |        1 |     35 |    566 |      0 |        0 | (0,152) |           2 |       2306 |     24 |        |       | \x980000000f43656e744f53
 153 |   2152 |        1 |     36 |    568 |      0 |        0 | (0,153) |           2 |      10498 |     24 |        |       | \x950000001146726565425344
vacuum后，指针不回收，页面回收了，upper从2072变为2152，两个40的单位
索引也可以查看，貌似没有变化
postgres=# select * from heap_page_items(get_raw_page('idx_t3_t',0));
 lp | lp_off | lp_flags | lp_len | t_xmin | t_xmax | t_field3 | t_ctid | t_infomask2 | t_infomask | t_hoff | t_bits | t_oid | t_data
----+--------+----------+--------+--------+--------+----------+--------+-------------+------------+--------+--------+-------+--------
  1 |  12642 |        2 |      2 |        |        |          |        |             |            |        |        |       |
  2 |      4 |        0 |      0 |        |        |          |        |             |            |        |        |       |
  3 |      1 |        0 |      0 |        |        |          |        |             |            |        |        |       |
  4 |      0 |        0 |      0 |        |        |          |        |             |            |        |        |       |
  5 |      1 |        0 |      0 |        |        |          |        |             |            |        |        |       |
  6 |      0 |        0 |      0 |        |        |          |        |             |            |        |        |       |
  7 |      0 |        0 |      0 |        |        |          |        |             |            |        |        |       |
  8 |      0 |        0 |      0 |        |        |          |        |             |            |        |        |       |
  9 |      0 |        0 |      0 |        |        |          |        |             |            |        |        |       |
 10 |      0 |        0 |  24568 |        |        |          |        |             |            |        |        |       |
 11 |      1 |        0 |      0 |        |        |          |        |             |            |        |        |       |
 12 |      0 |        0 |      0 |        |        |          |        |             |            |        |        |       |
(12 rows)
**************************************************************
最多167行，然后再查看其他block number  'idx_t3_t',1,2,3,4。。。。。。
postgres=# select * from heap_page_items(get_raw_page('t3',49)) limit 10 offset 110;
 lp  | lp_off | lp_flags | lp_len | t_xmin | t_xmax | t_field3 |  t_ctid  | t_infomask2 | t_infomask | t_hoff | t_bits | t_oid |                 t_data
-----+--------+----------+--------+--------+--------+----------+----------+-------------+------------+--------+--------+-------+----------------------------------------
 111 |   3184 |        1 |     42 |    582 |      0 |        0 | (49,111) |           2 |       2306 |     24 |        |       | \xd22000001d52616e6479204b6569736c6572
 112 |   3144 |        1 |     40 |    582 |      0 |        0 | (49,112) |           2 |       2306 |     24 |        |       | \xd3200000194a6f7368204b696e6e6579
(2 rows)                                                          这里表示第50个块的第112个tuple
postgres=# select * from page_header(get_raw_page('t3',19));
    lsn    | checksum | flags | lower | upper | special | pagesize | version | prune_xid
-----------+----------+-------+-------+-------+---------+----------+---------+-----------
 1/3C420B0 |        0 |     4 |   688 |   704 |    8192 |     8192 |       4 |         0
                                  688-704 这里没有空间了
**************************************************************
postgres=# select * from heap_page_items(get_raw_page('t3',50));
ERROR:  block number 50 is out of range for relation "t3"

postgres=# select * from page_header(get_raw_page('idx_t3_t',0));
    lsn    | checksum | flags | lower | upper | special | pagesize | version | prune_xid
-----------+----------+-------+-------+-------+---------+----------+---------+-----------
 0/C0284A0 |        0 |     0 |    72 |  8176 |    8176 |     8192 |       4 |         0
(1 row)

# pg_filedump查看datafile
安装
[root@postgres-1 ~]# yum install pg_filedump_13
-bash-4.2$ pg_filedump 16521

*******************************************************************
* PostgreSQL File/Block Formatted Dump Utility
*
* File: 16521
* Options used: None
*******************************************************************
Flags有unused, normal       normal的才有内容
Block    0 ********************************************************
<Header> -----
 Block Offset: 0x00000000         Offsets: Lower     424 (0x01a8)
 Block: Size 8192  Version    4            Upper    8192 (0x2000)
 LSN:  logid      1 recoff 0x03a7da80      Special  8192 (0x2000)
 Items:  100                      Free Space: 7768
 Checksum: 0x0000  Prune XID: 0x00000000  Flags: 0x0005 (HAS_FREE_LINES|ALL_VISIBLE)
 Length (including item array): 424

<Data> -----
 Item   1 -- Length:    0  Offset:    0 (0x0000)  Flags: UNUSED
 Item   2 -- Length:    0  Offset:    0 (0x0000)  Flags: UNUSED
 Item   3 -- Length:    0  Offset:    0 (0x0000)  Flags: UNUSED
 Item   4 -- Length:    0  Offset:    0 (0x0000)  Flags: UNUSED
 Item   5 -- Length:    0  Offset:    0 (0x0000)  Flags: UNUSED
 Item   6 -- Length:    0  Offset:    0 (0x0000)  Flags: UNUSED

-bash-4.2$  pg_filedump -f 16521      # 可查看行的内容
Block    9 ********************************************************
<Header> -----
 Block Offset: 0x00012000         Offsets: Lower     428 (0x01ac)
 Block: Size 8192  Version    4            Upper    7752 (0x1e48)
 LSN:  logid      1 recoff 0x03a80ef0      Special  8192 (0x2000)
 Items:  101                      Free Space: 7324
 Checksum: 0x0000  Prune XID: 0x00000000  Flags: 0x0005 (HAS_FREE_LINES|ALL_VISIBLE)
 Length (including item array): 428
             
  Item  93 -- Length:    0  Offset:    0 (0x0000)  Flags: UNUSED
 Item  94 -- Length:    0  Offset:    0 (0x0000)  Flags: UNUSED
 Item  95 -- Length:    0  Offset:    0 (0x0000)  Flags: UNUSED
 Item  96 -- Length:   67  Offset: 8120 (0x1fb8)  Flags: NORMAL
  1fb8: 26020000 00000000 00000000 00000900  &...............
  1fc8: 60000600 02091800 1d416461 6d20446f  `........Adam Do
  1fd8: 6e616368 69650b20 42414c13 20436174  nachie. BAL. Cat
  1fe8: 63686572 4a000000 b4000000 0f008116  cherJ...........
  1ff8: 00ac26                               ..&

 Item  97 -- Length:   63  Offset: 8056 (0x1f78)  Flags: NORMAL
  1f78: 26020000 00000000 00000000 00000900  &...............
  1f88: 61000600 02091800 15506175 6c204261  a........Paul Ba
  1f98: 6b6f0b20 42414c13 20436174 63686572  ko. BAL. Catcher
  1fa8: 4a000000 d7000000 0f008122 00f41a    J.........."...
postgres=# select * from staff where ctid='(9,96)';
     name      | team | position | height | weight |  age
---------------+------+----------+--------+--------+-------
 Adam Donachie |  BAL |  Catcher |     74 |    180 | 22.99
(1 row)
可以发现staff表的第一行数据在page9,item96       很奇怪，别的表没有出现这个情况，第一个page就有数据

用-D  加上数据类型去decode行
-bash-4.2$ pg_filedump -D text,text,text,int,int,float 16521
Error: unable to decode a tuple, callback #6 returned -2. Partial data: Adam Donachie    BAL     Catcher        74      180
 Item  97 -- Length:   63  Offset: 8056 (0x1f78)  Flags: NORMAL
Error: unable to decode a tuple, callback #6 returned -2. Partial data: Paul Bako        BAL     Catcher        74      215
 Item  98 -- Length:   71  Offset: 7984 (0x1f30)  Flags: NORMAL

 
##### TOAST ######  行外存储
It stands for The Oversized-Attribute Storage Technique
The mechanism is accomplished by splitting up the large column entry into 2KB bytes and storing them as chunks in the TOAST tables. 
It then stores the length and a pointer to the TOAST entry back where the column is normally stored. Because of how the pointer system is implemented,
 most TOAST'able column types are limited to a max size of 1GB.

只有特定的数据类型支持TOAST，因为那些整数、浮点数等不太长的数据类型是没有必要使用TOAST的。
另外，支持TOAST的数据类型必须是变长的。在变长类型中：
前4字节（32bit）称为长度字，长度字后面存储具体的内容或一个指针。
长度字的高2bit位是标志位，后面的30bit是长度值（表示值的总长度，包括长度字本身，以字节计）。
由长度值可知TOAST数据类型的逻辑长度最多是30bit，即1GB(2^30-1字节）之内。
前2bit的标志位，一个表示压缩标志位，一个表示是否行外存储，如果两个都是零，那么表示既未压缩也未行外存储。
如果设置了压缩标志标志位，表示该数值被压缩过（使用的是非常简单且快速的LZ压缩方法），使用前必须先解压缩。
如果设置了行外存储标志位，则表示该数值是在行外存储的。此时，长度字后面的部分只是一个指针，指向存储实际数据的TOAST表中的位置。如果两个标志位都设置了，那么这个行外数据也会被压缩。
不管是哪种情况，长度字里剩下的30bit的长度值都表示数据的实际尺寸，而不是压缩后的长度。

在 PG 中每个表字段有四种 TOAST 的策略：
PLAIN —— 避免压缩和行外存储。只有那些不需要 TOAST 策略就能存放的数据类型允许选择（例如 int 类型），而对于 text 这类要求存储长度超过页大小的类型，是不允许采用此策略的。
EXTENDED —— 允许压缩和行外存储。一般会先压缩，如果还是太大，就会行外存储。这是大多数可以TOAST的数据类型的默认策略。
EXTERNAL —— 允许行外存储，但不许压缩。这让在text类型和bytea类型字段上的子串操作更快。类似字符串这种会对数据的一部分进行操作的字段，采用此策略可能获得更高的性能，因为不需要读取出整行数据再解压。
MAIN —— 允许压缩，但不许行外存储。不过实际上，为了保证过大数据的存储，行外存储在其它方式（例如压缩）都无法满足需求的情况下，作为最后手段还是会被启动。因此理解为：尽量不使用行外存储更贴切。 
行外存储被切成了多个Chunk块，每个Chunk块大约是一个BLOCK的四分之一大小，如果块大小为8KB（默认就是8KB），则Chunk大约为2KB（比2KB略小一点），每个Chunk都作为独立的行存储在TOAST表中。

TOAST表有三个字段：
chunk_id —— 用来表示特定 TOAST 值的 OID ，可以理解为具有同样 chunk_id 值的所有行组成原表（这里的 blog ）的 TOAST 字段的一行数据。
chunk_seq —— 用来表示该行数据在整个数据中的位置。
chunk_data —— 该Chunk实际的数据。 
查找实际的toast表和它的数据
postgres=# select relname,relfilenode,reltoastrelid from pg_class where relname='facts';
 relname | relfilenode | reltoastrelid
---------+-------------+---------------
 facts   |       16462 |         16466
(1 row)

postgres=# \d+ pg_toast.pg_toast_16462
TOAST table "pg_toast.pg_toast_16462"
   Column   |  Type   | Storage
------------+---------+---------
 chunk_id   | oid     | plain
 chunk_seq  | integer | plain
 chunk_data | bytea   | plain
Owning table: "public.facts"
Indexes:
    "pg_toast_16462_index" PRIMARY KEY, btree (chunk_id, chunk_seq)
Access method: heap
facts表json类型data字段的长度
postgres=# select id,key,pg_column_size(data) from facts;
 id |           key           | pg_column_size
----+-------------------------+----------------
  1 | ansible_facts10.21.0.14 |          18038
可以发现data被分为10个chunk,每个chunk为1996 byte
postgres=# select chunk_id,chunk_seq,length(chunk_data) from pg_toast.pg_toast_16462;
 chunk_id | chunk_seq | length
----------+-----------+--------
    16471 |         0 |   1996      略小于2k
    16471 |         1 |   1996
    16471 |         2 |   1996
    16471 |         3 |   1996
    16471 |         4 |   1996
    16471 |         5 |   1996
    16471 |         6 |   1996
    16471 |         7 |   1996
    16471 |         8 |   1996
    16471 |         9 |     74
postgres=# select * from pg_toast.pg_toast_16462;
 chunk_id | chunk_seq | chunk_data
    16471 |         0 | \xc4ca010000227b5c6e20202020005c22616e73........... 
	16471 |         1 | \xbf02c40ffe16bf12ff0f2b013fbf12030f320b...........
	.................
    16471 |         9 | \x0f28026c04616e94c93130332c312030312c31...........	
(10 rows)	
修改TOAST策略
alter table blog alter content set storage external/extended;

######### WAL ###########
•WAL –Write Ahead Log. It is used in context of transaction log files.
•Xlog  -Transaction log. It is used in context of transaction log  buffers.
•LSN –Log sequence number. It is used to mark position of log in  pages. 
•Bgwriter –Background writer.This is used to flush shared buffers  and perform checkpoint. 
•Clog  -Commit log. It is used in context of transaction status buffers.
•Partial Page Write –This happens when OS is able to write partial page in disk files which can cause corruption.

The transaction log files are stored in $PGDATA/pg_wal directory. They are named as 000000010000070A0000008E. 
  -The first 8 digits identifies the timeline, 
  -The following 8 digits identifies the (logical) xlog file and      
  -The last ones represents the (physical) xlog file (Segement) 
The physical files in pg_xlog directory are not actually the xlog files; PostgreSQL calls it segments. 
Each Segment contains Bocks of 8K and Segment size is 16M
Block 0     1.Seg Hdr 2.Block Header 3.WAL Records Each WAL record has header. WAL 1, 2 ,3
Block 1     1. Block Header 2. WAL Records 3. Each WAL record has header. WAL 4,5
Block 2     1. Block Header 2. WAL Records 3. Each WAL record has header. WAL 5,6,7,8
…
Block 255   1. Block Header 2. WAL Records 3. Each WAL record has header. WAL m,n,…

switch wal之后, segment 号 加 1
-rw-------. 1 postgres postgres 16M Sep 13 02:43 0000000100000001000000A2
postgres=# select pg_switch_wal();
-[ RECORD 1 ]-+-----------
pg_switch_wal | 1/A21613D8
-rw-------. 1 postgres postgres 16M Sep 13 03:10 0000000100000001000000A3

postgres=# select * from pg_control_checkpoint();
-[ RECORD 1 ]--------+-------------------------
checkpoint_lsn       | 1/A2161310
redo_lsn             | 1/A21612D8
redo_wal_file        | 0000000100000001000000A2
timeline_id          | 1
prev_timeline_id     | 1
full_page_writes     | t
next_xid             | 0:591
next_oid             | 24700
next_multixact_id    | 1
next_multi_offset    | 0
oldest_xid           | 479
oldest_xid_dbid      | 1
oldest_active_xid    | 591
oldest_multi_xid     | 1
oldest_multi_dbid    | 1
oldest_commit_ts_xid | 0
newest_commit_ts_xid | 0
checkpoint_time      | 2021-09-13 02:58:38+00

WALInsertLock •This lock is used to insert transaction log record contents into transaction log memory buffer
WALWriteLock •This lock is used to write transaction log buffer data to WAL file

postgres=# select * from  pg_current_wal_insert_lsn();
-[ RECORD 1 ]-------------+-----------
pg_current_wal_insert_lsn | 1/A21613C0

postgres=# select * from  pg_current_wal_flush_lsn();
-[ RECORD 1 ]------------+-----------
pg_current_wal_flush_lsn | 1/A21613C0

postgres=# select * from  pg_current_wal_lsn();  一直在变
-[ RECORD 1 ]------+-----------
pg_current_wal_lsn | 1/A21613C0

postgres=# select pg_walfile_name('1/A21613C0');
-[ RECORD 1 ]---+-------------------------
pg_walfile_name | 0000000100000001000000A2

postgres=# select txid_current();
-[ RECORD 1 ]+----
txid_current | 590

全页写
PG数据页写入是以page为单位，每个page默认大小为8K，而操作系统数据块是4K（操作系统每次写入4k），在断电等情况下，极有可能部分pg数据页只写到4K系统就已经崩溃。
此时pg数据页中就一半是新写入的数据，一半是还没来得及写入的旧数据，这称为部分写问题。这种数据页可以看作是损坏的，在崩溃恢复时，由于XLOG记录无法在损坏的页面上重放，
它无法完全恢复该页。因此，我们需要一个额外附加的功能。

pg支持一种称为全页写的功能来处理部分写问题。如果启用（默认启用），pg会在每个检查点之后、每个页面第一次发生变更时，将头数据和整个页面作为一条XLOG记录写入WAL缓冲区。
在pg中，这种包含整个页面的XLOG记录称为备份块或全页镜像 (backup block or full-page image)。

查看wal日志
-bash-4.2$ pg_controldata
pg_control version number:            1300
Catalog version number:               202007201
Database system identifier:           6984324583401825557
Database cluster state:               in production
pg_control last modified:             Mon 13 Sep 2021 03:13:38 AM UTC
Latest checkpoint location:           1/A3000098
Latest checkpoint's REDO location:    1/A3000060

-bash-4.2$ pg_waldump -p ./ -s 1/A3000060
rmgr: Standby     len (rec/tot):     50/    50, tx:          0, lsn: 1/A3000060, prev 1/A3000028, desc: RUNNING_XACTS nextXid 591 latestCompletedXid 590 oldestRunningXid 591
rmgr: XLOG        len (rec/tot):    114/   114, tx:          0, lsn: 1/A3000098, prev 1/A3000060, desc: CHECKPOINT_ONLINE redo 1/A3000060; tli 1; prev tli 1; fpw true; xid 0:591; oid 24700; multi 1; offset 0; oldest xid 479 in DB 1; oldest multi 1 in DB 1; oldest/newest commit timestamp xid: 0/0; oldest running xid 591; online
rmgr: Standby     len (rec/tot):     50/    50, tx:          0, lsn: 1/A3000110, prev 1/A3000098, desc: RUNNING_XACTS nextXid 591 latestCompletedXid 590 oldestRunningXid 591
rmgr: Heap        len (rec/tot):     54/   362, tx:        591, lsn: 1/A3000148, prev 1/A3000110, desc: INSERT off 5 flags 0x00, blkref #0: rel 1663/14172/16472 blk 0 FPW
rmgr: Transaction len (rec/tot):     34/    34, tx:        591, lsn: 1/A30002B8, prev 1/A3000148, desc: COMMIT 2021-09-14 05:12:20.545562 UTC
rmgr: Standby     len (rec/tot):     50/    50, tx:          0, lsn: 1/A30002E0, prev 1/A30002B8, desc: RUNNING_XACTS nextXid 592 latestCompletedXid 591 oldestRunningXid 592

-bash-4.2$ pg_waldump 0000000100000001000000A3 --r heap      增删改
rmgr: Heap        len (rec/tot):     54/   362, tx:        591, lsn: 1/A3000148, prev 1/A3000110, desc: INSERT off 5 flags 0x00, blkref #0: rel 1663/14172/16472 blk 0 FPW
rmgr: Heap        len (rec/tot):     54/   422, tx:        592, lsn: 1/A3000400, prev 1/A30003C8, desc: INSERT off 6 flags 0x00, blkref #0: rel 1663/14172/16472 blk 0 FPW
rmgr: Heap        len (rec/tot):     93/    93, tx:        593, lsn: 1/A3000608, prev 1/A30005D0, desc: INSERT off 7 flags 0x00, blkref #0: rel 1663/14172/16472 blk 0
rmgr: Heap        len (rec/tot):     78/    78, tx:        594, lsn: 1/A30006C8, prev 1/A3000690, desc: HOT_UPDATE off 4 xmax 594 flags 0x60 ; new off 8 xmax 0, blkref #0: rel 1663/14172/16472 blk 0
rmgr: Heap        len (rec/tot):     54/    54, tx:        595, lsn: 1/A3000778, prev 1/A3000740, desc: DELETE off 5 flags 0x00 KEYS_UPDATED , blkref #0: rel 1663/14172/16472 blk 0

######## FSM ########
VACUUM performs processing while referring to the Visibility Map, and updates the Free Space Map
Free Space Map stores information about free space in a relation
• Used by INSERTs and UPDATEs
FSM的空间管理中，没有细粒度到数据页的每个比特，而是将最小单元定义为页大小（BLCKSZ）的256分之一，也就是说，
在默认8KB数据页的大小下，从FSM的角度观察，它有256个单元。所以，为了表述这个256个单元的状态，FSM为每个数据页分配了一个字节的空间。这也是FSM在设计时，一个空间和时间的折中选择
https://www.bookstack.cn/read/aliyun-rds-core/2470b8d6a68945ba.md
postgres=# create extension pg_freespacemap;
CREATE EXTENSION
postgres=# select * from pg_freespace('staff');
 blkno | avail
-------+-------
     0 |  7744
     1 |  7744
     2 |  7744
     3 |  7744
     4 |  7744
     5 |  7744
     6 |  7744
     7 |  7744
     8 |  7744
     9 |  7296
    10 |    32
    11 |    32
    12 |     0
    13 |    96
    14 |     0
    15 |    64
    16 |    32
    17 |    64
    18 |    32
    19 |    96
    20 |  6400
postgres=# select * from staff where ctid='(9,96)';
     name      | team | position | height | weight |  age
---------------+------+----------+--------+--------+-------
 Adam Donachie |  BAL |  Catcher |     74 |    180 | 22.99
(1 row)
可以发现staff表的第一行数据在page9,item96

######## VM ########
Visibility Map  跟vacuum密切相关
• A bitmap of heap pages
• 1 means “all tuples on page are visible to all transactions”
• Bits are set in VACUUM
• Cleared at INSERT/UPDATE/DELETE
VACUUM can now skip pages that are already marked in visibility map
• Still needs to scan all indexes
http://www.postgres.cn/v2/news/viewone/1/525
pg的冻结炸弹，事务号回卷会导致刚创建的元组不可见
postgresql数据库使用32位事务号，最大容纳42亿左右的事务号，事务号是循环使用的，当事务号耗尽后又会从3开始循环使用。事务环被分为两个半圆，
当前事务号过去的21亿事务属于过去的事务号，当前事务号往前的21亿属于未来的事务号，未来的事务号对当前事务是不可见的。

当数据页中的所有记录已经是FROZEN状态时，在发起vacuum freeze时会跳过这个页的扫描，从而大幅提升静态数据的freeze操作，减少IO扫描。
目前这个page frozen标记放在表对应的VM文件中
postgres=# create extension pg_visibility;
CREATE EXTENSION
postgres=# select * from pg_visibility_map_summary('t4');
 all_visible | all_frozen
-------------+------------
      318472 |          0
(1 row)
第一次freeze很耗时间，没有frozen page
postgres=# vacuum freeze verbose t4;
INFO:  aggressively vacuuming "public.t4"
INFO:  "t4": found 0 removable, 50000000 nonremovable row versions in 318472 out of 318472 pages
DETAIL:  0 dead row versions cannot be removed yet, oldest xmin: 587
There were 0 unused item identifiers.
Skipped 0 pages due to buffer pins, 0 frozen pages.
0 pages are entirely empty.
CPU: user: 7.76 s, system: 6.71 s, elapsed: 180.29 s.

postgres=# select * from pg_visibility_map_summary('t4');
 all_visible | all_frozen
-------------+------------
      318472 |     318472

第二次freeze立即结束，因为跳过了318471个frozen pages。vm文件记录了frozen page标志位
postgres=# vacuum freeze verbose t4;
INFO:  aggressively vacuuming "public.t4"
INFO:  "t4": found 0 removable, 53 nonremovable row versions in 1 out of 318472 pages
DETAIL:  0 dead row versions cannot be removed yet, oldest xmin: 587
There were 0 unused item identifiers.
Skipped 0 pages due to buffer pins, 318471 frozen pages.
0 pages are entirely empty.
CPU: user: 0.00 s, system: 0.00 s, elapsed: 0.00 s.

查看详细
postgres=# select * from pg_visibility_map('t4');
 blkno  | all_visible | all_frozen
--------+-------------+------------
      0 | t           | t
      1 | t           | t
      2 | t           | t
      3 | t           | t
      4 | t           | t
	  
###	pg_control  ###
用命令读pg_control
-bash-4.2$ pg_controldata
pg_control version number:            1300
Catalog version number:               202007201
Database system identifier:           6984324583401825557
Database cluster state:               in production
pg_control last modified:             Sat 11 Sep 2021 06:39:13 AM UTC
Latest checkpoint location:           1/A2160AD8
Latest checkpoint's REDO location:    1/A2160AA0
Latest checkpoint's REDO WAL file:    0000000100000001000000A2

用以下几个函数获取control的内容
https://www.postgresql.org/docs/current/functions-info.html#FUNCTIONS-CONTROLDATA

postgres=# select * from pg_control_system();
-[ RECORD 1 ]------------+-----------------------
pg_control_version       | 1300
catalog_version_no       | 202007201
system_identifier        | 6984324583401825557
pg_control_last_modified | 2021-09-11 06:39:13+00

postgres=# select * from pg_control_checkpoint();
-[ RECORD 1 ]--------+-------------------------
checkpoint_lsn       | 1/A2160AD8
redo_lsn             | 1/A2160AA0
redo_wal_file        | 0000000100000001000000A2
......

postgres=# select * from pg_control_init();
-[ RECORD 1 ]--------------+---------
max_data_alignment         | 8
database_block_size        | 8192
blocks_per_segment         | 131072
wal_block_size             | 8192
bytes_per_wal_segment      | 16777216
max_identifier_length      | 64
max_index_columns          | 32
max_toast_chunk_size       | 1996
large_object_chunk_size    | 2048
float8_pass_by_value       | t
data_page_checksum_version | 0

postgres=# select * from pg_control_recovery();
-[ RECORD 1 ]-----------------+----
min_recovery_end_lsn          | 0/0
min_recovery_end_timeline     | 0
backup_start_lsn              | 0/0
backup_end_lsn                | 0/0
end_of_backup_record_required | f

$ pg_resetwal -D /var/lib/pgsql/node_1/data/ --dry-run
Current pg_control values:

# Restoring pg_control
In the unlikely event pg_control becomes corrupted, it might be possible to restore it using pg_resetwal
pg_control version number:            1300
Catalog version number:               202108031
Database system identifier:           6998038587784135836
Latest checkpoint's TimeLineID:       1
Latest checkpoint's full_page_writes: on
Latest checkpoint's NextXID:          0:709

######### 数据类型 ###########
# 日期时间类型
postgres=# show datestyle;
 DateStyle
-----------
 ISO, MDY
postgres=# select now();
              now
-------------------------------
 2021-09-04 05:43:17.282491+00
postgres=# set datestyle='SQL,DMY';
SET
postgres=# select now();
              now
--------------------------------
 04/09/2021 05:45:00.682158 UTC

postgres=# show intervalstyle;
 IntervalStyle
---------------
 postgres
 
postgres=# select interval '1 year 2mons';
   interval
---------------
 1 year 2 mons
(1 row)

postgres=# set intervalstyle='sql_standard';
SET
postgres=# select interval '1 year 2mons';
 interval
----------
 1-2

postgres=# show lc_monetary;
 lc_monetary
-------------
 en_US.UTF-8
(1 row)

postgres=# select '12.33'::money;
 money
--------
 $12.33
(1 row)

# money类型
postgres=# set lc_monetary='zh_CN';
SET
postgres=# select '12.33'::money;
  money
---------
 ￥12.33
(1 row)

# 自增数据类型 serial
postgres=# create table t2(id serial not null,name text);
CREATE TABLE

# 数据类型 enum
create type color_t as enum('blue', 'red', 'gray', 'black');

drop table if exists cars;

create table cars (
  brand text
, model text
, color color_t
);

insert into cars(brand, model, color) values 
('ferari', 'testarosa', 'red'),
('aston martin', 'db2', 'blue'),
('bentley', 'mulsanne', 'gray'),
('ford', 'T', 'black');

# 数据类型domain
接著來看一個 Create Domain 的例子,為了與 Oracle Date 資料型態相容.
CREATE DOMAIN tdate
    AS timestamp(0) without time zone;

使用了基本資料型態 timestamp(0) without time zone

在psql 使用 \dD ,可以列出現在Database 的 自定義 Domain

List of domains
+-[ RECORD 1 ]-------------------------------+
| Schema    | miku                           |
| Name      | tdate                          |
| Type      | timestamp(0) without time zone |
| Collation |                                |
| Nullable  |                                |
| Default   |                                |
| Check     |                                |
+-----------+--------------------------------+

這樣就能很容易了解到 定義 Domain 是基於其他基本資料型態,可以定義新的 Collation , 
這樣我們就能指定 Collation 方便排序使用.
還有指定 Nullable , Default, 還有建立前面提到過的 Check 運算式.

create domain 是 ANSI SQL 標準.
有了 domain, 我們可以很方便的定義 domain specific type, 讓我們開發系統時,
有符合領域特性的 type system.

接著我們來看實例

create domain md5 as
text not null
check (
    length(value) = 32
);

create table ithelp191002 (
  fname text
, checksum md5
);

insert into ithelp191002 values
('passwd', 'abcd123xxx');

ERROR:  23514: value for domain md5 violates check constraint "md5_check"
SCHEMA NAME:  miku
DATATYPE NAME:  md5
CONSTRAINT NAME:  md5_check

回報錯誤了...

insert into ithelp191002 values
('passwd', '76a2173be6393254e72ffa4d6df1030a');

這樣就正確了.

# 生成列 由其他列计算而来
postgres=# create table tax1(salary numeric,taxindex numeric,tax numeric generated always as (salary*taxindex) stored);
CREATE TABLE
postgres=# insert into tax1 values(10000,0.13);
INSERT 0 1
postgres=# select * from tax1;
-[ RECORD 1 ]-----
salary   | 10000
taxindex | 0.13
tax      | 1300.00

# hstore类型
postgres=# CREATE TABLE books (
postgres(#    id serial primary key,
postgres(#    title VARCHAR (255),
postgres(#    attr hstore
postgres(# );
CREATE TABLE
postgres=# INSERT INTO books (title, attr)
postgres-# VALUES
postgres-#    (
postgres(#       'PostgreSQL Tutorial',
postgres(#       '"paperback" => "243",
postgres'#       "publisher" => "postgresqltutorial.com",
postgres'#       "language"  => "English",
postgres'#       "ISBN-13"   => "978-1449370000",
postgres'#        "weight"   => "11.2 ounces"'
postgres(#    );
INSERT 0 1
postgres=# INSERT INTO books (title, attr)
postgres-# VALUES
postgres-#    (
postgres(#       'PostgreSQL Cheat Sheet',
postgres(#       '
postgres'# "paperback" => "5",
postgres'# "publisher" => "postgresqltutorial.com",
postgres'# "language"  => "English",
postgres'# "ISBN-13"   => "978-1449370001",
postgres'# "weight"    => "1 ounces"'
postgres(#    );
INSERT 0 1
postgres=# select * from books;
 id |         title          |                                                                  attr
----+------------------------+----------------------------------------------------------------------------------------------------------------------------------------
  1 | PostgreSQL Tutorial    | "weight"=>"11.2 ounces", "ISBN-13"=>"978-1449370000", "language"=>"English", "paperback"=>"243", "publisher"=>"postgresqltutorial.com"
  2 | PostgreSQL Cheat Sheet | "weight"=>"1 ounces", "ISBN-13"=>"978-1449370001", "language"=>"English", "paperback"=>"5", "publisher"=>"postgresqltutorial.com"
(2 rows)

返回hstore列所有key
postgres=# select akeys(attr) from books;
                     akeys
-----------------------------------------------
 {weight,ISBN-13,language,paperback,publisher}
 {weight,ISBN-13,language,paperback,publisher}
(2 rows)
或者使用skeys()函数返回key集合：
postgres=# select skeys(attr) from books;
   skeys
-----------
 weight
 ISBN-13
 language
 paperback
 publisher
 weight
 ISBN-13
 language
 paperback
 publisher

返回hstore列所有value
postgres=# select avals(attr) from books;
或者使用svals()函数返回结果集：
postgres=# select svals(attr) from books;

转换hstore为json
postgres=# select title,hstore_to_json(attr) from books;
         title          |                                                              hstore_to_json
------------------------+------------------------------------------------------------------------------------------------------------------------------------------
 PostgreSQL Tutorial    | {"weight": "11.2 ounces", "ISBN-13": "978-1449370000", "language": "English", "paperback": "243", "publisher": "postgresqltutorial.com"}
 PostgreSQL Cheat Sheet | {"weight": "1 ounces", "ISBN-13": "978-1449370001", "language": "English", "paperback": "5", "publisher": "postgresqltutorial.com"}
(2 rows)

each函数转换hstore数据为结果集
postgres=# select title,(each(attr)).* from books;
         title          |    key    |         value
------------------------+-----------+------------------------
 PostgreSQL Tutorial    | weight    | 11.2 ounces
 PostgreSQL Tutorial    | ISBN-13   | 978-1449370000
 PostgreSQL Tutorial    | language  | English
 PostgreSQL Tutorial    | paperback | 243
 PostgreSQL Tutorial    | publisher | postgresqltutorial.com
 PostgreSQL Cheat Sheet | weight    | 1 ounces
 PostgreSQL Cheat Sheet | ISBN-13   | 978-1449370001
 PostgreSQL Cheat Sheet | language  | English
 PostgreSQL Cheat Sheet | paperback | 5
 PostgreSQL Cheat Sheet | publisher | postgresqltutorial.com

查询特定key的值
postgres=# select attr->'ISBN-13' AS isbn from books;
      isbn
----------------
 978-1449370000
 978-1449370001
(2 rows)
where子句
postgres=# SELECT
postgres-#    attr -> 'weight' AS weight
postgres-# FROM
postgres-#    books
postgres-# WHERE
postgres-#    attr -> 'ISBN-13' = '978-1449370000';
   weight
-------------
 11.2 ounces
(1 row)

增
UPDATE books
SET attr = attr || '"freeshipping"=>"yes"' :: hstore;
删
UPDATE books 
SET attr = delete(attr, 'freeshipping');
改
UPDATE books
SET attr = attr || '"freeshipping"=>"no"' :: hstore;

# 查询postgres 参数
postgres=# select * from pg_settings where name in ('wal_level','archive_mode','archive_command');

# 导出select查询
Either: 
 SELECT * FROM table \g filename
to just output to the file 'filename', or:
 select * from lineshoot \g |cat >> /solsolute/path/filename
to append to the file. Both in psql, or:
 echo 'SELECT * FROM table' | psql database >> test.out
from your terminal.

# recursive CTE
 with recursive t(n) as (
 values(1)                                     --非递归子句
 union all
 select n+1 from t where n<100)                --递归子句  t是temp working table
 select sum(n) from t;
 sum
------
 5050
(1 row)

# 数据库之外创建用户和数据库
createuser --pwprompt zabbix
createdb -O zabbix -E Unicode -T template0 zabbix

\c dbname username  切换数据库或用户

# 创建用户和赋予用户对象权限
zabbix=# create user chensen with password 'chensen';

zabbix=# grant select on users to chensen;
GRANT
zabbix=# \dp+ users;
                               Access privileges
 Schema | Name  | Type  |   Access privileges   | Column privileges | Policies
--------+-------+-------+-----------------------+-------------------+----------
 public | users | table | zabbix=arwdDxt/zabbix+|                   |
        |       |       | chensen=r/zabbix      |                   |
(1 row)
zabbix=# grant update,insert,delete,truncate on users to chensen;
GRANT
zabbix=# \dp+ users;
                               Access privileges
 Schema | Name  | Type  |   Access privileges   | Column privileges | Policies
--------+-------+-------+-----------------------+-------------------+----------
 public | users | table | zabbix=arwdDxt/zabbix+|                   |
        |       |       | chensen=arwdD/zabbix  |                   |
(1 row)

postgres=# grant select on it1 to chensen with grant option;
GRANT
postgres=# \dp+ it1
                                Access privileges
 Schema | Name | Type  |     Access privileges     | Column privileges | Policies
--------+------+-------+---------------------------+-------------------+----------
 public | it1  | table | postgres=arwdDxt/postgres+|                   |
        |      |       | chensen=r*/postgres       |                   |
上面的r*代表 with grant option

# grant命令
GRANT on Roles (with admin option)     用於將角色加入成為其他角色的成員。如果指定了 WITH ADMIN OPTION，則該成員就可以將角色的成員資格再授予其他人
GRANT on Objects (with grant option)   对象权限

# 创建role时赋予权限
postgres=# create role cl LOGIN CREATEDB CREATEROLE PASSWORD 'cloverclock123' valid until '2021-09-28';
CREATE ROLE
postgres=# \du
                                      List of roles
  Role name  |                         Attributes                         |  Member of
-------------+------------------------------------------------------------+--------------
 chensen     |                                                            | {}
 cl          | Create role, Create DB                                    +| {}
             | Password valid until 2021-09-28 00:00:00+00                |
 postgres    | Superuser, Create role, Create DB, Replication, Bypass RLS | {}

# group role以及 grant grouprole to role
postgres=# create role dba CREATEDB CREATEROLE;
CREATE ROLE
postgres=# create role clm LOGIN PASSWORD 'clm123123';
CREATE ROLE
postgres=# \du
                                      List of roles
  Role name  |                         Attributes                         |  Member of
-------------+------------------------------------------------------------+--------------
 chensen     |                                                            | {}
 cl          | Create role, Create DB                                    +| {}
             | Password valid until 2021-09-28 00:00:00+00                |
 clm         |                                                            | {}
 dba         | Create role, Create DB, Cannot login                       | {}
 postgres    | Superuser, Create role, Create DB, Replication, Bypass RLS | {}
 repl        | Replication                                               +| {}
             | 30 connections                                             |
 sam         |                                                            | {}
 zbx_monitor |                                                            | {pg_monitor}

postgres=# grant dba to clm;
GRANT ROLE
postgres=# \du
                                      List of roles
  Role name  |                         Attributes                         |  Member of
-------------+------------------------------------------------------------+--------------
 chensen     |                                                            | {}
 cl          | Create role, Create DB                                    +| {}
             | Password valid until 2021-09-28 00:00:00+00                |
 clm         |                                                            | {dba}
 dba         | Create role, Create DB, Cannot login                       | {}
 postgres    | Superuser, Create role, Create DB, Replication, Bypass RLS | {}
 repl        | Replication                                               +| {}
             | 30 connections                                             |
 sam         |                                                            | {}
 zbx_monitor |                                                            | {pg_monitor}

postgres=# create role clm2 LOGIN PASSWORD 'clm123123';
CREATE ROLE
postgres=# grant dba to clm2 with admin option;
GRANT ROLE
postgres=# \du
                                      List of roles
  Role name  |                         Attributes                         |  Member of
-------------+------------------------------------------------------------+--------------
 chensen     |                                                            | {}
 cl          | Create role, Create DB                                    +| {}
             | Password valid until 2021-09-28 00:00:00+00                |
 clm         |                                                            | {dba}
 clm2        |                                                            | {dba}
 dba         | Create role, Create DB, Cannot login                       | {}
 postgres    | Superuser, Create role, Create DB, Replication, Bypass RLS | {}
 repl        | Replication                                               +| {}
             | 30 connections                                             |
 sam         |                                                            | {}
 zbx_monitor |                                                            | {pg_monitor}
 
postgres=# select * from pg_authid where rolname='sam';
  oid  | rolname | rolsuper | rolinherit | rolcreaterole | rolcreatedb | rolcanlogin | rolreplication | rolbypassrls | rolconnlimit |                                                              rolpassword                                                              | r
olvaliduntil
-------+---------+----------+------------+---------------+-------------+-------------+----------------+--------------+--------------+---------------------------------------------------------------------------------------------------------------------------------------+--
-------------
 18728 | sam     | f        | t          | f             | f           | t           | f              | f            |           -1 | SCRAM-SHA-256$4096:DNulkDpKBLqkY90Z4z4P3Q==$f+jAGXc1BC7K39LJ3XXmLQ7RpFUGotQaC1uJiBIonHk=:cCx2zsHzUGUooAtoyB4U79afIWnX4qpeXZglPC6WoGk= |
(1 row)

# 更改用户权限
赋予权限:alter user xxx with (CREATEDB, CREATEROLE, CREATEUSER, and even SUPERUSER)
revoke权限:  alter user xxx with nocreatedb  权限前面加no

postgres=# \du chensen
           List of roles
 Role name | Attributes | Member of
-----------+------------+-----------
 chensen   |            | {}

postgres=# alter user chensen with superuser;
ALTER ROLE
postgres=# \du chensen
           List of roles
 Role name | Attributes | Member of
-----------+------------+-----------
 chensen   | Superuser  | {}
postgres=# alter user chensen with nosuperuser;
ALTER ROLE
postgres=# \du chensen
           List of roles
 Role name | Attributes | Member of
-----------+------------+-----------
 chensen   |            | {}


pg_hba.conf
Trust Authentication
Allow the connection unconditionally. This method allows anyone that can connect to the PostgreSQL database server to login as any PostgreSQL user they wish, 
without the need for a password or any other authentication.
Ident authentication can only be used on TCP/IP connections. 
When specified for local connections, peer authentication will be used instead.
md5 Authentication
Require the client to supply a double-MD5-hashed password for authentication.

最好设置为允许所有用户通过网络走密码验证，这样就不需要reload postgresql
host    all             all             0.0.0.0/0               md5


新增用户sam, 用md5验证
-bash-4.2$ grep sam $PGDATA/pg_hba.conf |grep -v '#'
host    all             sam             0.0.0.0/0               md5
host    all             sam             127.0.0.1/32               md5
-------写.pgpass文件
-bash-4.2$ cat .pgpass
127.0.0.1:5432:postgres:zbx_monitor:vSTJ456
127.0.0.1:5432:postgres:sam:Foxconn123
-bash-4.2$ psql -h 127.0.0.1 -U sam -d postgres -c "select * from dbs"
   key   |              value
---------+---------------------------------
 mongo   | This is mongo cookbook
 mysql   | I like mysql
 oracle  | big database
 access  | microsoft tiny database
 mssql   | Microsoft SQL Server
 redis   | popular opensource key value db
 sqlite3 | a good tiny database
(7 rows)
-------不写.pgpass文件
-bash-4.2$ PGPASSWORD=Foxconn123 psql -h 127.0.0.1 -U sam -d postgres -c "select * from dbs"
   key   |              value
---------+---------------------------------
 mongo   | This is mongo cookbook
 mysql   | I like mysql
 oracle  | big database
 access  | microsoft tiny database
 mssql   | Microsoft SQL Server
 redis   | popular opensource key value db
 sqlite3 | a good tiny database
(7 rows)

-bash-4.2$ psql postgresql://sam:Foxconn123@127.0.0.1/postgres  -c "select * from dbs"
   key   |              value
---------+---------------------------------
 mongo   | This is mongo cookbook
 mysql   | I like mysql
 oracle  | big database
 access  | microsoft tiny database
 mssql   | Microsoft SQL Server
 redis   | popular opensource key value db
 sqlite3 | a good tiny database
(7 rows)


# search_path
默认设置为
postgres=# show search_path;
   search_path
-----------------
 "$user", public
(1 row)
此时看不到其他用户的schema的表
如要看schema chensen的表
postgres=# set search_path to chensen;
SET
postgres=# \d
                       List of relations
 Schema  |            Name            |     Type      |  Owner
---------+----------------------------+---------------+---------
 chensen | acknowledges               | foreign table | chensen
 chensen | actions                    | foreign table | chensen
 chensen | alerts                     | foreign table | chensen
 chensen | auditlog                   | foreign table | chensen
或者
postgres=# select * from information_schema.tables where table_schema='chensen';

### root账号下使用psql
[root@postgres-1 ~]# sudo -u postgres psql -c 'select * from cron.job'
could not change directory to "/root": Permission denied
 jobid |  schedule  |          command          | nodename | nodeport | database | username | active | jobname
-------+------------+---------------------------+----------+----------+----------+----------+--------+---------
     1 | 40 * * * * | SELECT profile.snapshot() |          |     5432 | postgres | postgres | t      |


## copy命令进行导入导出
# 导出
copy 表名 to '文件名' with csv;
copy (select a.hostid,a.name,c.name from hosts as a inner join hosts_groups as b on a.hostid=b.hostid inner join hstgrp as c on b.groupid=c.groupid where a.name not like 'Template%') to '/tmp/zabbixhost.csv' with csv;
# 导入
postgres=# create table staff(name text,team text,position text,height integer,weight integer,age numeric);
CREATE TABLE
postgres=# \copy staff from '/var/lib/pgsql/sample2.csv' with csv header delimiter ',' encoding 'UTF8';
COPY 1034

# lateral join 实现select嵌套循环
伪代码
select name from staff as o1
for each name 
loop
do 
DML语句 from staff where name= o1.name
done
done

实现
postgres=# select * from (select name from staff) as o1, lateral (select row_to_json(ta) from (select name,team,position,(select row_to_json(ti) from (select height,weight,age where name=o1.name) ti )as details from staff where name=o1.name) ta) as o2 order by name;
        name         |                                                        row_to_json
---------------------+----------------------------------------------------------------------------------------------------------------------------
 Aaron Boone         | {"name":"Aaron Boone","team":" FLA","position":" Third Baseman","details":{"height":74,"weight":200,"age":33.98}}
 Aaron Cook          | {"name":"Aaron Cook","team":" COL","position":" Starting Pitcher","details":{"height":75,"weight":205,"age":28.06}}
 Aaron Fultz         | {"name":"Aaron Fultz","team":" CLE","position":" Relief Pitcher","details":{"height":72,"weight":205,"age":33.49}}
 Aaron Harang        | {"name":"Aaron Harang","team":" CIN","position":" Starting Pitcher","details":{"height":79,"weight":240,"age":28.81}}

# 窗口函数
select groupid,hostid,hostgroupid,row_number() over(partition by groupid order by hostgroupid) as hostgroupid_asc from hosts_groups;
 groupid | hostid | hostgroupid | hostgroupid_asc
---------+--------+-------------+-----------------
       4 |  10084 |          92 |               1
       8 |  10093 |         175 |               1
       8 |  10095 |         177 |               2
       8 |  10094 |         178 |               3
       8 |  10096 |         179 |               4
       8 |  10097 |         180 |               5
       8 |  10098 |         181 |               6
       8 |  10099 |         182 |               7
       8 |  10100 |         183 |               8
       8 |  10101 |         184 |               9
       8 |  10102 |         185 |              10
       8 |  10103 |         186 |              11
       8 |  10050 |         187 |              12
       8 |  10183 |         209 |              13

# generate_series 生成序列
https://blog.csdn.net/horses/article/details/107337354
基于时间
postgres=# select * from generate_series('2021-09-01 00:00:00'::timestamp,'2021-10-01 00:00:00'::timestamp,interval '1 day');
   generate_series
---------------------
 2021-09-01 00:00:00
 2021-09-02 00:00:00
 2021-09-03 00:00:00
 2021-09-04 00:00:00
 postgres=# select * from generate_series('2021-10-01 00:00:00'::timestamp,'2021-09-01 00:00:00'::timestamp,interval '-1 day');
   generate_series
---------------------
 2021-10-01 00:00:00
 2021-09-30 00:00:00
 2021-09-29 00:00:00
 2021-09-28 00:00:00
 2021-09-27 00:00:00

基于数字， asc, desc
postgres=# select * from generate_series(5,1,-1);
 generate_series
-----------------
               5
               4
               3
               2
               1
(5 rows)

postgres=# select * from generate_series(1,5);
 generate_series
-----------------
               1
               2
               3
               4
               5
postgres=# select * from generate_series(1,10,2);
 generate_series
-----------------
               1
               3
               5
               7
               9
基于字符
postgres=# select chr(v) from generate_series(65,90) v;
 chr
-----
 A
 B
 C
 D

postgres=# select chr(v) from generate_series(90,65,-1) v;
 chr
-----
 Z
 Y
 X
 W

# CTE生成序列
postgres=# with recursive t(n) as (
  values (1)
  union all
  select n+2 from t where n<50
)
select n from t;
 n
----
  1
  3
  5
  7
  9
 11
postgres=# with recursive t(n) as (
  values (1)
  union all
  select n*2 from t where n<50
)
select n from t;
 n
----
  1
  2
  4
  8
 16
 32
 64

# 生成指定范围内的随机数
CREATE OR REPLACE FUNCTION public.random_between(low integer, high integer)
 RETURNS integer
 LANGUAGE plpgsql
 STRICT
AS $function$
BEGIN
   RETURN floor(random()* (high-low + 1) + low);
END;
$function$
postgres=# select random_between(1000,1500);
 random_between
----------------
           1248
postgres=# insert into r1(value) select random_between(1,99999) from generate_series(1,999);
INSERT 0 999
postgres=# select * from r1;
 id  | value
-----+-------
   1 | 28586
   2 | 62447
   3 | 44234
	   
# 绑定变量和执行计划
create table t3(id serial,t text);
\d t3
insert into t3(t) select 'Linux' from generate_series(1,100);
select * from t3;
insert into t3(t) select 'Windows' from generate_series(1,50);
select * from t3;
create index idx_t3_t on t3(t);
analyze t3;
explain select count(*) from t3 where t='Linux';
prepare mypan(text) as select count(*) from t3 where t=$1;
explain execute mypan('Linux');

#索引
PostgreSQL的B-tree索引与Oracle的B-tree索引区别比较大，主要是以下4点：
1.PostgreSQL中索引会存储NULL，而Oracle不会；  还可以指定null first, null last
2.PostgreSQL中建立索引时，可以使用where来建立部分索引，而Oracle不能；
3.PostgreSQL中可以对同一列建立两个相同的索引，而Oracle不能；
4.PostgreSQL中可以使用concurrently关键字达到创建索引时不阻塞表的DML的功能，Oracle也有online参数实现类似的功能。

#查看锁
在一个session里
postgres=# begin;
BEGIN
postgres=*# insert into dbs values('oracle','big database');
INSERT 0 1

在另一个session里
select pid, state, usename, query, query_start 
from pg_stat_activity 
where pid in (
  select pid from pg_locks l 
  join pg_class t on l.relation = t.oid 
  and t.relkind = 'r' 
  where t.relname = 'dbs'
);
  pid  |        state        | usename  |                       query                        |          query_start
-------+---------------------+----------+----------------------------------------------------+-------------------------------
 27066 | idle in transaction | postgres | insert into dbs values('sqlite3','tiny database'); | 2021-09-11 08:21:47.500668+00
 27719 | idle in transaction | postgres | select key from dbs;                               | 2021-09-11 08:20:19.181387+00
(2 rows)

postgres=# select locktype,relation,mode from pg_locks;
   locktype    | relation |       mode
---------------+----------+------------------
 relation      |    12141 | AccessShareLock
 virtualxid    |          | ExclusiveLock
 relation      |    16676 | AccessShareLock
 relation      |    16669 | AccessShareLock
 relation      |    16472 | RowExclusiveLock
 virtualxid    |          | ExclusiveLock
 relation      |    16472 | AccessShareLock
 virtualxid    |          | ExclusiveLock
 transactionid |          | ExclusiveLock

postgres=# select oid,relname,relfilenode from pg_class where relname='dbs';
  oid  | relname | relfilenode
-------+---------+-------------
 16472 | dbs     |       16472

kill进程 
SELECT pg_cancel_backend(11929);
SELECT pg_terminate_backend(11929); 

查看当前事务锁等待、持锁信息的SQL
create view v_locks_monitor as   
with    
t_wait as    
(    
  select a.mode,a.locktype,a.database,a.relation,a.page,a.tuple,a.classid,a.granted,   
  a.objid,a.objsubid,a.pid,a.virtualtransaction,a.virtualxid,a.transactionid,a.fastpath,    
  b.state,b.query,b.xact_start,b.query_start,b.usename,b.datname,b.client_addr,b.client_port,b.application_name   
    from pg_locks a,pg_stat_activity b where a.pid=b.pid and not a.granted   
),   
t_run as   
(   
  select a.mode,a.locktype,a.database,a.relation,a.page,a.tuple,a.classid,a.granted,   
  a.objid,a.objsubid,a.pid,a.virtualtransaction,a.virtualxid,a.transactionid,a.fastpath,   
  b.state,b.query,b.xact_start,b.query_start,b.usename,b.datname,b.client_addr,b.client_port,b.application_name   
    from pg_locks a,pg_stat_activity b where a.pid=b.pid and a.granted   
),   
t_overlap as   
(   
  select r.* from t_wait w join t_run r on   
  (   
    r.locktype is not distinct from w.locktype and   
    r.database is not distinct from w.database and   
    r.relation is not distinct from w.relation and   
    r.page is not distinct from w.page and   
    r.tuple is not distinct from w.tuple and   
    r.virtualxid is not distinct from w.virtualxid and   
    r.transactionid is not distinct from w.transactionid and   
    r.classid is not distinct from w.classid and   
    r.objid is not distinct from w.objid and   
    r.objsubid is not distinct from w.objsubid and   
    r.pid <> w.pid   
  )    
),    
t_unionall as    
(    
  select r.* from t_overlap r    
  union all    
  select w.* from t_wait w    
)    
select locktype,datname,relation::regclass,page,tuple,virtualxid,transactionid::text,classid::regclass,objid,objsubid,   
string_agg(   
'Pid: '||case when pid is null then 'NULL' else pid::text end||chr(10)||   
'Lock_Granted: '||case when granted is null then 'NULL' else granted::text end||' , Mode: '||case when mode is null then 'NULL' else mode::text end||' , FastPath: '||case when fastpath is null then 'NULL' else fastpath::text end||' , VirtualTransaction: '||case when virtualtransaction is null then 'NULL' else virtualtransaction::text end||' , Session_State: '||case when state is null then 'NULL' else state::text end||chr(10)||   
'Username: '||case when usename is null then 'NULL' else usename::text end||' , Database: '||case when datname is null then 'NULL' else datname::text end||' , Client_Addr: '||case when client_addr is null then 'NULL' else client_addr::text end||' , Client_Port: '||case when client_port is null then 'NULL' else client_port::text end||' , Application_Name: '||case when application_name is null then 'NULL' else application_name::text end||chr(10)||    
'Xact_Start: '||case when xact_start is null then 'NULL' else xact_start::text end||' , Query_Start: '||case when query_start is null then 'NULL' else query_start::text end||' , Xact_Elapse: '||case when (now()-xact_start) is null then 'NULL' else (now()-xact_start)::text end||' , Query_Elapse: '||case when (now()-query_start) is null then 'NULL' else (now()-query_start)::text end||chr(10)||    
'SQL (Current SQL in Transaction): '||chr(10)||  
case when query is null then 'NULL' else query::text end,    
chr(10)||'--------'||chr(10)    
order by    
  (  case mode    
    when 'INVALID' then 0   
    when 'AccessShareLock' then 1   
    when 'RowShareLock' then 2   
    when 'RowExclusiveLock' then 3   
    when 'ShareUpdateExclusiveLock' then 4   
    when 'ShareLock' then 5   
    when 'ShareRowExclusiveLock' then 6   
    when 'ExclusiveLock' then 7   
    when 'AccessExclusiveLock' then 8   
    else 0   
  end  ) desc,   
  (case when granted then 0 else 1 end)  
) as lock_conflict  
from t_unionall   
group by   
locktype,datname,relation,page,tuple,virtualxid,transactionid::text,classid,objid,objsubid ;  

###  table access method
https://www.postgresql.fastware.com/blog/postgresql-table-access-methods
Is it the same as foreign data wrappers? What is the difference?
Foreign data wrappers are intended to access foreign data, while table access methods are used to access local data.

For example, suppose you have a requirement to use columnar data in your application. With foreign data wrappers, you would need to use to access a remote server containing the
 columnar data (in this case using cstore_fdw), which would reduce processing performance.

But with table access methods, it is possible to store columnar tables locally, which speeds up processing. Note though, that PostgreSQL 13 does not support table access methods for columnar tables.

In short, foreign data wrappers and table access methods target different needs. The former allows users to access data in a remote server that was never intended to be stored locally, 
while the latter allows users to store data locally using different supported methods.

Possible implementations of table access methods in PostgreSQL 14 and later include, among others, the following:

An alternative to heap, such as zheap
Columnar tables, such as Zedstore
In-memory tables
Indexed tables

### exists
dvdrental=# select f.film_id,f.title,f.release_year,f.rating from film f where exists (select * from film_category c where c.film_id=f.film_id and category_id=2) order by rating;
 film_id |         title          | release_year | rating
---------+------------------------+--------------+--------
     569 | Menagerie Rushmore     |         2006 | G
     901 | Tracy Cider            |         2006 | G
     402 | Harper Dying           |         2006 | G
     430 | Hook Chariots          |         2006 | G
     510 | Lawless Vision         |         2006 | G
