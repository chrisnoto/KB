psql登录方法
1  psql -U xxx -d xxx
2  psql 'host=rep01 user=repmgr dbname=repmgr connect_timeout=2'
3  psql postgres://[USERNAME]:[PASSWORD]@[HOSTNAME]:[PORT]/[DATABASENAME]?sslmode=require

postgres@u2004:~$ psql -U chensen -h 10.67.39.58 -d chensen

postgres@u2004:~$ psql 'host=10.67.39.58 user=chensen dbname=chensen connect_timeout=2'

postgres@u2004:~$ psql postgres://chensen:chensen@10.67.39.58:5432/chensen

postgres@u2004:~$ psql postgres://chensen@10.67.39.58:5432/chensen
Password for user chensen:

#########  逻辑概念 ##########
在 Postgresql中是以下的關係
Computer -> Cluter -> Catalog -> Schema -> Database Object (Table/View 等等)

一台電腦可以有多個 Cluster,在 Oracle 叫 Instance
一個 Cluster 可以有多個 Catalog ,包含Postgresql在內,許多資料庫會另外稱作 Database.
一個 Database 可以有多個 Schema, 又叫做  namespace of relations (關聯式物件), 還有相關存取規則(ACL).	

## schema
postgres=# create schema authorization chensen;    为用户创建schema
CREATE SCHEMA
postgres=# \dn
  List of schemas
  Name   |  Owner
---------+----------
 chensen | chensen

# information_schema
postgres=# select * from information_schema.information_schema_catalog_name;
 catalog_name
--------------
 postgres
(1 row)


两个隐藏schema   pg_catalog和information_schema
postgres=# \dn      隐藏的看不到       *** 可以加S来查看全部schema， \dnS ***
  List of schemas
  Name  |  Owner
--------+----------
 public | postgres
(1 row)

postgres=# select table_schema
postgres-#   from information_schema.tables
postgres-#  group by table_schema;
    table_schema
--------------------
 public
 pg_catalog
 information_schema

postgres=# \dn pg_catalog
    List of schemas
    Name    |  Owner
------------+----------
 pg_catalog | postgres
(1 row)

postgres=# \dn information_schema
        List of schemas
        Name        |  Owner
--------------------+----------
 information_schema | postgres
(1 row)

Postgresql独特的术语
a tuple or an item                is a synonym for a row
a relation                        is a synonym for a table
a filenode                        is an id which represent a reference to a table or an index.
a block and page                  are equals and they represent a 8kb segment information the file storing the table.
a heap                            refer to heap file. Heap files are lists of unordered records of variable size. Although sharing a similar name, heap files are different from heap data structure.
CTID                              represent the physical location of the row version within its table. CTID is also a special column available for every tables but not visible unless specifically mentioned. It consists of a page number and the index of an item identifier.
OID                               stands for Object Identifier.
database cluster                  we call a database cluster the storage area on disk. A database cluster is a collection of databases that is managed by a single instance of a running database server.
VACCUM                            PostgreSQL databases require periodic maintenance known as vacuuming	

###### oid  filenode
shell命令找出db与oid的映射关系
-bash-4.2$ oid2name
All databases:
    Oid  Database Name  Tablespace
----------------------------------
  14172       postgres  pg_default
  14171      template0  pg_default
      1      template1  pg_default
-bash-4.2$ oid2name -s
All tablespaces:
    Oid  Tablespace Name
------------------------
   1663       pg_default
   1664        pg_global
  16719           mtbs01

-bash-4.2$ oid2name -d postgres -i 包括表，索引，序列
From database "postgres":
  Filenode    Table Name
------------------------
     16669         books
     16667  books_id_seq
     16676    books_pkey
     16472           dbs
     16462         facts
     16460  facts_id_seq
     16469    facts_pkey
     16715      idx_t3_t
     16385            it
     16391           it1
     16521         staff
     16402            t2
     16400     t2_id_seq
     16713            t3
     16416     t3_id_seq
     16427            t4
     16409          tax1
     16397          tbl1
	  
sql命令找出db与oid的映射关系
postgres=# select oid, datname from pg_database;
  oid  |  datname
-------+-----------
 14172 | postgres
     1 | template1
 14171 | template0
 
sql命令找出表的存放路径	  
postgres=# select pg_relation_filepath('books');
 pg_relation_filepath
----------------------
 base/14172/16669
(1 row)
shell命令找出表的filenode
-bash-4.2$ oid2name -d postgres -t books
From database "postgres":
  Filenode  Table Name
----------------------
     16669       books
注意：A table's filenode often matches its OID, this is not necessarily the case
postgres=# select oid,relname,relfilenode from pg_class where relname='books';
  oid  | relname | relfilenode
-------+---------+-------------
 16669 | books   |       16669
 server是外部表
postgres=# select oid,relname,relfilenode from pg_class where relname='server';
  oid  | relname | relfilenode
-------+---------+-------------
 16487 | server  |           0
	
如果想知道这些快捷命令后面用了什么SQL，可以开启-E选项
-bash-4.2$ psql -E
psql (13.3)
Type "help" for help.

postgres=# \l
********* QUERY **********
SELECT d.datname as "Name",
       pg_catalog.pg_get_userbyid(d.datdba) as "Owner",
       pg_catalog.pg_encoding_to_char(d.encoding) as "Encoding",
       d.datcollate as "Collate",
       d.datctype as "Ctype",
       pg_catalog.array_to_string(d.datacl, E'\n') AS "Access privileges"
FROM pg_catalog.pg_database d
ORDER BY 1;
**************************

                                  List of databases
   Name    |  Owner   | Encoding |   Collate   |    Ctype    |   Access privileges
-----------+----------+----------+-------------+-------------+-----------------------
 postgres  | postgres | UTF8     | en_US.UTF-8 | en_US.UTF-8 |
 template0 | postgres | UTF8     | en_US.UTF-8 | en_US.UTF-8 | =c/postgres          +
           |          |          |             |             | postgres=CTc/postgres
 template1 | postgres | UTF8     | en_US.UTF-8 | en_US.UTF-8 | =c/postgres          +
           |          |          |             |             | postgres=CTc/postgres
或者postgres=# \set ECHO_HIDDEN on

####### 物理概念 ###########
tablespace
postgres=# select oid,* from pg_tablespace;
 oid  | oid  |  spcname   | spcowner | spcacl | spcoptions
------+------+------------+----------+--------+------------
 1663 | 1663 | pg_default |       10 |        |
 1664 | 1664 | pg_global  |       10 |        |
pg_default默认的表空间                        The location of the pg_default tablespace is $PGDATA\base
pg_global 存放'database cluster' level的表    The location of the pg_global tablespace is $PGDATA\global
查看pg_global表空间的表有哪些
postgres=# select oid,relname,reltablespace from pg_class where  reltablespace=1664;
 oid  |                 relname                 | reltablespace
------+-----------------------------------------+---------------
 4175 | pg_toast_1260                           |          1664
 4176 | pg_toast_1260_index                     |          1664
...........
 4185 | pg_toast_1213                           |          1664
 4186 | pg_toast_1213_index                     |          1664
 2676 | pg_authid_rolname_index                 |          1664
 2677 | pg_authid_oid_index                     |          1664
 2694 | pg_auth_members_role_member_index       |          1664
 2695 | pg_auth_members_member_role_index       |          1664
 2671 | pg_database_datname_index               |          1664
 2672 | pg_database_oid_index                   |          1664
 2397 | pg_shdescription_o_c_index              |          1664
 1232 | pg_shdepend_depender_index              |          1664
 1233 | pg_shdepend_reference_index             |          1664
 2697 | pg_tablespace_oid_index                 |          1664
 2698 | pg_tablespace_spcname_index             |          1664
 2965 | pg_db_role_setting_databaseid_rol_index |          1664
 3593 | pg_shseclabel_object_index              |          1664
 6001 | pg_replication_origin_roiident_index    |          1664
 6002 | pg_replication_origin_roname_index      |          1664
 6114 | pg_subscription_oid_index               |          1664
 6115 | pg_subscription_subname_index           |          1664
 1260 | pg_authid                               |          1664
 6100 | pg_subscription                         |          1664
 1262 | pg_database                             |          1664
 2964 | pg_db_role_setting                      |          1664
 1213 | pg_tablespace                           |          1664
 1261 | pg_auth_members                         |          1664
 1214 | pg_shdepend                             |          1664
 2396 | pg_shdescription                        |          1664
 6000 | pg_replication_origin                   |          1664
 3592 | pg_shseclabel                           |          1664
(43 rows)
用户表空间
不要建在$PGDATA目录里
postgres=# create tablespace mtbs01 location '/data01';           
CREATE TABLESPACE
postgres=# select oid,* from pg_tablespace;
  oid  |  oid  |  spcname   | spcowner | spcacl | spcoptions
-------+-------+------------+----------+--------+------------
  1663 |  1663 | pg_default |       10 |        |
  1664 |  1664 | pg_global  |       10 |        |
 16719 | 16719 | mtbs01     |       10 |        |

在$PGDATA/pg_tblspc 目录下有指向/data01的链接
-bash-4.2$ ll $PGDATA/pg_tblspc
total 0
lrwxrwxrwx. 1 postgres postgres 7 Sep 11 03:23 16719 -> /data01
******* 创建tbs，导致从库down掉， 注意!
-bash-4.2$ cat postgresql-Sat.log          -postgres-2
2021-09-11 03:19:58.281 UTC [14107] FATAL:  directory "/data01" does not exist
2021-09-11 03:19:58.281 UTC [14107] HINT:  Create this directory for the tablespace before restarting the server.
2021-09-11 03:19:58.281 UTC [14107] CONTEXT:  WAL redo at 1/3D12500 for Tablespace/CREATE: 16719 "/data01"
2021-09-11 03:19:58.296 UTC [14104] LOG:  startup process (PID 14107) exited with exit code 1
2021-09-11 03:19:58.296 UTC [14104] LOG:  terminating any other active server processes
2021-09-11 03:19:58.341 UTC [14104] LOG:  database system is shut down


修改用户表空间的位置：  手动新建目录，拷贝原表空间的数据，用ln -s命令做新的链接(要停postgres)
#####  查看page ########
postgresql的表为堆表,表是page/block的集合，而page是row/tuple/item的集合
一个page为8k，一个表太大的话就会产生数据分片，一个分片最大1G，block/page数量为131072
A Pointer to an item is called CTID (ItemPointer), created by PostgreSQL, it consists of a page number and the index of an item identifier.
inside a page the pointers to the row are stored at the starts and the tuples (rows) are stored at the end of the page. 一个page里，指针在前，tuples在后

postgres=# select ctid,* from t3;
   ctid   |  id  |          t
----------+------+---------------------
 (0,1)    |  156 | Adam Donachie
 (0,2)    |  157 | Paul Bako
 (0,3)    |  158 | Ramon Hernandez
 (0,4)    |  159 | Kevin Millar
 (0,5)    |  160 | Chris Gomez

postgres=# \! ls -lh 13/data/base/14172/16427*
-rw-------. 1 postgres postgres 1.0G Aug  6 00:25 13/data/base/14172/16427
-rw-------. 1 postgres postgres 1.0G Aug  6 00:29 13/data/base/14172/16427.1
-rw-------. 1 postgres postgres 441M Aug  6 00:32 13/data/base/14172/16427.2
-rw-------. 1 postgres postgres 648K Aug  6 00:32 13/data/base/14172/16427_fsm
-rw-------. 1 postgres postgres  80K Aug  6 00:32 13/data/base/14172/16427_vm
postgres=# select oid,relname,relpages,reltuples from pg_class where relname='t4';
  oid  | relname | relpages |   reltuples
-------+---------+----------+---------------
 16427 | t4      |   318472 | 5.0000104e+07

page header结构
---------------------------------------------------------------------------------------------------------
Field	            Type	        Length	    Description
pd_lsn	            PageXLogRecPtr	8 bytes	    LSN: next byte after last byte of WAL record for last change to this page
pd_checksum	        uint16	        2 bytes	    Page checksum
pd_flags	        uint16	        2 bytes	    Flag bits
pd_lower	        LocationIndex	2 bytes	    Offset to start of free space
pd_upper	        LocationIndex	2 bytes   	Offset to end of free space
pd_special	        LocationIndex	2 bytes	    Offset to start of special space
pd_pagesize_version	uint16	        2 bytes   	Page size and layout version number information
pd_prune_xid	    TransactionId	4 bytes  	Oldest unpruned XMAX on page, or zero if none
---------------------------------------------------------------------------------------------------------
HeapTupleHeaderData结构
---------------------------------------------------------------------------------------------------------
Field	            Type	     	Length	    Description
t_xmin	            TransactionId	4 bytes	    insert XID stamp
t_xmax	            TransactionId	4 bytes	    delete XID stamp
t_cid	            CommandId	    4 bytes	    insert and/or delete CID stamp (overlays with t_xvac)
t_xvac	            TransactionId	4 bytes	    XID for VACUUM operation moving a row version
t_ctid	            ItemPointerData	6 bytes	    current TID of this or newer row version
t_infomask2         uint16		    2 bytes	    number of attributes, plus various flag bits
t_infomask	        uint16		    2 bytes	    various flag bits
t_hoff            	uint8	     	1 byte	    offset to user data
---------------------------------------------------------------------------------------------------------
postgres=# create extension pageinspect ;
CREATE EXTENSION
postgres=# select * from page_header(get_raw_page('t3',0));
    lsn    | checksum | flags | lower | upper | special | pagesize | version | prune_xid
-----------+----------+-------+-------+-------+---------+----------+---------+-----------
 1/3B99988 |        0 |     0 |   636 |  2072 |    8192 |     8192 |       4 |       567(一个删除的事务)

postgres=# select count(*) from t3;
 count
-------
   151
postgres=# select * from heap_page_items(get_raw_page('t3',0));
 lp  | lp_off | lp_flags | lp_len | t_xmin | t_xmax | t_field3 | t_ctid  | t_infomask2 | t_infomask | t_hoff | t_bits | t_oid |           t_data
-----+--------+----------+--------+--------+--------+----------+---------+-------------+------------+--------+--------+-------+----------------------------

 147 |   2312 |        1 |     36 |    499 |      0 |        0 | (0,147) |           2 |       2306 |     24 |        |       | \x930000001157696e646f7773
 148 |   2272 |        1 |     36 |    499 |      0 |        0 | (0,148) |           2 |       2306 |     24 |        |       | \x940000001157696e646f7773
 149 |   2232 |        1 |     36 |    499 |    568 |        0 | (0,153) |           2 |        258 |     24 |        |       | \x950000001157696e646f7773
 150 |   2192 |        1 |     36 |    499 |    567 |        0 | (0,150) |        8194 |       1282 |     24 |        |       | \x960000001157696e646f7773
 151 |   2152 |        1 |     36 |    565 |      0 |        0 | (0,151) |           2 |       2306 |     24 |        |       | \x9700000011536f6c61726973
 152 |   2112 |        1 |     35 |    566 |      0 |        0 | (0,152) |           2 |       2306 |     24 |        |       | \x980000000f43656e744f53
 153 |   2072 |        1 |     36 |    568 |      0 |        0 | (0,153) |           2 |      10242 |     24 |        |       | \x950000001146726565425344

事务568：  postgres=# update t3 set t='FreeBSD' where id=149;      \x950000001146726565425344
事务567：  postgres=# delete from t3 where id=150;
事务566：  postgres=# insert into t3(t) values('CentOS');          \x980000000f43656e744f53
事务565：  postgres=# insert into t3(t) values('Solaris');         \x9700000011536f6c61726973

通过lower能算出指针的数量。表中的指针数为(636-24)/4= 153 ，但实际表的数据只有151行。 指针有153个，lp 150代表delete，lp 149和153 代表update
空间没有减少。
现在vacuum表t3
postgres=# vacuum verbose t3;

postgres=# select * from page_header(get_raw_page('t3',0));
    lsn    | checksum | flags | lower | upper | special | pagesize | version | prune_xid
-----------+----------+-------+-------+-------+---------+----------+---------+-----------
 1/3B9BE38 |        0 |     5 |   636 |  2152 |    8192 |     8192 |       4 |         0
(1 row)

postgres=# select * from heap_page_items(get_raw_page('t3',0));
 lp  | lp_off | lp_flags | lp_len | t_xmin | t_xmax | t_field3 | t_ctid  | t_infomask2 | t_infomask | t_hoff | t_bits | t_oid |           t_data
 147 |   2312 |        1 |     36 |    499 |      0 |        0 | (0,147) |           2 |       2306 |     24 |        |       | \x930000001157696e646f7773
 148 |   2272 |        1 |     36 |    499 |      0 |        0 | (0,148) |           2 |       2306 |     24 |        |       | \x940000001157696e646f7773
 149 |      0 |        0 |      0 |        |        |          |         |             |            |        |        |       |
 150 |      0 |        0 |      0 |        |        |          |         |             |            |        |        |       |
 151 |   2232 |        1 |     36 |    565 |      0 |        0 | (0,151) |           2 |       2306 |     24 |        |       | \x9700000011536f6c61726973
 152 |   2192 |        1 |     35 |    566 |      0 |        0 | (0,152) |           2 |       2306 |     24 |        |       | \x980000000f43656e744f53
 153 |   2152 |        1 |     36 |    568 |      0 |        0 | (0,153) |           2 |      10498 |     24 |        |       | \x950000001146726565425344
vacuum后，指针不回收，页面回收了，upper从2072变为2152，两个40的单位
索引也可以查看，貌似没有变化
postgres=# select * from heap_page_items(get_raw_page('idx_t3_t',0));
 lp | lp_off | lp_flags | lp_len | t_xmin | t_xmax | t_field3 | t_ctid | t_infomask2 | t_infomask | t_hoff | t_bits | t_oid | t_data
----+--------+----------+--------+--------+--------+----------+--------+-------------+------------+--------+--------+-------+--------
  1 |  12642 |        2 |      2 |        |        |          |        |             |            |        |        |       |
  2 |      4 |        0 |      0 |        |        |          |        |             |            |        |        |       |
  3 |      1 |        0 |      0 |        |        |          |        |             |            |        |        |       |
  4 |      0 |        0 |      0 |        |        |          |        |             |            |        |        |       |
  5 |      1 |        0 |      0 |        |        |          |        |             |            |        |        |       |
  6 |      0 |        0 |      0 |        |        |          |        |             |            |        |        |       |
  7 |      0 |        0 |      0 |        |        |          |        |             |            |        |        |       |
  8 |      0 |        0 |      0 |        |        |          |        |             |            |        |        |       |
  9 |      0 |        0 |      0 |        |        |          |        |             |            |        |        |       |
 10 |      0 |        0 |  24568 |        |        |          |        |             |            |        |        |       |
 11 |      1 |        0 |      0 |        |        |          |        |             |            |        |        |       |
 12 |      0 |        0 |      0 |        |        |          |        |             |            |        |        |       |
(12 rows)
**************************************************************
最多167行，然后再查看其他block number  'idx_t3_t',1,2,3,4。。。。。。
postgres=# select * from heap_page_items(get_raw_page('t3',49)) limit 10 offset 110;
 lp  | lp_off | lp_flags | lp_len | t_xmin | t_xmax | t_field3 |  t_ctid  | t_infomask2 | t_infomask | t_hoff | t_bits | t_oid |                 t_data
-----+--------+----------+--------+--------+--------+----------+----------+-------------+------------+--------+--------+-------+----------------------------------------
 111 |   3184 |        1 |     42 |    582 |      0 |        0 | (49,111) |           2 |       2306 |     24 |        |       | \xd22000001d52616e6479204b6569736c6572
 112 |   3144 |        1 |     40 |    582 |      0 |        0 | (49,112) |           2 |       2306 |     24 |        |       | \xd3200000194a6f7368204b696e6e6579
(2 rows)                                                          这里表示第50个块的第112个tuple
postgres=# select * from page_header(get_raw_page('t3',19));
    lsn    | checksum | flags | lower | upper | special | pagesize | version | prune_xid
-----------+----------+-------+-------+-------+---------+----------+---------+-----------
 1/3C420B0 |        0 |     4 |   688 |   704 |    8192 |     8192 |       4 |         0
                                  688-704 这里没有空间了
**************************************************************
postgres=# select * from heap_page_items(get_raw_page('t3',50));
ERROR:  block number 50 is out of range for relation "t3"

postgres=# select * from page_header(get_raw_page('idx_t3_t',0));
    lsn    | checksum | flags | lower | upper | special | pagesize | version | prune_xid
-----------+----------+-------+-------+-------+---------+----------+---------+-----------
 0/C0284A0 |        0 |     0 |    72 |  8176 |    8176 |     8192 |       4 |         0
(1 row)

## pg_resetwal 利用MVCC多版本原理，篡改下一个事务号找回刚刚删除的数据
postgres=# select xmin,xmax,id from t1;
 xmin | xmax | id
------+------+----
  497 |    0 |  1
  497 |    0 |  2
  497 |    0 |  3
  498 |    0 |  4
  499 |    0 |  5
(5 rows)

postgres=# delete from t1 where id=4;
DELETE 1
postgres=# select * from heap_page_items(get_raw_page('t1','main',0));
 lp | lp_off | lp_flags | lp_len | t_xmin | t_xmax | t_field3 | t_ctid | t_infomask2 | t_infomask | t_hoff | t_bits | t_oid |     t_data
----+--------+----------+--------+--------+--------+----------+--------+-------------+------------+--------+--------+-------+----------------
  1 |   8160 |        1 |     30 |    497 |      0 |        0 | (0,1)  |           2 |       2306 |     24 |        |       | \x010000000561
  2 |   8128 |        1 |     30 |    497 |      0 |        0 | (0,2)  |           2 |       2306 |     24 |        |       | \x020000000562
  3 |   8096 |        1 |     30 |    497 |      0 |        0 | (0,3)  |           2 |       2306 |     24 |        |       | \x030000000563
  4 |   8064 |        1 |     30 |    498 |    500 |        0 | (0,4)  |        8194 |        258 |     24 |        |       | \x040000000564
  5 |   8032 |        1 |     30 |    499 |      0 |        0 | (0,5)  |           2 |       2306 |     24 |        |       | \x050000000565
(5 rows)

postgres=# select xmin,xmax,id from t1;
 xmin | xmax | id
------+------+----
  497 |    0 |  1
  497 |    0 |  2
  497 |    0 |  3
  499 |    0 |  5

postgres=# select * from t1;
 id | info
----+------
  1 | a
  2 | b
  3 | c
(3 rows)

postgres=# \q
postgres@u2004:~$ logout
root@u2004:~# systemctl stop postgresql
root@u2004:~# su - postgres
postgres@u2004:~$ /usr/lib/postgresql/12/bin/pg_resetwal -x 499 -D /var/lib/postgresql/12/main/
Write-ahead log reset
postgres@u2004:~$ logout
root@u2004:~# systemctl start postgresql
root@u2004:~# su - postgres
postgres@u2004:~$ psql
psql (12.8 (Ubuntu 12.8-0ubuntu0.20.04.1))
Type "help" for help.

postgres=# select * from t1;
 id | info
----+------
  1 | a
  2 | b
  3 | c
  4 | d

postgres=# select xmin,xmax,id from t1;
 xmin | xmax | id
------+------+----
  497 |    0 |  1
  497 |    0 |  2
  497 |    0 |  3
  498 |  500 |  4

root@u2004:~# systemctl stop postgresql
root@u2004:~# su - postgres
postgres@u2004:~$ /usr/lib/postgresql/12/bin/pg_resetwal -x 500 -D /var/lib/postgresql/12/main/
Write-ahead log reset
postgres@u2004:~$ logout
root@u2004:~# systemctl start postgresql
root@u2004:~# su - postgres
postgres@u2004:~$ psql
psql (12.8 (Ubuntu 12.8-0ubuntu0.20.04.1))
Type "help" for help.

postgres=# select * from t1;
 id | info
----+------
  1 | a
  2 | b
  3 | c
  4 | d
  5 | e
(5 rows)

postgres=# select xmin,xmax,id from t1;
 xmin | xmax | id
------+------+----
  497 |    0 |  1
  497 |    0 |  2
  497 |    0 |  3
  498 |  500 |  4
  499 |    0 |  5
(5 rows)

# pg_filedump查看datafile
安装
[root@postgres-1 ~]# yum install pg_filedump_13
-bash-4.2$ pg_filedump 16521

*******************************************************************
* PostgreSQL File/Block Formatted Dump Utility
*
* File: 16521
* Options used: None
*******************************************************************
Flags有unused, normal       normal的才有内容
Block    0 ********************************************************
<Header> -----
 Block Offset: 0x00000000         Offsets: Lower     424 (0x01a8)
 Block: Size 8192  Version    4            Upper    8192 (0x2000)
 LSN:  logid      1 recoff 0x03a7da80      Special  8192 (0x2000)
 Items:  100                      Free Space: 7768
 Checksum: 0x0000  Prune XID: 0x00000000  Flags: 0x0005 (HAS_FREE_LINES|ALL_VISIBLE)
 Length (including item array): 424

<Data> -----
 Item   1 -- Length:    0  Offset:    0 (0x0000)  Flags: UNUSED
 Item   2 -- Length:    0  Offset:    0 (0x0000)  Flags: UNUSED
 Item   3 -- Length:    0  Offset:    0 (0x0000)  Flags: UNUSED
 Item   4 -- Length:    0  Offset:    0 (0x0000)  Flags: UNUSED
 Item   5 -- Length:    0  Offset:    0 (0x0000)  Flags: UNUSED
 Item   6 -- Length:    0  Offset:    0 (0x0000)  Flags: UNUSED

-bash-4.2$  pg_filedump -f 16521      # 可查看行的内容
Block    9 ********************************************************
<Header> -----
 Block Offset: 0x00012000         Offsets: Lower     428 (0x01ac)
 Block: Size 8192  Version    4            Upper    7752 (0x1e48)
 LSN:  logid      1 recoff 0x03a80ef0      Special  8192 (0x2000)
 Items:  101                      Free Space: 7324
 Checksum: 0x0000  Prune XID: 0x00000000  Flags: 0x0005 (HAS_FREE_LINES|ALL_VISIBLE)
 Length (including item array): 428
             
  Item  93 -- Length:    0  Offset:    0 (0x0000)  Flags: UNUSED
 Item  94 -- Length:    0  Offset:    0 (0x0000)  Flags: UNUSED
 Item  95 -- Length:    0  Offset:    0 (0x0000)  Flags: UNUSED
 Item  96 -- Length:   67  Offset: 8120 (0x1fb8)  Flags: NORMAL
  1fb8: 26020000 00000000 00000000 00000900  &...............
  1fc8: 60000600 02091800 1d416461 6d20446f  `........Adam Do
  1fd8: 6e616368 69650b20 42414c13 20436174  nachie. BAL. Cat
  1fe8: 63686572 4a000000 b4000000 0f008116  cherJ...........
  1ff8: 00ac26                               ..&

 Item  97 -- Length:   63  Offset: 8056 (0x1f78)  Flags: NORMAL
  1f78: 26020000 00000000 00000000 00000900  &...............
  1f88: 61000600 02091800 15506175 6c204261  a........Paul Ba
  1f98: 6b6f0b20 42414c13 20436174 63686572  ko. BAL. Catcher
  1fa8: 4a000000 d7000000 0f008122 00f41a    J.........."...
postgres=# select * from staff where ctid='(9,96)';
     name      | team | position | height | weight |  age
---------------+------+----------+--------+--------+-------
 Adam Donachie |  BAL |  Catcher |     74 |    180 | 22.99
(1 row)
可以发现staff表的第一行数据在page9,item96       很奇怪，别的表没有出现这个情况，第一个page就有数据

用-D  加上数据类型去decode行
-bash-4.2$ pg_filedump -D text,text,text,int,int,float 16521
Error: unable to decode a tuple, callback #6 returned -2. Partial data: Adam Donachie    BAL     Catcher        74      180
 Item  97 -- Length:   63  Offset: 8056 (0x1f78)  Flags: NORMAL
Error: unable to decode a tuple, callback #6 returned -2. Partial data: Paul Bako        BAL     Catcher        74      215
 Item  98 -- Length:   71  Offset: 7984 (0x1f30)  Flags: NORMAL

 
##### TOAST ######  行外存储
It stands for The Oversized-Attribute Storage Technique
The mechanism is accomplished by splitting up the large column entry into 2KB bytes and storing them as chunks in the TOAST tables. 
It then stores the length and a pointer to the TOAST entry back where the column is normally stored. Because of how the pointer system is implemented,
 most TOAST'able column types are limited to a max size of 1GB.

只有特定的数据类型支持TOAST，因为那些整数、浮点数等不太长的数据类型是没有必要使用TOAST的。
另外，支持TOAST的数据类型必须是变长的。在变长类型中：
前4字节（32bit）称为长度字，长度字后面存储具体的内容或一个指针。
长度字的高2bit位是标志位，后面的30bit是长度值（表示值的总长度，包括长度字本身，以字节计）。
由长度值可知TOAST数据类型的逻辑长度最多是30bit，即1GB(2^30-1字节）之内。
前2bit的标志位，一个表示压缩标志位，一个表示是否行外存储，如果两个都是零，那么表示既未压缩也未行外存储。
如果设置了压缩标志标志位，表示该数值被压缩过（使用的是非常简单且快速的LZ压缩方法），使用前必须先解压缩。
如果设置了行外存储标志位，则表示该数值是在行外存储的。此时，长度字后面的部分只是一个指针，指向存储实际数据的TOAST表中的位置。如果两个标志位都设置了，那么这个行外数据也会被压缩。
不管是哪种情况，长度字里剩下的30bit的长度值都表示数据的实际尺寸，而不是压缩后的长度。

在 PG 中每个表字段有四种 TOAST 的策略：
PLAIN —— 避免压缩和行外存储。只有那些不需要 TOAST 策略就能存放的数据类型允许选择（例如 int 类型），而对于 text 这类要求存储长度超过页大小的类型，是不允许采用此策略的。
EXTENDED —— 允许压缩和行外存储。一般会先压缩，如果还是太大，就会行外存储。这是大多数可以TOAST的数据类型的默认策略。
EXTERNAL —— 允许行外存储，但不许压缩。这让在text类型和bytea类型字段上的子串操作更快。类似字符串这种会对数据的一部分进行操作的字段，采用此策略可能获得更高的性能，因为不需要读取出整行数据再解压。
MAIN —— 允许压缩，但不许行外存储。不过实际上，为了保证过大数据的存储，行外存储在其它方式（例如压缩）都无法满足需求的情况下，作为最后手段还是会被启动。因此理解为：尽量不使用行外存储更贴切。 
行外存储被切成了多个Chunk块，每个Chunk块大约是一个BLOCK的四分之一大小，如果块大小为8KB（默认就是8KB），则Chunk大约为2KB（比2KB略小一点），每个Chunk都作为独立的行存储在TOAST表中。

TOAST表有三个字段：
chunk_id —— 用来表示特定 TOAST 值的 OID ，可以理解为具有同样 chunk_id 值的所有行组成原表（这里的 blog ）的 TOAST 字段的一行数据。
chunk_seq —— 用来表示该行数据在整个数据中的位置。
chunk_data —— 该Chunk实际的数据。 
查找实际的toast表和它的数据
postgres=# select relname,relfilenode,reltoastrelid from pg_class where relname='facts';
 relname | relfilenode | reltoastrelid
---------+-------------+---------------
 facts   |       16462 |         16466
(1 row)

postgres=# \d+ pg_toast.pg_toast_16462
TOAST table "pg_toast.pg_toast_16462"
   Column   |  Type   | Storage
------------+---------+---------
 chunk_id   | oid     | plain
 chunk_seq  | integer | plain
 chunk_data | bytea   | plain
Owning table: "public.facts"
Indexes:
    "pg_toast_16462_index" PRIMARY KEY, btree (chunk_id, chunk_seq)
Access method: heap
facts表json类型data字段的长度
postgres=# select id,key,pg_column_size(data) from facts;
 id |           key           | pg_column_size
----+-------------------------+----------------
  1 | ansible_facts10.21.0.14 |          18038
可以发现data被分为10个chunk,每个chunk为1996 byte
postgres=# select chunk_id,chunk_seq,length(chunk_data) from pg_toast.pg_toast_16462;
 chunk_id | chunk_seq | length
----------+-----------+--------
    16471 |         0 |   1996      略小于2k
    16471 |         1 |   1996
    16471 |         2 |   1996
    16471 |         3 |   1996
    16471 |         4 |   1996
    16471 |         5 |   1996
    16471 |         6 |   1996
    16471 |         7 |   1996
    16471 |         8 |   1996
    16471 |         9 |     74
postgres=# select * from pg_toast.pg_toast_16462;
 chunk_id | chunk_seq | chunk_data
    16471 |         0 | \xc4ca010000227b5c6e20202020005c22616e73........... 
	16471 |         1 | \xbf02c40ffe16bf12ff0f2b013fbf12030f320b...........
	.................
    16471 |         9 | \x0f28026c04616e94c93130332c312030312c31...........	
(10 rows)	
修改TOAST策略
alter table blog alter content set storage external/extended;

######### WAL ###########
•WAL –Write Ahead Log. It is used in context of transaction log files.
•Xlog  -Transaction log. It is used in context of transaction log  buffers.
•LSN –Log sequence number. It is used to mark position of log in  pages. 
•Bgwriter –Background writer.This is used to flush shared buffers  and perform checkpoint. 
•Clog  -Commit log. It is used in context of transaction status buffers.
•Partial Page Write –This happens when OS is able to write partial page in disk files which can cause corruption.

The transaction log files are stored in $PGDATA/pg_wal directory. They are named as 000000010000070A0000008E. 
  -The first 8 digits identifies the timeline, 
  -The following 8 digits identifies the (logical) xlog file and      
  -The last ones represents the (physical) xlog file (Segement) 
The physical files in pg_xlog directory are not actually the xlog files; PostgreSQL calls it segments. 
Each Segment contains Bocks of 8K and Segment size is 16M
Block 0     1.Seg Hdr 2.Block Header 3.WAL Records Each WAL record has header. WAL 1, 2 ,3
Block 1     1. Block Header 2. WAL Records 3. Each WAL record has header. WAL 4,5
Block 2     1. Block Header 2. WAL Records 3. Each WAL record has header. WAL 5,6,7,8
…
Block 255   1. Block Header 2. WAL Records 3. Each WAL record has header. WAL m,n,…

switch wal之后, segment 号 加 1
-rw-------. 1 postgres postgres 16M Sep 13 02:43 0000000100000001000000A2
postgres=# select pg_switch_wal();
-[ RECORD 1 ]-+-----------
pg_switch_wal | 1/A21613D8
-rw-------. 1 postgres postgres 16M Sep 13 03:10 0000000100000001000000A3

postgres=# select * from pg_control_checkpoint();
-[ RECORD 1 ]--------+-------------------------
checkpoint_lsn       | 1/A2161310
redo_lsn             | 1/A21612D8
redo_wal_file        | 0000000100000001000000A2
timeline_id          | 1
prev_timeline_id     | 1
full_page_writes     | t
next_xid             | 0:591
next_oid             | 24700
next_multixact_id    | 1
next_multi_offset    | 0
oldest_xid           | 479
oldest_xid_dbid      | 1
oldest_active_xid    | 591
oldest_multi_xid     | 1
oldest_multi_dbid    | 1
oldest_commit_ts_xid | 0
newest_commit_ts_xid | 0
checkpoint_time      | 2021-09-13 02:58:38+00

WALInsertLock •This lock is used to insert transaction log record contents into transaction log memory buffer
WALWriteLock •This lock is used to write transaction log buffer data to WAL file

postgres=# select * from  pg_current_wal_insert_lsn();
-[ RECORD 1 ]-------------+-----------
pg_current_wal_insert_lsn | 1/A21613C0

postgres=# select * from  pg_current_wal_flush_lsn();
-[ RECORD 1 ]------------+-----------
pg_current_wal_flush_lsn | 1/A21613C0

postgres=# select txid_current();
-[ RECORD 1 ]+----
txid_current | 590

postgres=# select txid_status(10109);  通过txid得到事务的提交状态
 txid_status
-------------
 committed
(1 row)


postgres=# select pg_current_wal_lsn();
 pg_current_wal_lsn
--------------------
 3/89E12DB8
(1 row)
LSN在wal日志中的偏移量即LSN低32位中后24位对应的十进制值。
postgres=# select x'E12DB8'::int as offset,pg_walfile_name_offset(pg_current_wal_lsn());
  offset  |       pg_walfile_name_offset
----------+-------------------------------------
 14757304 | (000000010000000300000089,14757304)
(1 row)    
 # 通过lsn计算出的偏移量与pg_walfile_name_offset结果一致



000000010000000300000089 walfile文件名组成
00000001 timeline ID
00000003 LogID
00000089 LogSeq

WAL segment file name=timelineId + (uint32)(LSN−1)/16M*256 +(uint32)(LSN−1/16M)%256


lsn获取 
注意转换公式中LSN为十进制，而pg_current_wal_lsn()得到的值是十六进制，需要进行转换
postgres=# select pg_current_wal_lsn();
 pg_current_wal_lsn
--------------------
 3/89B3ED00
(1 row)
***此处3代表walfile的第二部分,logid***
***89代表walfile的后两位***
*** B3ED00代表偏移量***

postgres=# select x'389E12DB8'::bigint;   转成十进制
    int8
-------------
 15198137784
(1 row)


logid
LSN / 左边的数字
postgres=# select ((15198137784 -1)/ (16::bigint * 1024::bigint * 1024::bigint * 256::bigint) ::int8);
 ?column?
----------
        3               #与walfile第二部分logid一致
(1 row)

logseq获取  套用公式：(uint32)LSN−1 / (16M ∗ 256)
postgres=# select ((15198137784-1)/(16 * 1024 * 1024)) % 256;
 ?column?
----------
      137
(1 row)


postgres=# select to_hex(137);
 to_hex
--------
 89
(1 row)

postgres=# select pg_walfile_name(pg_current_wal_lsn());
     pg_walfile_name
--------------------------
 000000010000000300000089         与上面验证的89一致
(1 row)


xid和txid的区别
xid是32位的整型，会被FREEZE，循环使用，xmin,xmax都是XID类型。通过xid可以得到事务结束时间。

txid是64位整型，不会被循环使用，通过epoch可以从xid转换为txid。通过txid可以得到事务的提交状态。

全页写
PG数据页写入是以page为单位，每个page默认大小为8K，而操作系统数据块是4K（操作系统每次写入4k），在断电等情况下，极有可能部分pg数据页只写到4K系统就已经崩溃。
此时pg数据页中就一半是新写入的数据，一半是还没来得及写入的旧数据，这称为部分写问题。这种数据页可以看作是损坏的，在崩溃恢复时，由于XLOG记录无法在损坏的页面上重放，
它无法完全恢复该页。因此，我们需要一个额外附加的功能。

pg支持一种称为全页写的功能来处理部分写问题。如果启用（默认启用），pg会在每个检查点之后、每个页面第一次发生变更时，将头数据和整个页面作为一条XLOG记录写入WAL缓冲区。
在pg中，这种包含整个页面的XLOG记录称为备份块或全页镜像 (backup block or full-page image)。

查看wal日志
-bash-4.2$ pg_controldata
pg_control version number:            1300
Catalog version number:               202007201
Database system identifier:           6984324583401825557
Database cluster state:               in production
pg_control last modified:             Mon 13 Sep 2021 03:13:38 AM UTC
Latest checkpoint location:           1/A3000098
Latest checkpoint's REDO location:    1/A3000060

-bash-4.2$ pg_waldump -p ./ -s 1/A3000060
rmgr: Standby     len (rec/tot):     50/    50, tx:          0, lsn: 1/A3000060, prev 1/A3000028, desc: RUNNING_XACTS nextXid 591 latestCompletedXid 590 oldestRunningXid 591
rmgr: XLOG        len (rec/tot):    114/   114, tx:          0, lsn: 1/A3000098, prev 1/A3000060, desc: CHECKPOINT_ONLINE redo 1/A3000060; tli 1; prev tli 1; fpw true; xid 0:591; oid 24700; multi 1; offset 0; oldest xid 479 in DB 1; oldest multi 1 in DB 1; oldest/newest commit timestamp xid: 0/0; oldest running xid 591; online
rmgr: Standby     len (rec/tot):     50/    50, tx:          0, lsn: 1/A3000110, prev 1/A3000098, desc: RUNNING_XACTS nextXid 591 latestCompletedXid 590 oldestRunningXid 591
rmgr: Heap        len (rec/tot):     54/   362, tx:        591, lsn: 1/A3000148, prev 1/A3000110, desc: INSERT off 5 flags 0x00, blkref #0: rel 1663/14172/16472 blk 0 FPW
rmgr: Transaction len (rec/tot):     34/    34, tx:        591, lsn: 1/A30002B8, prev 1/A3000148, desc: COMMIT 2021-09-14 05:12:20.545562 UTC
rmgr: Standby     len (rec/tot):     50/    50, tx:          0, lsn: 1/A30002E0, prev 1/A30002B8, desc: RUNNING_XACTS nextXid 592 latestCompletedXid 591 oldestRunningXid 592

-bash-4.2$ pg_waldump 0000000100000001000000A3 --r heap      增删改
rmgr: Heap        len (rec/tot):     54/   362, tx:        591, lsn: 1/A3000148, prev 1/A3000110, desc: INSERT off 5 flags 0x00, blkref #0: rel 1663/14172/16472 blk 0 FPW
rmgr: Heap        len (rec/tot):     54/   422, tx:        592, lsn: 1/A3000400, prev 1/A30003C8, desc: INSERT off 6 flags 0x00, blkref #0: rel 1663/14172/16472 blk 0 FPW
rmgr: Heap        len (rec/tot):     93/    93, tx:        593, lsn: 1/A3000608, prev 1/A30005D0, desc: INSERT off 7 flags 0x00, blkref #0: rel 1663/14172/16472 blk 0
rmgr: Heap        len (rec/tot):     78/    78, tx:        594, lsn: 1/A30006C8, prev 1/A3000690, desc: HOT_UPDATE off 4 xmax 594 flags 0x60 ; new off 8 xmax 0, blkref #0: rel 1663/14172/16472 blk 0
rmgr: Heap        len (rec/tot):     54/    54, tx:        595, lsn: 1/A3000778, prev 1/A3000740, desc: DELETE off 5 flags 0x00 KEYS_UPDATED , blkref #0: rel 1663/14172/16472 blk 0

以ready結尾的，表示可以歸檔但還沒有歸檔，done結尾的表示已經歸檔
7  .ready
.ready是同名wal段文件在archive_status目錄內的標記文件，代表該wal段文件可被歸檔。wal段文件在數據目錄中的存儲文件數量是有上限的，一般通過wal_keep_segments參數來約束，
因此數據庫引擎在wal段文件個數達到上限後會在archive_status目錄內增加可移除的wal段文件的標記文件，文件名是原wal段文件名後增加.ready後綴，等待歸檔工具進行歸檔。

8  .done
.done是同名wal段文件在archive_status目錄內的標記文件，代表該wal段文件已被歸檔，可以被清理。數據庫引擎默認通過archive_command命令對.ready文件進行歸檔，
歸檔成功與否取決於archive_command命令返回true還是false，當archive_command返回true時，代表與.ready文件同名的wal段文件已被歸檔，引擎再將該文件的擴展名重命名為.done，
等待數據庫引擎在下一次的checkpoint時進一步清理原wal段文件。

PG的归档很灵活，archive_command指定外部shell命令来进行归档。首先来看WAL归档如何初始化。通常情况下，归档的事件链从WAL写开始XLogWrite()。
当写满一个WAL段文件，通过向archive_status目录插入一个.ready文件来通知归档进程需要处理这个段文件了（XLogArchiveNotifySeg->XLogArchiveNotify）。
例如，如果0000000100000001000000C6文件需要归档，那么.ready文件为0000000100000001000000C6.ready。这个.ready文件作为归档进程的通知文件。
创建这个文件的同时，也会向归档进程发起一个信号来唤醒它。此时归档进程唤醒了开始处理所有.ready文件。

#archive_command失败的问题 2021-11-1  
-bash-4.2$ tail -f ../../log/postgresql-Mon.log
2021-11-01 03:14:11.959 UTC [29822] LOG:  archive command failed with exit code 1
2021-11-01 03:14:11.959 UTC [29822] DETAIL:  The failed archive command was: test ! -f /opt/archivedir/0000000100000003000000EA && cp pg_wal/0000000100000003000000EA /opt/archivedir/0000000100000003000000EA
postgres-1机器里archive_status目录中.backup和.ready文件同时存在
-rw-------. 1 postgres postgres 0 10月 30 21:40 0000000100000003000000EA.done
-rw-------. 1 postgres postgres 0 10月 30 21:40 0000000100000003000000EA.ready
-rw-------. 1 postgres postgres 0 11月  1 01:27 0000000100000003000000EB.ready
-rw-------. 1 postgres postgres 0 11月  1 01:27 0000000100000003000000EC.ready
-rw-------. 1 postgres postgres 0 11月  1 01:40 0000000100000003000000ED.ready
-rw-------. 1 postgres postgres 0 11月  1 01:43 0000000100000003000000EE.ready
-rw-------. 1 postgres postgres 0 11月  1 02:40 0000000100000003000000EF.ready
-rw-------. 1 postgres postgres 0 11月  1 03:01 0000000100000003000000F0.ready
解决步骤：
验证了test ! -f /opt/archivedir/0000000100000003000000EA, 发现/opt/archivedir/0000000100000003000000EA存在/opt/archivedir目录中，所以后续cp命令不会执行
删除该文件后，一切正常

# max_wal_size参数没有起作用
-bash-4.2$ du -sh pg_wal
1.7G    pg_wal
-bash-4.2$ grep 1G postgresql.conf
max_wal_size = 1GB


######## FSM ########
VACUUM performs processing while referring to the Visibility Map, and updates the Free Space Map
Free Space Map stores information about free space in a relation
• Used by INSERTs and UPDATEs
FSM的空间管理中，没有细粒度到数据页的每个比特，而是将最小单元定义为页大小（BLCKSZ）的256分之一，也就是说，
在默认8KB数据页的大小下，从FSM的角度观察，它有256个单元。所以，为了表述这个256个单元的状态，FSM为每个数据页分配了一个字节的空间。这也是FSM在设计时，一个空间和时间的折中选择
https://www.bookstack.cn/read/aliyun-rds-core/2470b8d6a68945ba.md
postgres=# create extension pg_freespacemap;
CREATE EXTENSION
postgres=# select * from pg_freespace('staff');
 blkno | avail
-------+-------
     0 |  7744
     1 |  7744
     2 |  7744
     3 |  7744
     4 |  7744
     5 |  7744
     6 |  7744
     7 |  7744
     8 |  7744
     9 |  7296
    10 |    32
    11 |    32
    12 |     0
    13 |    96
    14 |     0
    15 |    64
    16 |    32
    17 |    64
    18 |    32
    19 |    96
    20 |  6400
postgres=# select * from staff where ctid='(9,96)';
     name      | team | position | height | weight |  age
---------------+------+----------+--------+--------+-------
 Adam Donachie |  BAL |  Catcher |     74 |    180 | 22.99
(1 row)
可以发现staff表的第一行数据在page9,item96

######## VM ########
Visibility Map  跟vacuum密切相关
• A bitmap of heap pages
• 1 means “all tuples on page are visible to all transactions”
• Bits are set in VACUUM
• Cleared at INSERT/UPDATE/DELETE
VACUUM can now skip pages that are already marked in visibility map
• Still needs to scan all indexes
http://www.postgres.cn/v2/news/viewone/1/525
pg的冻结炸弹，事务号回卷会导致刚创建的元组不可见
postgresql数据库使用32位事务号，最大容纳42亿左右的事务号，事务号是循环使用的，当事务号耗尽后又会从3开始循环使用。事务环被分为两个半圆，
当前事务号过去的21亿事务属于过去的事务号，当前事务号往前的21亿属于未来的事务号，未来的事务号对当前事务是不可见的。

当数据页中的所有记录已经是FROZEN状态时，在发起vacuum freeze时会跳过这个页的扫描，从而大幅提升静态数据的freeze操作，减少IO扫描。
目前这个page frozen标记放在表对应的VM文件中
postgres=# create extension pg_visibility;
CREATE EXTENSION
postgres=# select * from pg_visibility_map_summary('t4');
 all_visible | all_frozen
-------------+------------
      318472 |          0
(1 row)
第一次freeze很耗时间，没有frozen page
postgres=# vacuum freeze verbose t4;
INFO:  aggressively vacuuming "public.t4"
INFO:  "t4": found 0 removable, 50000000 nonremovable row versions in 318472 out of 318472 pages
DETAIL:  0 dead row versions cannot be removed yet, oldest xmin: 587
There were 0 unused item identifiers.
Skipped 0 pages due to buffer pins, 0 frozen pages.
0 pages are entirely empty.
CPU: user: 7.76 s, system: 6.71 s, elapsed: 180.29 s.

postgres=# select * from pg_visibility_map_summary('t4');
 all_visible | all_frozen
-------------+------------
      318472 |     318472

第二次freeze立即结束，因为跳过了318471个frozen pages。vm文件记录了frozen page标志位
postgres=# vacuum freeze verbose t4;
INFO:  aggressively vacuuming "public.t4"
INFO:  "t4": found 0 removable, 53 nonremovable row versions in 1 out of 318472 pages
DETAIL:  0 dead row versions cannot be removed yet, oldest xmin: 587
There were 0 unused item identifiers.
Skipped 0 pages due to buffer pins, 318471 frozen pages.
0 pages are entirely empty.
CPU: user: 0.00 s, system: 0.00 s, elapsed: 0.00 s.

查看详细
postgres=# select * from pg_visibility_map('t4');
 blkno  | all_visible | all_frozen
--------+-------------+------------
      0 | t           | t
      1 | t           | t
      2 | t           | t
      3 | t           | t
      4 | t           | t
	  
###	pg_control  ###
用命令读pg_control
-bash-4.2$ pg_controldata
pg_control version number:            1300
Catalog version number:               202007201
Database system identifier:           6984324583401825557
Database cluster state:               in production
pg_control last modified:             Sat 11 Sep 2021 06:39:13 AM UTC
Latest checkpoint location:           1/A2160AD8
Latest checkpoint's REDO location:    1/A2160AA0
Latest checkpoint's REDO WAL file:    0000000100000001000000A2

通过system identifier计算数据库什么时候创建的
postgres=# select to_timestamp(((6984324583401825557>>32) & (2^32-1)::bigint));
      to_timestamp
------------------------
 2021-07-13 08:26:28+00
(1 row)

用以下几个函数获取control的内容
https://www.postgresql.org/docs/current/functions-info.html#FUNCTIONS-CONTROLDATA

postgres=# select * from pg_control_system();
-[ RECORD 1 ]------------+-----------------------
pg_control_version       | 1300
catalog_version_no       | 202007201
system_identifier        | 6984324583401825557
pg_control_last_modified | 2021-09-11 06:39:13+00

postgres=# select * from pg_control_checkpoint();
-[ RECORD 1 ]--------+-------------------------
checkpoint_lsn       | 1/A2160AD8
redo_lsn             | 1/A2160AA0
redo_wal_file        | 0000000100000001000000A2
......

postgres=# select * from pg_control_init();
-[ RECORD 1 ]--------------+---------
max_data_alignment         | 8
database_block_size        | 8192
blocks_per_segment         | 131072
wal_block_size             | 8192
bytes_per_wal_segment      | 16777216
max_identifier_length      | 64
max_index_columns          | 32
max_toast_chunk_size       | 1996
large_object_chunk_size    | 2048
float8_pass_by_value       | t
data_page_checksum_version | 0

postgres=# select * from pg_control_recovery();
-[ RECORD 1 ]-----------------+----
min_recovery_end_lsn          | 0/0
min_recovery_end_timeline     | 0
backup_start_lsn              | 0/0
backup_end_lsn                | 0/0
end_of_backup_record_required | f

$ pg_resetwal -D /var/lib/pgsql/node_1/data/ --dry-run
Current pg_control values:

# Restoring pg_control
In the unlikely event pg_control becomes corrupted, it might be possible to restore it using pg_resetwal
pg_control version number:            1300
Catalog version number:               202108031
Database system identifier:           6998038587784135836
Latest checkpoint's TimeLineID:       1
Latest checkpoint's full_page_writes: on
Latest checkpoint's NextXID:          0:709

MVCC的是实现方式大概有两种，关键就在于将旧数据放在什么地方；

  	1. 将多版本的记录都存储在数据库中，垃圾收集器清理不需要的记录。比如：PostgreSQL/Firebird/Interbase ，而SQL Server将其存储在tempdb中。
  	2. 将最新的记录放在数据库中，通过恢复undo日志，来重建旧版本的数据。比如Oracle、MySQL(innodb)。
######### 数据类型 ###########
# 日期时间类型
postgres=# show datestyle;
 DateStyle
-----------
 ISO, MDY
postgres=# select now();
              now
-------------------------------
 2021-09-04 05:43:17.282491+00
postgres=# set datestyle='SQL,DMY';
SET
postgres=# select now();
              now
--------------------------------
 04/09/2021 05:45:00.682158 UTC

postgres=# show intervalstyle;
 IntervalStyle
---------------
 postgres
 
postgres=# select interval '1 year 2mons';
   interval
---------------
 1 year 2 mons
(1 row)

postgres=# set intervalstyle='sql_standard';
SET
postgres=# select interval '1 year 2mons';
 interval
----------
 1-2

postgres=# show lc_monetary;
 lc_monetary
-------------
 en_US.UTF-8
(1 row)

postgres=# select '12.33'::money;
 money
--------
 $12.33
(1 row)

# money类型
postgres=# set lc_monetary='zh_CN';
SET
postgres=# select '12.33'::money;
  money
---------
 ￥12.33
(1 row)

# 自增数据类型 serial
postgres=# create table t2(id serial not null,name text);
CREATE TABLE

# 数据类型 enum
create type color_t as enum('blue', 'red', 'gray', 'black');

drop table if exists cars;

create table cars (
  brand text
, model text
, color color_t
);

insert into cars(brand, model, color) values 
('ferari', 'testarosa', 'red'),
('aston martin', 'db2', 'blue'),
('bentley', 'mulsanne', 'gray'),
('ford', 'T', 'black');

# 数据类型domain
接著來看一個 Create Domain 的例子,為了與 Oracle Date 資料型態相容.
CREATE DOMAIN tdate
    AS timestamp(0) without time zone;

使用了基本資料型態 timestamp(0) without time zone

在psql 使用 \dD ,可以列出現在Database 的 自定義 Domain

List of domains
+-[ RECORD 1 ]-------------------------------+
| Schema    | miku                           |
| Name      | tdate                          |
| Type      | timestamp(0) without time zone |
| Collation |                                |
| Nullable  |                                |
| Default   |                                |
| Check     |                                |
+-----------+--------------------------------+

這樣就能很容易了解到 定義 Domain 是基於其他基本資料型態,可以定義新的 Collation , 
這樣我們就能指定 Collation 方便排序使用.
還有指定 Nullable , Default, 還有建立前面提到過的 Check 運算式.

create domain 是 ANSI SQL 標準.
有了 domain, 我們可以很方便的定義 domain specific type, 讓我們開發系統時,
有符合領域特性的 type system.

接著我們來看實例

create domain md5 as
text not null
check (
    length(value) = 32
);

create table ithelp191002 (
  fname text
, checksum md5
);

insert into ithelp191002 values
('passwd', 'abcd123xxx');

ERROR:  23514: value for domain md5 violates check constraint "md5_check"
SCHEMA NAME:  miku
DATATYPE NAME:  md5
CONSTRAINT NAME:  md5_check

回報錯誤了...

insert into ithelp191002 values
('passwd', '76a2173be6393254e72ffa4d6df1030a');

這樣就正確了.

# 生成列 由其他列计算而来
postgres=# create table tax1(salary numeric,taxindex numeric,tax numeric generated always as (salary*taxindex) stored);
CREATE TABLE
postgres=# insert into tax1 values(10000,0.13);
INSERT 0 1
postgres=# select * from tax1;
-[ RECORD 1 ]-----
salary   | 10000
taxindex | 0.13
tax      | 1300.00

# hstore类型
postgres=# CREATE TABLE books (
postgres(#    id serial primary key,
postgres(#    title VARCHAR (255),
postgres(#    attr hstore
postgres(# );
CREATE TABLE
postgres=# INSERT INTO books (title, attr)
postgres-# VALUES
postgres-#    (
postgres(#       'PostgreSQL Tutorial',
postgres(#       '"paperback" => "243",
postgres'#       "publisher" => "postgresqltutorial.com",
postgres'#       "language"  => "English",
postgres'#       "ISBN-13"   => "978-1449370000",
postgres'#        "weight"   => "11.2 ounces"'
postgres(#    );
INSERT 0 1
postgres=# INSERT INTO books (title, attr)
postgres-# VALUES
postgres-#    (
postgres(#       'PostgreSQL Cheat Sheet',
postgres(#       '
postgres'# "paperback" => "5",
postgres'# "publisher" => "postgresqltutorial.com",
postgres'# "language"  => "English",
postgres'# "ISBN-13"   => "978-1449370001",
postgres'# "weight"    => "1 ounces"'
postgres(#    );
INSERT 0 1
postgres=# select * from books;
 id |         title          |                                                                  attr
----+------------------------+----------------------------------------------------------------------------------------------------------------------------------------
  1 | PostgreSQL Tutorial    | "weight"=>"11.2 ounces", "ISBN-13"=>"978-1449370000", "language"=>"English", "paperback"=>"243", "publisher"=>"postgresqltutorial.com"
  2 | PostgreSQL Cheat Sheet | "weight"=>"1 ounces", "ISBN-13"=>"978-1449370001", "language"=>"English", "paperback"=>"5", "publisher"=>"postgresqltutorial.com"
(2 rows)

返回hstore列所有key
postgres=# select akeys(attr) from books;
                     akeys
-----------------------------------------------
 {weight,ISBN-13,language,paperback,publisher}
 {weight,ISBN-13,language,paperback,publisher}
(2 rows)
或者使用skeys()函数返回key集合：
postgres=# select skeys(attr) from books;
   skeys
-----------
 weight
 ISBN-13
 language
 paperback
 publisher
 weight
 ISBN-13
 language
 paperback
 publisher

返回hstore列所有value
postgres=# select avals(attr) from books;
或者使用svals()函数返回结果集：
postgres=# select svals(attr) from books;

转换hstore为json
postgres=# select title,hstore_to_json(attr) from books;
         title          |                                                              hstore_to_json
------------------------+------------------------------------------------------------------------------------------------------------------------------------------
 PostgreSQL Tutorial    | {"weight": "11.2 ounces", "ISBN-13": "978-1449370000", "language": "English", "paperback": "243", "publisher": "postgresqltutorial.com"}
 PostgreSQL Cheat Sheet | {"weight": "1 ounces", "ISBN-13": "978-1449370001", "language": "English", "paperback": "5", "publisher": "postgresqltutorial.com"}
(2 rows)

each函数转换hstore数据为结果集
postgres=# select title,(each(attr)).* from books;
         title          |    key    |         value
------------------------+-----------+------------------------
 PostgreSQL Tutorial    | weight    | 11.2 ounces
 PostgreSQL Tutorial    | ISBN-13   | 978-1449370000
 PostgreSQL Tutorial    | language  | English
 PostgreSQL Tutorial    | paperback | 243
 PostgreSQL Tutorial    | publisher | postgresqltutorial.com
 PostgreSQL Cheat Sheet | weight    | 1 ounces
 PostgreSQL Cheat Sheet | ISBN-13   | 978-1449370001
 PostgreSQL Cheat Sheet | language  | English
 PostgreSQL Cheat Sheet | paperback | 5
 PostgreSQL Cheat Sheet | publisher | postgresqltutorial.com

查询特定key的值
postgres=# select attr->'ISBN-13' AS isbn from books;
      isbn
----------------
 978-1449370000
 978-1449370001
(2 rows)
where子句
postgres=# SELECT
postgres-#    attr -> 'weight' AS weight
postgres-# FROM
postgres-#    books
postgres-# WHERE
postgres-#    attr -> 'ISBN-13' = '978-1449370000';
   weight
-------------
 11.2 ounces
(1 row)

增
UPDATE books
SET attr = attr || '"freeshipping"=>"yes"' :: hstore;
删
UPDATE books 
SET attr = delete(attr, 'freeshipping');
改
UPDATE books
SET attr = attr || '"freeshipping"=>"no"' :: hstore;

# 查询postgres 参数
postgres=# select * from pg_settings where name in ('wal_level','archive_mode','archive_command');

# 导出select查询
Either: 
 SELECT * FROM table \g filename
to just output to the file 'filename', or:
 select * from lineshoot \g |cat >> /solsolute/path/filename
to append to the file. Both in psql, or:
 echo 'SELECT * FROM table' | psql database >> test.out
from your terminal.

# recursive CTE
 with recursive t(n) as (
 values(1)                                     --非递归子句
 union all
 select n+1 from t where n<100)                --递归子句  t是temp working table
 select sum(n) from t;
 sum
------
 5050
(1 row)

# 显示所有的trigger
SELECT  event_object_table AS table_name ,trigger_name         
FROM information_schema.triggers  
GROUP BY table_name , trigger_name 
ORDER BY table_name ,trigger_name;

# 数据库之外创建用户和数据库
createuser --pwprompt zabbix
createdb -O zabbix -E Unicode -T template0 zabbix

\c dbname username  切换数据库或用户

# 创建用户和赋予用户对象权限
zabbix=# create user chensen with password 'chensen';

zabbix=# grant select on users to chensen;
GRANT
zabbix=# \dp+ users;
                               Access privileges
 Schema | Name  | Type  |   Access privileges   | Column privileges | Policies
--------+-------+-------+-----------------------+-------------------+----------
 public | users | table | zabbix=arwdDxt/zabbix+|                   |
        |       |       | chensen=r/zabbix      |                   |
(1 row)
zabbix=# grant update,insert,delete,truncate on users to chensen;
GRANT
zabbix=# \dp+ users;
                               Access privileges
 Schema | Name  | Type  |   Access privileges   | Column privileges | Policies
--------+-------+-------+-----------------------+-------------------+----------
 public | users | table | zabbix=arwdDxt/zabbix+|                   |
        |       |       | chensen=arwdD/zabbix  |                   |
(1 row)

postgres=# grant select on it1 to chensen with grant option;
GRANT
postgres=# \dp+ it1
                                Access privileges
 Schema | Name | Type  |     Access privileges     | Column privileges | Policies
--------+------+-------+---------------------------+-------------------+----------
 public | it1  | table | postgres=arwdDxt/postgres+|                   |
        |      |       | chensen=r*/postgres       |                   |
上面的r*代表 with grant option

# grant命令
GRANT on Roles (with admin option)     用於將角色加入成為其他角色的成員。如果指定了 WITH ADMIN OPTION，則該成員就可以將角色的成員資格再授予其他人
GRANT on Objects (with grant option)   对象权限

# 创建role时赋予权限
postgres=# create role cl LOGIN CREATEDB CREATEROLE PASSWORD 'cloverclock123' valid until '2021-09-28';
CREATE ROLE
postgres=# \du
                                      List of roles
  Role name  |                         Attributes                         |  Member of
-------------+------------------------------------------------------------+--------------
 chensen     |                                                            | {}
 cl          | Create role, Create DB                                    +| {}
             | Password valid until 2021-09-28 00:00:00+00                |
 postgres    | Superuser, Create role, Create DB, Replication, Bypass RLS | {}

# group role以及 grant grouprole to role
postgres=# create role dba CREATEDB CREATEROLE;
CREATE ROLE
postgres=# create role clm LOGIN PASSWORD 'clm123123';
CREATE ROLE
postgres=# \du
                                      List of roles
  Role name  |                         Attributes                         |  Member of
-------------+------------------------------------------------------------+--------------
 chensen     |                                                            | {}
 cl          | Create role, Create DB                                    +| {}
             | Password valid until 2021-09-28 00:00:00+00                |
 clm         |                                                            | {}
 dba         | Create role, Create DB, Cannot login                       | {}
 postgres    | Superuser, Create role, Create DB, Replication, Bypass RLS | {}
 repl        | Replication                                               +| {}
             | 30 connections                                             |
 sam         |                                                            | {}
 zbx_monitor |                                                            | {pg_monitor}

postgres=# grant dba to clm;
GRANT ROLE
postgres=# \du
                                      List of roles
  Role name  |                         Attributes                         |  Member of
-------------+------------------------------------------------------------+--------------
 chensen     |                                                            | {}
 cl          | Create role, Create DB                                    +| {}
             | Password valid until 2021-09-28 00:00:00+00                |
 clm         |                                                            | {dba}
 dba         | Create role, Create DB, Cannot login                       | {}
 postgres    | Superuser, Create role, Create DB, Replication, Bypass RLS | {}
 repl        | Replication                                               +| {}
             | 30 connections                                             |
 sam         |                                                            | {}
 zbx_monitor |                                                            | {pg_monitor}

postgres=# create role clm2 LOGIN PASSWORD 'clm123123';
CREATE ROLE
postgres=# grant dba to clm2 with admin option;
GRANT ROLE
postgres=# \du
                                      List of roles
  Role name  |                         Attributes                         |  Member of
-------------+------------------------------------------------------------+--------------
 chensen     |                                                            | {}
 cl          | Create role, Create DB                                    +| {}
             | Password valid until 2021-09-28 00:00:00+00                |
 clm         |                                                            | {dba}
 clm2        |                                                            | {dba}
 dba         | Create role, Create DB, Cannot login                       | {}
 postgres    | Superuser, Create role, Create DB, Replication, Bypass RLS | {}
 repl        | Replication                                               +| {}
             | 30 connections                                             |
 sam         |                                                            | {}
 zbx_monitor |                                                            | {pg_monitor}
 
postgres=# select * from pg_authid where rolname='sam';
  oid  | rolname | rolsuper | rolinherit | rolcreaterole | rolcreatedb | rolcanlogin | rolreplication | rolbypassrls | rolconnlimit |                                                              rolpassword                                                              | r
olvaliduntil
-------+---------+----------+------------+---------------+-------------+-------------+----------------+--------------+--------------+---------------------------------------------------------------------------------------------------------------------------------------+--
-------------
 18728 | sam     | f        | t          | f             | f           | t           | f              | f            |           -1 | SCRAM-SHA-256$4096:DNulkDpKBLqkY90Z4z4P3Q==$f+jAGXc1BC7K39LJ3XXmLQ7RpFUGotQaC1uJiBIonHk=:cCx2zsHzUGUooAtoyB4U79afIWnX4qpeXZglPC6WoGk= |
(1 row)

# 更改用户权限
赋予权限:alter user xxx with (CREATEDB, CREATEROLE, CREATEUSER, and even SUPERUSER)
revoke权限:  alter user xxx with nocreatedb  权限前面加no

postgres=# \du chensen
           List of roles
 Role name | Attributes | Member of
-----------+------------+-----------
 chensen   |            | {}

postgres=# alter user chensen with superuser;
ALTER ROLE
postgres=# \du chensen
           List of roles
 Role name | Attributes | Member of
-----------+------------+-----------
 chensen   | Superuser  | {}
postgres=# alter user chensen with nosuperuser;
ALTER ROLE
postgres=# \du chensen
           List of roles
 Role name | Attributes | Member of
-----------+------------+-----------
 chensen   |            | {}


pg_hba.conf
Trust Authentication
Allow the connection unconditionally. This method allows anyone that can connect to the PostgreSQL database server to login as any PostgreSQL user they wish, 
without the need for a password or any other authentication.
Ident authentication can only be used on TCP/IP connections. 
When specified for local connections, peer authentication will be used instead.
md5 Authentication
Require the client to supply a double-MD5-hashed password for authentication.

最好设置为允许所有用户通过网络走密码验证，这样就不需要reload postgresql
host    all             all             0.0.0.0/0               md5


新增用户sam, 用md5验证
-bash-4.2$ grep sam $PGDATA/pg_hba.conf |grep -v '#'
host    all             sam             0.0.0.0/0               md5
host    all             sam             127.0.0.1/32               md5
-------写.pgpass文件
-bash-4.2$ cat .pgpass
127.0.0.1:5432:postgres:zbx_monitor:vSTJ456
127.0.0.1:5432:postgres:sam:Foxconn123
-bash-4.2$ psql -h 127.0.0.1 -U sam -d postgres -c "select * from dbs"
   key   |              value
---------+---------------------------------
 mongo   | This is mongo cookbook
 mysql   | I like mysql
 oracle  | big database
 access  | microsoft tiny database
 mssql   | Microsoft SQL Server
 redis   | popular opensource key value db
 sqlite3 | a good tiny database
(7 rows)
-------不写.pgpass文件
-bash-4.2$ PGPASSWORD=Foxconn123 psql -h 127.0.0.1 -U sam -d postgres -c "select * from dbs"
   key   |              value
---------+---------------------------------
 mongo   | This is mongo cookbook
 mysql   | I like mysql
 oracle  | big database
 access  | microsoft tiny database
 mssql   | Microsoft SQL Server
 redis   | popular opensource key value db
 sqlite3 | a good tiny database
(7 rows)

-bash-4.2$ psql postgresql://sam:Foxconn123@127.0.0.1/postgres  -c "select * from dbs"
   key   |              value
---------+---------------------------------
 mongo   | This is mongo cookbook
 mysql   | I like mysql
 oracle  | big database
 access  | microsoft tiny database
 mssql   | Microsoft SQL Server
 redis   | popular opensource key value db
 sqlite3 | a good tiny database
(7 rows)


# search_path
默认设置为
postgres=# show search_path;
   search_path
-----------------
 "$user", public
(1 row)
此时看不到其他用户的schema的表
如要看schema chensen的表
postgres=# set search_path to chensen;
SET
postgres=# \d
                       List of relations
 Schema  |            Name            |     Type      |  Owner
---------+----------------------------+---------------+---------
 chensen | acknowledges               | foreign table | chensen
 chensen | actions                    | foreign table | chensen
 chensen | alerts                     | foreign table | chensen
 chensen | auditlog                   | foreign table | chensen
或者
postgres=# select * from information_schema.tables where table_schema='chensen';

### root账号下使用psql
[root@postgres-1 ~]# sudo -u postgres psql -c 'select * from cron.job'
could not change directory to "/root": Permission denied
 jobid |  schedule  |          command          | nodename | nodeport | database | username | active | jobname
-------+------------+---------------------------+----------+----------+----------+----------+--------+---------
     1 | 40 * * * * | SELECT profile.snapshot() |          |     5432 | postgres | postgres | t      |


## copy命令进行导入导出
# 导出
copy 表名 to '文件名' with csv;
copy (select a.hostid,a.name,c.name from hosts as a inner join hosts_groups as b on a.hostid=b.hostid inner join hstgrp as c on b.groupid=c.groupid where a.name not like 'Template%') to '/tmp/zabbixhost.csv' with csv;
# 导入
postgres=# create table staff(name text,team text,position text,height integer,weight integer,age numeric);
CREATE TABLE
postgres=# \copy staff from '/var/lib/pgsql/sample2.csv' with csv header delimiter ',' encoding 'UTF8';
COPY 1034


# Large object
All large objects are stored in a single system table named pg_largeobject.
 The real data is stored as a “bytea” (byte array) column. Since some files might be really large, PostgreSQL breaks them up into chunks.
lo_import函数导入文件
 postgres=# select lo_import('/tmp/facts.db');
 lo_import
-----------
     25991
(1 row)

postgres=# \dl
              Large objects
  ID   |  Owner   |     Description
-------+----------+----------------------
 16520 | postgres | oracle instantclinet
(1 row)

移除lo的链接
postgres=# select lo_unlink(16520);
 lo_unlink
-----------
         1
(1 row)

postgres=# \dl
      Large objects
 ID | Owner | Description
----+-------+-------------
(0 rows)


postgres=# select count(*) from pg_largeobject;
 count
-------
 27518
(1 row)

postgres=# select pg_size_pretty(pg_total_relation_size('pg_largeobject'));
 pg_size_pretty
----------------
 72 MB
(1 row)

-bash-4.2$ ls -lh base/14172/2613
-rw-------. 1 postgres postgres 72M  8月 31 08:07 base/14172/2613

建表导入文件
postgres=# create table t_file(name text,oid_number oid);
CREATE TABLE
postgres=# insert into t_file values('/tmp/facts.db',lo_import('/tmp/facts.db')) returning *;
     name      | oid_number
---------------+------------
 /tmp/facts.db |      25998
(1 row)

olphane large object will be cleand up by vacuum

# lateral join 实现select嵌套循环
伪代码
select name from staff as o1
for each name 
loop
do 
DML语句 from staff where name= o1.name
done
done

实现
postgres=# select * from (select name from staff) as o1, lateral (select row_to_json(ta) from (select name,team,position,(select row_to_json(ti) from (select height,weight,age where name=o1.name) ti )as details from staff where name=o1.name) ta) as o2 order by name;
        name         |                                                        row_to_json
---------------------+----------------------------------------------------------------------------------------------------------------------------
 Aaron Boone         | {"name":"Aaron Boone","team":" FLA","position":" Third Baseman","details":{"height":74,"weight":200,"age":33.98}}
 Aaron Cook          | {"name":"Aaron Cook","team":" COL","position":" Starting Pitcher","details":{"height":75,"weight":205,"age":28.06}}
 Aaron Fultz         | {"name":"Aaron Fultz","team":" CLE","position":" Relief Pitcher","details":{"height":72,"weight":205,"age":33.49}}
 Aaron Harang        | {"name":"Aaron Harang","team":" CIN","position":" Starting Pitcher","details":{"height":79,"weight":240,"age":28.81}}

# 窗口函数
select groupid,hostid,hostgroupid,row_number() over(partition by groupid order by hostgroupid) as hostgroupid_asc from hosts_groups;
 groupid | hostid | hostgroupid | hostgroupid_asc
---------+--------+-------------+-----------------
       4 |  10084 |          92 |               1
       8 |  10093 |         175 |               1
       8 |  10095 |         177 |               2
       8 |  10094 |         178 |               3
       8 |  10096 |         179 |               4
       8 |  10097 |         180 |               5
       8 |  10098 |         181 |               6
       8 |  10099 |         182 |               7
       8 |  10100 |         183 |               8
       8 |  10101 |         184 |               9
       8 |  10102 |         185 |              10
       8 |  10103 |         186 |              11
       8 |  10050 |         187 |              12
       8 |  10183 |         209 |              13

# generate_series 生成序列
https://blog.csdn.net/horses/article/details/107337354
基于时间
postgres=# select * from generate_series('2021-09-01 00:00:00'::timestamp,'2021-10-01 00:00:00'::timestamp,interval '1 day');
   generate_series
---------------------
 2021-09-01 00:00:00
 2021-09-02 00:00:00
 2021-09-03 00:00:00
 2021-09-04 00:00:00
 postgres=# select * from generate_series('2021-10-01 00:00:00'::timestamp,'2021-09-01 00:00:00'::timestamp,interval '-1 day');
   generate_series
---------------------
 2021-10-01 00:00:00
 2021-09-30 00:00:00
 2021-09-29 00:00:00
 2021-09-28 00:00:00
 2021-09-27 00:00:00

基于数字， asc, desc
postgres=# select * from generate_series(5,1,-1);
 generate_series
-----------------
               5
               4
               3
               2
               1
(5 rows)

postgres=# select * from generate_series(1,5);
 generate_series
-----------------
               1
               2
               3
               4
               5
postgres=# select * from generate_series(1,10,2);
 generate_series
-----------------
               1
               3
               5
               7
               9
基于字符
postgres=# select chr(v) from generate_series(65,90) v;
 chr
-----
 A
 B
 C
 D

postgres=# select chr(v) from generate_series(90,65,-1) v;
 chr
-----
 Z
 Y
 X
 W

# CTE生成序列
postgres=# with recursive t(n) as (
  values (1)
  union all
  select n+2 from t where n<50
)
select n from t;
 n
----
  1
  3
  5
  7
  9
 11
postgres=# with recursive t(n) as (
  values (1)
  union all
  select n*2 from t where n<50
)
select n from t;
 n
----
  1
  2
  4
  8
 16
 32
 64

# 生成指定范围内的随机数
CREATE OR REPLACE FUNCTION public.random_between(low integer, high integer)
 RETURNS integer
 LANGUAGE plpgsql
 STRICT
AS $function$
BEGIN
   RETURN floor(random()* (high-low + 1) + low);
END;
$function$
postgres=# select random_between(1000,1500);
 random_between
----------------
           1248
postgres=# insert into r1(value) select random_between(1,99999) from generate_series(1,999);
INSERT 0 999
postgres=# select * from r1;
 id  | value
-----+-------
   1 | 28586
   2 | 62447
   3 | 44234
	   
# 绑定变量和执行计划
create table t3(id serial,t text);
\d t3
insert into t3(t) select 'Linux' from generate_series(1,100);
select * from t3;
insert into t3(t) select 'Windows' from generate_series(1,50);
select * from t3;
create index idx_t3_t on t3(t);
analyze t3;
explain select count(*) from t3 where t='Linux';
prepare mypan(text) as select count(*) from t3 where t=$1;
explain execute mypan('Linux');

#索引
PostgreSQL的B-tree索引与Oracle的B-tree索引区别比较大，主要是以下4点：
1.PostgreSQL中索引会存储NULL，而Oracle不会；  还可以指定null first, null last
2.PostgreSQL中建立索引时，可以使用where来建立部分索引，而Oracle不能；
3.PostgreSQL中可以对同一列建立两个相同的索引，而Oracle不能；
4.PostgreSQL中可以使用concurrently关键字达到创建索引时不阻塞表的DML的功能，Oracle也有online参数实现类似的功能。

#查看锁
在一个session里
postgres=# begin;
BEGIN
postgres=*# insert into dbs values('oracle','big database');
INSERT 0 1

在另一个session里
select pid, state, usename, query, query_start 
from pg_stat_activity 
where pid in (
  select pid from pg_locks l 
  join pg_class t on l.relation = t.oid 
  and t.relkind = 'r' 
  where t.relname = 'dbs'
);
  pid  |        state        | usename  |                       query                        |          query_start
-------+---------------------+----------+----------------------------------------------------+-------------------------------
 27066 | idle in transaction | postgres | insert into dbs values('sqlite3','tiny database'); | 2021-09-11 08:21:47.500668+00
 27719 | idle in transaction | postgres | select key from dbs;                               | 2021-09-11 08:20:19.181387+00
(2 rows)

postgres=# select locktype,relation,mode from pg_locks;
   locktype    | relation |       mode
---------------+----------+------------------
 relation      |    12141 | AccessShareLock
 virtualxid    |          | ExclusiveLock
 relation      |    16676 | AccessShareLock
 relation      |    16669 | AccessShareLock
 relation      |    16472 | RowExclusiveLock
 virtualxid    |          | ExclusiveLock
 relation      |    16472 | AccessShareLock
 virtualxid    |          | ExclusiveLock
 transactionid |          | ExclusiveLock

postgres=# select oid,relname,relfilenode from pg_class where relname='dbs';
  oid  | relname | relfilenode
-------+---------+-------------
 16472 | dbs     |       16472

kill进程 
SELECT pg_cancel_backend(11929);
SELECT pg_terminate_backend(11929); 

查看当前事务锁等待、持锁信息的SQL
create view v_locks_monitor as   
with    
t_wait as    
(    
  select a.mode,a.locktype,a.database,a.relation,a.page,a.tuple,a.classid,a.granted,   
  a.objid,a.objsubid,a.pid,a.virtualtransaction,a.virtualxid,a.transactionid,a.fastpath,    
  b.state,b.query,b.xact_start,b.query_start,b.usename,b.datname,b.client_addr,b.client_port,b.application_name   
    from pg_locks a,pg_stat_activity b where a.pid=b.pid and not a.granted   
),   
t_run as   
(   
  select a.mode,a.locktype,a.database,a.relation,a.page,a.tuple,a.classid,a.granted,   
  a.objid,a.objsubid,a.pid,a.virtualtransaction,a.virtualxid,a.transactionid,a.fastpath,   
  b.state,b.query,b.xact_start,b.query_start,b.usename,b.datname,b.client_addr,b.client_port,b.application_name   
    from pg_locks a,pg_stat_activity b where a.pid=b.pid and a.granted   
),   
t_overlap as   
(   
  select r.* from t_wait w join t_run r on   
  (   
    r.locktype is not distinct from w.locktype and   
    r.database is not distinct from w.database and   
    r.relation is not distinct from w.relation and   
    r.page is not distinct from w.page and   
    r.tuple is not distinct from w.tuple and   
    r.virtualxid is not distinct from w.virtualxid and   
    r.transactionid is not distinct from w.transactionid and   
    r.classid is not distinct from w.classid and   
    r.objid is not distinct from w.objid and   
    r.objsubid is not distinct from w.objsubid and   
    r.pid <> w.pid   
  )    
),    
t_unionall as    
(    
  select r.* from t_overlap r    
  union all    
  select w.* from t_wait w    
)    
select locktype,datname,relation::regclass,page,tuple,virtualxid,transactionid::text,classid::regclass,objid,objsubid,   
string_agg(   
'Pid: '||case when pid is null then 'NULL' else pid::text end||chr(10)||   
'Lock_Granted: '||case when granted is null then 'NULL' else granted::text end||' , Mode: '||case when mode is null then 'NULL' else mode::text end||' , FastPath: '||case when fastpath is null then 'NULL' else fastpath::text end||' , VirtualTransaction: '||case when virtualtransaction is null then 'NULL' else virtualtransaction::text end||' , Session_State: '||case when state is null then 'NULL' else state::text end||chr(10)||   
'Username: '||case when usename is null then 'NULL' else usename::text end||' , Database: '||case when datname is null then 'NULL' else datname::text end||' , Client_Addr: '||case when client_addr is null then 'NULL' else client_addr::text end||' , Client_Port: '||case when client_port is null then 'NULL' else client_port::text end||' , Application_Name: '||case when application_name is null then 'NULL' else application_name::text end||chr(10)||    
'Xact_Start: '||case when xact_start is null then 'NULL' else xact_start::text end||' , Query_Start: '||case when query_start is null then 'NULL' else query_start::text end||' , Xact_Elapse: '||case when (now()-xact_start) is null then 'NULL' else (now()-xact_start)::text end||' , Query_Elapse: '||case when (now()-query_start) is null then 'NULL' else (now()-query_start)::text end||chr(10)||    
'SQL (Current SQL in Transaction): '||chr(10)||  
case when query is null then 'NULL' else query::text end,    
chr(10)||'--------'||chr(10)    
order by    
  (  case mode    
    when 'INVALID' then 0   
    when 'AccessShareLock' then 1   
    when 'RowShareLock' then 2   
    when 'RowExclusiveLock' then 3   
    when 'ShareUpdateExclusiveLock' then 4   
    when 'ShareLock' then 5   
    when 'ShareRowExclusiveLock' then 6   
    when 'ExclusiveLock' then 7   
    when 'AccessExclusiveLock' then 8   
    else 0   
  end  ) desc,   
  (case when granted then 0 else 1 end)  
) as lock_conflict  
from t_unionall   
group by   
locktype,datname,relation,page,tuple,virtualxid,transactionid::text,classid,objid,objsubid ;  

###  table access method
https://www.postgresql.fastware.com/blog/postgresql-table-access-methods
Is it the same as foreign data wrappers? What is the difference?
Foreign data wrappers are intended to access foreign data, while table access methods are used to access local data.

For example, suppose you have a requirement to use columnar data in your application. With foreign data wrappers, you would need to use to access a remote server containing the
 columnar data (in this case using cstore_fdw), which would reduce processing performance.

But with table access methods, it is possible to store columnar tables locally, which speeds up processing. Note though, that PostgreSQL 13 does not support table access methods for columnar tables.

In short, foreign data wrappers and table access methods target different needs. The former allows users to access data in a remote server that was never intended to be stored locally, 
while the latter allows users to store data locally using different supported methods.

Possible implementations of table access methods in PostgreSQL 14 and later include, among others, the following:

An alternative to heap, such as zheap
Columnar tables, such as Zedstore
In-memory tables
Indexed tables

### exists
dvdrental=# select f.film_id,f.title,f.release_year,f.rating from film f where exists (select * from film_category c where c.film_id=f.film_id and category_id=2) order by rating;
 film_id |         title          | release_year | rating
---------+------------------------+--------------+--------
     569 | Menagerie Rushmore     |         2006 | G
     901 | Tracy Cider            |         2006 | G
     402 | Harper Dying           |         2006 | G
     430 | Hook Chariots          |         2006 | G
     510 | Lawless Vision         |         2006 | G

If the subquery returns NULL, EXISTS returns true	 
dvdrental=# select film_id,title from film where exists(select null);
 film_id |            title
---------+-----------------------------
     133 | Chamber Italian
     384 | Grosse Wonderful
       8 | Airport Pollock

# pgbench
/usr/pgsql-13/bin/pgbench -i -s 100 -U postgres -p 5432 -d pgbench  初始化数据库
pgbench -M prepared -r -c 10 -j 4 -T 100 -U postgres -p 5432 -d pgbench -l  删改数据库	   

#####  查看数据库、表的大小
只查看表
pgbench=# select pg_size_pretty(pg_relation_size('pgbench_accounts'));
 pg_size_pretty
----------------
 1281 MB
(1 row)
pgbench=# \d+
                                 List of relations
 Schema |       Name       | Type  |  Owner   | Persistence |  Size   | Description
--------+------------------+-------+----------+-------------+---------+-------------
 public | pgbench_accounts | table | postgres | permanent   | 1281 MB |

只查看表的index
pgbench=# select pg_size_pretty(pg_indexes_size('pgbench_accounts'));
 pg_size_pretty
----------------
 214 MB
(1 row)
pgbench=# \di+
                                             List of relations
 Schema |         Name          | Type  |  Owner   |      Table       | Persistence |  Size  | Description
--------+-----------------------+-------+----------+------------------+-------------+--------+-------------
 public | pgbench_accounts_pkey | index | postgres | pgbench_accounts | permanent   | 214 MB |
 public | pgbench_branches_pkey | index | postgres | pgbench_branches | permanent   | 16 kB  |
 public | pgbench_tellers_pkey  | index | postgres | pgbench_tellers  | permanent   | 40 kB  |

查看表包括表的依赖
pgbench=# select pg_size_pretty(pg_total_relation_size('pgbench_accounts'));
 pg_size_pretty
----------------
 1495 MB
(1 row)
查看表空间大小
pgbench=# select pg_size_pretty(pg_tablespace_size('pg_default'));
 pg_size_pretty
----------------
 1535 MB
(1 row)
pgbench=# \dbS+
                                  List of tablespaces
    Name    |  Owner   | Location | Access privileges | Options |  Size   | Description
------------+----------+----------+-------------------+---------+---------+-------------
 pg_default | postgres |          |                   |         | 1535 MB |
 pg_global  | postgres |          |                   |         | 575 kB  |

查看数据库的大小
pgbench=# select pg_size_pretty(pg_database_size('pgbench'));
 pg_size_pretty
----------------
 1504 MB
(1 row)
pgbench=# \l+
                                                               List of databases
   Name    |  Owner   | Encoding  | Collate | Ctype |   Access privileges   |  Size   | Tablespace |                Description
-----------+----------+-----------+---------+-------+-----------------------+---------+------------+--------------------------------------------
 pgbench   | postgres | SQL_ASCII | C       | C     |                       | 1504 MB | pg_default |
 postgres  | postgres | SQL_ASCII | C       | C     |                       | 8133 kB | pg_default | default administrative connection database
 repmgr    | repmgr   | SQL_ASCII | C       | C     |                       | 8293 kB | pg_default |

 查看数据库中所有的表,index的大小并排序
 SELECT
    TableName
    ,pg_size_pretty(pg_table_size(TableName)) AS TableSize
    ,pg_size_pretty(pg_indexes_size(TableName)) AS IndexSize
    ,pg_total_relation_size(TableName) AS TotalSize
FROM 
(
     SELECT ('"' || table_schema || '"."' || table_name || '"') AS TableName
     FROM information_schema.tables
) AS Tables
ORDER BY 4 DESC;
                          tablename                           | tablesize  | indexsize  | totalsize
--------------------------------------------------------------+------------+------------+------------
 "public"."t4"                                                | 2489 MB    | 0 bytes    | 2609676288
 "pg_catalog"."pg_largeobject"                                | 72 MB      | 624 kB     |   75825152
 "profile"."sample_stat_tables"                               | 7208 kB    | 1280 kB    |    8691712
 "profile"."sample_statements"                                | 4448 kB    | 944 kB     |    5521408
 "profile"."sample_kcache"                                    | 2248 kB    | 760 kB     |    3080192
 "profile"."sample_stat_indexes"                              | 1464 kB    | 504 kB     |    2015232
 "pg_catalog"."pg_attribute"                                  | 1320 kB    | 488 kB     |    1851392
 "pg_catalog"."pg_depend"                                     | 680 kB     | 904 kB     |    1622016
 "pg_catalog"."pg_proc"                                       | 1064 kB    | 432 kB     |    1531904
 "pg_catalog"."pg_statistic"                                  | 984 kB     | 64 kB      |    1073152
 "profile"."sample_stat_tables_total"                         | 712 kB     | 192 kB     |     925696
 "pg_catalog"."pg_rewrite"                                    | 704 kB     | 32 kB      |     753664

# 找出时间长的查询 
postgres=# select datname,pid,query_start,state,query from pg_stat_activity ;
 datname  | pid  |          query_start          | state  |                                              query
----------+------+-------------------------------+--------+--------------------------------------------------------------------------------------------------
          | 1180 |                               |        |
 postgres | 1183 | 2021-10-27 01:40:01.020783+00 | idle   | update cron.job_run_details set status = $1, return_message = $2, end_time = $3 where runid = $4
          | 1184 |                               |        |
          | 1225 | 2021-10-15 09:19:10.40095+00  | active | START_REPLICATION SLOT "postgres2_slot" 2/5000000 TIMELINE 1
 postgres | 2401 | 2021-10-27 02:16:38.955905+00 | active | select datname,pid,query_start,state,query from pg_stat_activity ;

查看索引是否存活、有效
postgres=# select relname,indexrelname,indexrelid from pg_stat_all_indexes where relname='t3';
 relname | indexrelname | indexrelid
---------+--------------+------------
 t3      | idx_t3_t     |      16425
(1 row)

postgres=# select indexrelid,indislive,indisvalid from pg_index where indexrelid=16425;
 indexrelid | indislive | indisvalid
------------+-----------+------------
      16425 | t         | t
	  
查看元组上次vacuum,analyze时间和有多少dead tuple
postgres=# select relname,last_vacuum,n_dead_tup,last_analyze
from pg_stat_all_tables where relname='t2';
 relname |          last_vacuum          | n_dead_tup |         last_analyze
---------+-------------------------------+------------+-------------------------------
 t2      | 2021-09-16 02:45:20.079676+00 |          0 | 2021-10-27 02:23:56.784364+00

#  查找自从上次统计以来没有使用的索引 
postgres=# SELECT
     relname,
     indexrelname,
    idx_scan,
     idx_tup_read,
     idx_tup_fetch,
     pg_size_pretty(pg_relation_size(indexrelname::regclass)) as size
 FROM
     pg_stat_all_indexes
 WHERE
     schemaname = 'public'
     AND indexrelname NOT LIKE 'pg_toast_%'
     AND idx_scan = 0
     AND idx_tup_read = 0
     AND idx_tup_fetch = 0
 ORDER BY
     pg_relation_size(indexrelname::regclass) DESC;
 relname | indexrelname | idx_scan | idx_tup_read | idx_tup_fetch |  size
---------+--------------+----------+--------------+---------------+--------
 t3      | idx_t3_t     |        0 |            0 |             0 | 152 kB
 books   | books_pkey   |        0 |            0 |             0 | 16 kB
 facts   | facts_pkey   |        0 |            0 |             0 | 16 kB
 
### buffercache扩展 
查看PG Buffer cache里的数据
postgres=# create extension pg_buffercache;
CREATE EXTENSION

postgres=# SELECT c.relname, count(*) AS buffers
  FROM pg_buffercache b INNER JOIN pg_class c
  ON b.relfilenode = pg_relation_filenode(c.oid) AND
  b.reldatabase IN (0, (SELECT oid FROM pg_database
  WHERE datname = current_database()))
  GROUP BY c.relname
  ORDER BY 2 DESC
  LIMIT 10;
        relname         | buffers
------------------------+---------
 sample_stat_tables     |     901
 sample_statements      |     555
 sample_kcache          |     281
 sample_stat_indexes    |     183
 pg_attribute           |     162
 pk_sample_stat_tables  |     160
 pg_proc                |     114
 pg_statistic           |     101
 pg_largeobject         |      99
 pk_sample_statements_n |      96
(10 rows)

# pgfincore扩展
查看OS CACHE里的数据
[root@postgres-1 ~]# yum install pgfincore13 -y
postgres=# create extension pgfincore;
CREATE EXTENSION

postgres=# select * from pgfincore('t4');
      relpath       | segment | os_page_size | rel_os_pages | pages_mem | group_mem | os_pages_free | databit | pages_dirty | group_dirty
--------------------+---------+--------------+--------------+-----------+-----------+---------------+---------+-------------+-------------
 base/14172/16427   |       0 |         4096 |       262144 |    262144 |         1 |         52808 |         |           0 |           0
 base/14172/16427.1 |       1 |         4096 |       262144 |    262144 |         1 |         52808 |         |           0 |           0
 base/14172/16427.2 |       2 |         4096 |       112656 |    112656 |         1 |         52808 |         |           0 |           0
(3 rows)

select rpad(c.relname,30,' ') as Object_Name,
case when c.relkind='r' then 'Table' when c.relkind='i' then 'Index' else 'Other' end as Object_Type, 
rpad(count(*)::text,5,' ') as "PG_Buffer_Cache_usage(8KB)",
split_part(pgfincore(c.relname::text)::text,','::text,5) as "OS_Cache_usage(4KB)"
from pg_class c inner join pg_buffercache b on b.relfilenode=c.relfilenode
     inner join pg_database d on (b.reldatabase=d.oid and d.datname=current_database() and c.relnamespace=(select oid from pg_namespace where nspname='public'))
group by c.relname,c.relkind
order by "PG_Buffer_Cache_usage(8KB)"
desc limit 10;
这里可以同时看到表t4在PG BUFFER和OS cache里有多少缓存
          object_name           | object_type | PG_Buffer_Cache_usage(8KB) | OS_Cache_usage(4KB)
--------------------------------+-------------+----------------------------+---------------------
 t4                             | Table       | 12619                      | 262144
 t4                             | Table       | 12619                      | 262144
 t4                             | Table       | 12619                      | 112656
(3 rows)


释放OS CACHE里的数据
postgres=# select * from pgfadvise_dontneed('t4');
      relpath       | os_page_size | rel_os_pages | os_pages_free
--------------------+--------------+--------------+---------------
 base/14172/16427   |         4096 |       262144 |        311367
 base/14172/16427.1 |         4096 |       262144 |        573544
 base/14172/16427.2 |         4096 |       112656 |        686170
(3 rows)
查询结果
          object_name           | object_type | PG_Buffer_Cache_usage(8KB) | OS_Cache_usage(4KB)
--------------------------------+-------------+----------------------------+---------------------
 t4                             | Table       | 12619                      | 0
 t4                             | Table       | 12619                      | 0
 t4                             | Table       | 12619                      | 0

# pg_prewarm扩展
postgres=# create extension pg_prewarm;
CREATE EXTENSION
将表加到pg的buffercache里 ------ 预热
postgres=# select pg_prewarm('t4','buffer');
 pg_prewarm
------------
     318472
(1 row)

postgres=# SELECT c.relname, count(*) AS buffers
             FROM pg_buffercache b INNER JOIN pg_class c
             ON b.relfilenode = pg_relation_filenode(c.oid) AND
                b.reldatabase IN (0, (SELECT oid FROM pg_database
                                      WHERE datname = current_database()))
             GROUP BY c.relname
             ORDER BY 2 DESC
             LIMIT 10;
        relname        | buffers  (8KB)
-----------------------+---------
 t4                    |  126003
 sample_stat_tables    |     901
 sample_statements     |     555
 sample_kcache         |     281
 sample_stat_indexes   |     183
 pk_sample_stat_tables |     160
 pg_proc               |     112
 pg_attribute          |     103
 pg_largeobject        |      98
 pg_statistic          |      96


postgres=# select c.relname,pg_size_pretty(count(*) * 8192) as buffered, 
round(100.0 * count(*) / ( 
select setting from pg_settings 
where name='shared_buffers')::integer,1)
as buffer_percent, 
round(100.0*count(*)*8192 / pg_table_size(c.oid),1) as percent_of_relation
from pg_class c inner join pg_buffercache b on b.relfilenode = c.relfilenode inner 
join pg_database d on ( b.reldatabase =d.oid and d.datname =current_database()) 
group by c.oid,c.relname order by 3 desc limit 10;
         relname          | buffered | buffer_percent | percent_of_relation
--------------------------+----------+----------------+---------------------
 t4                       | 985 MB   |           96.2 |                39.6
 sample_stat_tables       | 7208 kB  |            0.7 |               100.0
 sample_statements        | 4440 kB  |            0.4 |                99.8
 sample_kcache            | 2248 kB  |            0.2 |               100.0
 pk_sample_kcache_n       | 760 kB   |            0.1 |               100.0
 pk_sample_stat_tables    | 1280 kB  |            0.1 |               100.0
 pk_sample_statements_n   | 760 kB   |            0.1 |                99.0
 pg_statistic             | 808 kB   |            0.1 |                82.1
 pg_largeobject           | 784 kB   |            0.1 |                99.0
 sample_stat_tables_total | 712 kB   |            0.1 |               100.0
(10 rows)

上述结果里，buffered 表示表格被載入shared_buffers的大小
buffer_percent 表示這個表格佔用多少shared_buffers 的比例
percent_of_relation 表示這個表格有多少比例被載入 shared_buffers


postgres=# \timing
Timing is on.
postgres=# select count(*) from t4;
  count
----------
 50000000
(1 row)

Time: 1633.040 ms (00:01.633)

# buffer里hit 125998, 从磁盘读192474
postgres=# explain (analyze,buffers) select count(*) from t4;
                                                                 QUERY PLAN
---------------------------------------------------------------------------------------------------------------------------------------------
 Finalize Aggregate  (cost=579887.80..579887.81 rows=1 width=8) (actual time=4471.167..4484.424 rows=1 loops=1)
   Buffers: shared hit=125998 read=192474     
   I/O Timings: read=695.778
   ->  Gather  (cost=579887.58..579887.79 rows=2 width=8) (actual time=4470.931..4484.409 rows=3 loops=1)
         Workers Planned: 2
         Workers Launched: 2
         Buffers: shared hit=125998 read=192474
         I/O Timings: read=695.778
         ->  Partial Aggregate  (cost=578887.58..578887.59 rows=1 width=8) (actual time=4465.660..4465.662 rows=1 loops=3)
               Buffers: shared hit=125998 read=192474       
               I/O Timings: read=695.778
               ->  Parallel Seq Scan on t4  (cost=0.00..526804.47 rows=20833247 width=0) (actual time=0.052..2554.489 rows=16666667 loops=3)
                     Buffers: shared hit=125998 read=192474
                     I/O Timings: read=695.778
 Planning Time: 0.140 ms
 Execution Time: 4484.615 ms

####  表/索引膨胀
PostgreSQL的表或索引发生膨胀后，用户可以使用vacuum full或rewrite table(如cluster)的方式重建表。

但是vacuum full或者rewrite都需要持有排它锁，会堵塞读操作。

为了减少锁冲突，社区有一个名为pg_reorg或pg_repack的插件，使用了增量的方式重组数据，最后通过切换FILENODE完成数据重组。

仅仅在切换FILENODE时需要持有排他锁，非常短暂，影响比VACUUM FULL和rewrite的方式小多了。

但是pg_reorg或pg_repack都需要建触发器，记录下增量重组时，原表产生的增量数据。

https://github.com/reorg/pg_repack

因此重组时，触发器会带来一定的开销，对被重组的表，有一定的DML性能影响。

本文将要介绍另一个重组插件，名为pg_squeeze，它使用REDO和logical replication实现增量重组，不需要建立触发器，但是要求表上面有PK或者UK。

pg_squeeze的优点
相比pg_repack或pg_reorg，pg_squeeze不需要建触发器，所以在重组时对原表的DML几乎没有性能影响。

pg_squeeze支持自动的重组，即通过设置阈值、比较用户表与阈值，自动启动WORKER进程，将数据复制到重组表，最后加锁，切换FILENODE 

# 遗忘的复制插槽会导致wal膨胀。 但是幸运的是，我们可以通过pg_replication_slots监视插槽的状态
postgres=# select * from pg_replication_slots ;
-[ RECORD 1 ]-------+---------------
slot_name           | standby_slot
plugin              |
slot_type           | physical
datoid              |
database            |
temporary           | f
active              | t
active_pid          | 31805
xmin                |
catalog_xmin        |
restart_lsn         | 3/A5A60000
confirmed_flush_lsn |
wal_status          | extended
safe_wal_size       |
-[ RECORD 2 ]-------+---------------
slot_name           | postgres2_slot
plugin              |
slot_type           | physical
datoid              |
database            |
temporary           | f
active              | t
active_pid          | 21862
xmin                |
catalog_xmin        |
restart_lsn         | 4/769EF8C8
confirmed_flush_lsn |
wal_status          | reserved
safe_wal_size       |

postgres-1这台机的wal膨胀的时候，wal文件有240个，大小达到3.8G
原因是因为复制槽standby_slot，这个复制槽曾经被pg_receivewal用过
*******
-bash-4.2$ pg_receivewal -D wal_remotebk/ -v -S standby_slot --synchronous -h 10.67.39.58 -p 5432 -U repl -W
Password:
pg_receivewal: starting log streaming at 2/9000000 (timeline 1)
pg_receivewal: finished segment at 2/A000000 (timeline 1)
pg_receivewal: finished segment at 2/B000000 (timeline 1)
pg_receivewal: finished segment at 2/C000000 (timeline 1)
pg_receivewal: finished segment at 2/D000000 (timeline 1)
pg_receivewal: finished segment at 2/E000000 (timeline 1)
pg_receivewal: finished segment at 2/F000000 (timeline 1)

*******
-bash-4.2$ ls -lh pg_wal
總計 3.8G
-rw-------. 1 postgres postgres 16M 10月 16 09:40 00000001000000030000008A
-rw-------. 1 postgres postgres 16M 10月 16 14:40 00000001000000030000008B
-bash-4.2$ ls -lh pg_wal |wc -l
240

解决：首先在postgres-2上恢复pg_receivewal的运行，然后删除这个复制槽
postgres=# select pg_drop_replication_slot('standby_slot');
 pg_drop_replication_slot
--------------------------

(1 row)


wal膨胀消失后
-bash-4.2$ ls -lh pg_wal
總計 513M
-rw-------. 1 postgres postgres 319 11月  6 05:59 000000010000000400000075.00000028.backup
-rw-------. 1 postgres postgres 16M 11月  6 07:32 000000010000000400000076
-rw-------. 1 postgres postgres 16M 10月 24 16:40 000000010000000400000077

-bash-4.2$ ll |wc -l
35

# pg_archivecleanup命令

pg_archivecleanup is for use with streaming replication. It removes WAL archives no longer needed for the standby to catch up.
 It has no idea how long you keep your base backups around
pg_archivecleanup can also be used as a standalone program to clean WAL file archives

# 清除 archived wal files

运行一段时间后有18G的归档日志
-bash-4.2$ du -sh /opt/archivedir/
18G     /opt/archivedir/

先做basebackup备份，然后运行pg_archivecleanup
-bash-4.2$ pg_basebackup -D backups

看到000000010000000400000078.00000028.backup这个文件，这个文件是一个backup label文件，里面有label信息
-bash-4.2$ ls -lh pg_wal
總計 513M
-rw-------. 1 postgres postgres 16M 11月  6 07:50 000000010000000400000078
-rw-------. 1 postgres postgres 340 11月  6 07:50 000000010000000400000078.00000028.backup
-rw-------. 1 postgres postgres 16M 11月  6 07:53 000000010000000400000079


-bash-4.2$ pg_archivecleanup -d /opt/archivedir/ 000000010000000400000078.00000028.backup
pg_archivecleanup: keeping WAL file "/opt/archivedir//000000010000000400000078" and later
pg_archivecleanup: removing file "/opt/archivedir//000000010000000000000001"
pg_archivecleanup: removing file "/opt/archivedir//000000010000000000000002"

清除完后，还剩33M
-bash-4.2$ du -sh /opt/archivedir/
33M     /opt/archivedir/

# 添加主键
在表上添加一个主键是有意义的，PostgreSQL中，可以通过alter table很方便的添加一个主键，但是当主键索引创建的时候，会花费很长时间，这样会阻塞查询；

DO NOT

ALTER TABLE items ADD PRIMARY KEY (id); 
INSTEAD

CREATE UNIQUE INDEX CONCURRENTLY items_pk ON items (id); -- 花很长时间，但是不会阻塞读写
ALTER TABLE items ADD CONSTRAINT items_pk PRIMARY KEY USING INDEX items_pk;  -- 阻塞读写，但是很短
通过将主键索引的创建，分成两步；这样繁重的创建索引的工作不会影响业务查询；


######################################
rule 转换 例子
数据来源是2个字段表示的经纬度，要求实时转换为geometry类型。

创建来源表结构

postgres=# create table nt(id int, c1 numeric, c2 numeric);  
CREATE TABLE  
创建目标表结构

postgres=# create table nt_geo (id int, geo geometry);  
CREATE TABLE  
对来源表创建规则或触发器，例如

postgres=# create rule r1 as on insert to nt do instead insert into nt_geo values (NEW.id, ST_MakePoint(NEW.c1,NEW.c2));  
CREATE RULE  
使用来源数据结构，将数据插入来源数据表

postgres=# insert into nt values (1,1,1);  
INSERT 0 1  
数据会自动写入目标表，来源表只是个转换入口，不会落数据

postgres=# select * from nt;  
 id | c1 | c2   
----+----+----  
(0 rows)  
  
postgres=# select * from nt_geo ;  
 id |                    geo                       
----+--------------------------------------------  
  1 | 0101000000000000000000F03F000000000000F03F  
(1 row)  
cool !!!使用这种方法，我们不需要先入库在转换，也不需要在入库前写程序进行转换。