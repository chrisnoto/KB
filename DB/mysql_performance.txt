运行中的mysql状态查看
 
对正在运行的mysql进行监控，其中一个方式就是查看mysql运行状态。 

(1)QPS(每秒Query量) 
QPS = Questions(or Queries) / seconds 
mysql > show  global  status like 'Question%'; 
 
(2)TPS(每秒事务量) 
TPS = (Com_commit + Com_rollback) / seconds 
mysql > show global status like 'Com_commit'; 
mysql > show global status like 'Com_rollback'; 
 
(3)key Buffer 命中率 
mysql>show  global   status  like   'key%'; 
key_buffer_read_hits = (1-key_reads / key_read_requests) * 100% 
key_buffer_write_hits = (1-key_writes / key_write_requests) * 100% 
 
(4)InnoDB Buffer命中率 
mysql> show status like 'innodb_buffer_pool_read%'; 
innodb_buffer_read_hits = (1 - innodb_buffer_pool_reads / innodb_buffer_pool_read_requests) * 100% 
 
(5)Query Cache命中率 
mysql> show status like 'Qcache%'; 
Query_cache_hits = (Qcahce_hits / (Qcache_hits + Qcache_inserts )) * 100%; 
 
(6)Table Cache状态量 
mysql> show global  status like 'open%'; 
比较 open_tables  与 opend_tables 值 
 
(7)Thread Cache 命中率 
mysql> show global status like 'Thread%'; 
mysql> show global status like 'Connections'; 
Thread_cache_hits = (1 - Threads_created / connections ) * 100% 
 
(8)锁定状态 
mysql> show global  status like '%lock%'; 
Table_locks_waited/Table_locks_immediate=0.3%  如果这个比值比较大的话，说明表锁造成的阻塞比较严重 
Innodb_row_lock_waits innodb行锁，太大可能是间隙锁造成的 
 
(9)复制延时量 
mysql > show slave status 
查看延时时间 
 
(10) Tmp Table 状况(临时表状况) 
mysql > show status like 'Create_tmp%'; 
Created_tmp_disk_tables/Created_tmp_tables比值最好不要超过10%，如果Created_tmp_tables值比较大， 
可能是排序句子过多或者是连接句子不够优化 
 
(11) Binlog Cache 使用状况 
mysql > show status like 'Binlog_cache%'; 
如果Binlog_cache_disk_use值不为0 ，可能需要调大 binlog_cache_size大小 
 
(12) Innodb_log_waits 量 
mysql > show status like 'innodb_log_waits'; 
Innodb_log_waits值不等于0的话，表明 innodb log  buffer 因为空间不足而等待 

https://www.cnblogs.com/zhoujinyi/p/5236705.html
统计应用：

      关于SQL维度的统计信息主要集中在events_statements_summary_by_digest表中，通过将SQL语句抽象出digest，可以统计某类SQL语句在各个维度的统计信息

1，哪个SQL执行最多：

复制代码
zjy@performance_schema 11:36:22>SELECT SCHEMA_NAME,DIGEST_TEXT,COUNT_STAR,SUM_ROWS_SENT,SUM_ROWS_EXAMINED,FIRST_SEEN,LAST_SEEN FROM events_statements_summary_by_digest ORDER BY COUNT_STAR desc LIMIT 1\G
*************************** 1. row ***************************
      SCHEMA_NAME: dchat
      DIGEST_TEXT: SELECT ...
       COUNT_STAR: 1161210102
    SUM_ROWS_SENT: 1161207842
SUM_ROWS_EXAMINED: 0
       FIRST_SEEN: 2016-02-17 00:36:46
        LAST_SEEN: 2016-03-07 11:36:29
复制代码
各个字段的注释可以看上面的表结构说明：从2月17号到3月7号该SQL执行了1161210102次。

2，哪个SQL平均响应时间最多：

复制代码
zjy@performance_schema 11:36:28>SELECT SCHEMA_NAME,DIGEST_TEXT,COUNT_STAR,AVG_TIMER_WAIT,SUM_ROWS_SENT,SUM_ROWS_EXAMINED,FIRST_SEEN,LAST_SEEN FROM events_statements_summary_by_digest ORDER BY AVG_TIMER_WAIT desc LIMIT 1\G
*************************** 1. row ***************************
      SCHEMA_NAME: dchat
      DIGEST_TEXT: SELECT ...
       COUNT_STAR: 1
   AVG_TIMER_WAIT: 273238183964000
    SUM_ROWS_SENT: 50208
SUM_ROWS_EXAMINED: 5565651
       FIRST_SEEN: 2016-02-22 13:27:33
        LAST_SEEN: 2016-02-22 13:27:33
复制代码
各个字段的注释可以看上面的表结构说明：从2月17号到3月7号该SQL平均响应时间273238183964000皮秒（1000000000000皮秒=1秒）

3，哪个SQL扫描的行数最多：

SUM_ROWS_EXAMINED

4，哪个SQL使用的临时表最多：

SUM_CREATED_TMP_DISK_TABLES、SUM_CREATED_TMP_TABLES

5，哪个SQL返回的结果集最多：

SUM_ROWS_SENT

6，哪个SQL排序数最多：

SUM_SORT_ROWS

通过上述指标我们可以间接获得某类SQL的逻辑IO(SUM_ROWS_EXAMINED)，CPU消耗(SUM_SORT_ROWS)，网络带宽(SUM_ROWS_SENT)的对比。

通过file_summary_by_instance表，可以获得系统运行到现在，哪个文件(表)物理IO最多，这可能意味着这个表经常需要访问磁盘IO。

7，哪个表、文件逻辑IO最多（热数据）：

复制代码
zjy@performance_schema 12:16:18>SELECT FILE_NAME,EVENT_NAME,COUNT_READ,SUM_NUMBER_OF_BYTES_READ,COUNT_WRITE,SUM_NUMBER_OF_BYTES_WRITE FROM file_summary_by_instance ORDER BY SUM_NUMBER_OF_BYTES_READ+SUM_NUMBER_OF_BYTES_WRITE DESC LIMIT 2\G
*************************** 1. row ***************************
                FILE_NAME: /var/lib/mysql/ibdata1  #文件
               EVENT_NAME: wait/io/file/innodb/innodb_data_file
               COUNT_READ: 544
 SUM_NUMBER_OF_BYTES_READ: 10977280
              COUNT_WRITE: 3700729
SUM_NUMBER_OF_BYTES_WRITE: 1433734217728
*************************** 2. row ***************************
                FILE_NAME: /var/lib/mysql/dchat/fans.ibd   #表
               EVENT_NAME: wait/io/file/innodb/innodb_data_file
               COUNT_READ: 9370680
 SUM_NUMBER_OF_BYTES_READ: 153529188352
              COUNT_WRITE: 67576376
SUM_NUMBER_OF_BYTES_WRITE: 1107815432192
复制代码
8，哪个索引使用最多：

复制代码
zjy@performance_schema 12:18:42>SELECT OBJECT_NAME, INDEX_NAME, COUNT_FETCH, COUNT_INSERT, COUNT_UPDATE, COUNT_DELETE FROM table_io_waits_summary_by_index_usage ORDER BY SUM_TIMER_WAIT DESC limit 1;
+-------------+------------+-------------+--------------+--------------+--------------+
| OBJECT_NAME | INDEX_NAME | COUNT_FETCH | COUNT_INSERT | COUNT_UPDATE | COUNT_DELETE |
+-------------+------------+-------------+--------------+--------------+--------------+
| fans        | PRIMARY    | 29002695158 |            0 |    296373434 |            0 |
+-------------+------------+-------------+--------------+--------------+--------------+
1 row in set (0.29 sec)
复制代码
通过table_io_waits_summary_by_index_usage表，可以获得系统运行到现在，哪个表的具体哪个索引(包括主键索引，二级索引)使用最多。

9，哪个索引没有使用过：

zjy@performance_schema 12:23:22>SELECT OBJECT_SCHEMA, OBJECT_NAME, INDEX_NAME FROM table_io_waits_summary_by_index_usage WHERE INDEX_NAME IS NOT NULL AND COUNT_STAR = 0 AND OBJECT_SCHEMA <> 'mysql' ORDER BY OBJECT_SCHEMA,OBJECT_NAME;
10，哪个等待事件消耗的时间最多：

zjy@performance_schema 12:25:22>SELECT EVENT_NAME, COUNT_STAR, SUM_TIMER_WAIT, AVG_TIMER_WAIT FROM events_waits_summary_global_by_event_name WHERE event_name != 'idle' ORDER BY SUM_TIMER_WAIT DESC LIMIT 1;
