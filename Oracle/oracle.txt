########### Oracle启动/关闭过程 ###############

启动模式
1 startup nomount
启动实例 shutdown --> nomount
总体来说，启动数据库实例包括以下操作：
读取参数文件 SPFILE
分配 SGA
启动后台进程
打开告警文件和跟踪文件

*nomount 状态不打开任何的控制文件及数据文件，所以我们可以在此阶段进行数据库创建、控制文件重建、特定的备份恢复等操作。
*nomount 状态下可以通过参数文件获得控制文件的位置，因为此时参数文件已经打开：
SQL> show parameter control_files;

2 alter database mount/startup mount
装载数据库 nomunt --> mount
3.3.1 装载数据库概述
装载数据库就是把数据库文件和实例关联起来，包括以下三个步骤：
Oracle根据参数文件 SPFILE 中的参数找到控制文件
打开控制文件
从控制文件获得数据字典和重做日志文件的名字及位置
完成以上三步，没有任何错误的情况下，Oracle 就已经把实例和数据库关联起来了。
装载数据库有两种方式：
一是直接启动数据库到 mount 状态：startup mount
二是如果数据库已经启动到 nomount 状态，使用 alter database mount 把数据库切换到mount 状态

我们就可以查询控制文件、数据文件和重做日志文件
SQL> select status from v$instance;

SQL> select name from v$controlfile;

SQL> select name from v$datafile;

SQL> select member from v$logfile;
但此时还不能查询数据库文件，如表和视图。所以对于普通用户而言，这个时候数据库还是不可用的。只有等到经历了最后一步 打开数据库 之后，才能使用数据库
*在mount阶段我们可以：
*重命名数据文件，移动数据文件位置等
*启用或关闭重做日志文件的归档及非归档模式
*实现数据库的完全恢复

3 alter database open或startup
打开数据库 mount --> open
打开数据库时，实例将打开所有处于联机状态的数据文件和重做日志文件。

在此期间，Oracle 服务器将校验所有的数据文件和联机日志文件能否打开，并对数据库作一致性检查。

如果出现一致性错误，SMON 进程将启动实例恢复
如果任一数据文件或联机日志文件丢失，Oracle 服务器将报错
只有将数据库设置为打开状态后，数据库才处于正常状态，这时普通用户才能够访问数据库。

4 startup restrict
限制模式下打开数据库。可以做的操作包括 数据import/export,  data load(with SQL*Loader),暂时禁用用户访问数据，执行迁移、升级操作

关闭数据库
与启动数据库顺序相反，也分三个步骤：
CLOSE 关闭数据库（关闭数据文件）
DISMOUNT 卸载数据库（关闭控制文件）
SHUTDOWN 关闭 Oracle 实例
关闭模式
1）shutdown NORMAL
//缺省值，与shutdown效果相同，等所有用户写入完毕后，退出数据库并关闭
2）shutdown IMMEDIATE
//回滚未提交所有事务操作，退出数据库并关闭；较常用
3）shutdown TRANSCACTION
//等待所有用户操作完毕后，再退出据库并关闭；一般用于定期关闭数据库
4）shutdown ABORT
//强制断开所有用户，数据全部不保存，会造成数据丢失，一般不建议使用

数据库关闭阶段做的工作：
终止所有会话
PMON进程回滚活动的事务
通过DBWn进程将已完成的事务转储至磁盘
LGWR进程将内存中的所有变更向量转储只redo log文件
同时关闭数据文件和重做日志文件(更新文件头，关闭文件句柄)
在数据库卸载阶段关闭控制文件
随后，通过解除分配SGA和终止后台进程，停止实例

数据库出现损坏的定义：
可能丢失了已提交的事务
也可能存储了未提交的事务

SYS@poc1> shutdown immediate;
Database closed.
Database dismounted.
ORACLE instance shut down.
SYS@poc1> @$ORACLE_HOME/mode.sql;
select a.thread#,b.open_mode,a.status,
*
ERROR at line 1:
ORA-01034: ORACLE not available                            # 状态
Process ID: 2899
Session ID: 923 Serial number: 2899


SYS@poc1> startup nomount;
ORACLE instance started.

Total System Global Area 4275781632 bytes
Fixed Size                  2260088 bytes
Variable Size            1107297160 bytes
Database Buffers         3154116608 bytes
Redo Buffers               12107776 bytes
SYS@poc1> @$ORACLE_HOME/mode.sql;
FROM v$thread a,
     *
ERROR at line 8:
ORA-01507: database not mounted                              # 状态


SYS@poc1> startup mount;
ORA-01081: cannot start already-running ORACLE - shut it down first
SYS@poc1> alter database mount;

Database altered.

SYS@poc1> @$ORACLE_HOME/mode.sql;

   THREAD# OPEN_MODE            STATUS STATUS
---------- -------------------- ------ ----------------------
         1 MOUNTED              CLOSED NO Crash Recovery req.             # 状态

SYS@poc1> alter database open;

Database altered.

SYS@poc1> @$ORACLE_HOME/mode.sql;

   THREAD# OPEN_MODE            STATUS STATUS
---------- -------------------- ------ ----------------------
         1 READ WRITE           OPEN   Instance already open.              # 状态
SYS@poc1> startup restrict;
ORACLE instance started.

Total System Global Area 4275781632 bytes
Fixed Size                  2260088 bytes
Variable Size            1107297160 bytes
Database Buffers         3154116608 bytes
Redo Buffers               12107776 bytes
Database mounted.
Database opened.
SYS@poc1> @$ORACLE_HOME/mode.sql;

   THREAD# OPEN_MODE            STATUS STATUS
---------- -------------------- ------ ----------------------
         1 READ WRITE           OPEN   Instance already open.                # 状态

SYS@poc1> shutdown abort;
ORACLE instance shut down.
SYS@poc1> startup mount;
ORACLE instance started.

Total System Global Area 4275781632 bytes
Fixed Size                  2260088 bytes
Variable Size            1107297160 bytes
Database Buffers         3154116608 bytes
Redo Buffers               12107776 bytes
Database mounted.
SYS@poc1> @$ORACLE_HOME/mode.sql;

   THREAD# OPEN_MODE            STATUS STATUS
---------- -------------------- ------ ----------------------
         1 MOUNTED              OPEN   Crash Recovery req.
SYS@poc1> alter database open;

Database altered.

SYS@poc1> @$ORACLE_HOME/mode.sql;

   THREAD# OPEN_MODE            STATUS STATUS
---------- -------------------- ------ ----------------------
         1 READ WRITE           OPEN   Instance already open.

[oracle@ora6 dbhome_1]$ cat -n mode.sql
     1  select a.thread#,b.open_mode,a.status,
     2  CASE
     3  WHEN((b.open_mode='MOUNTED') AND (a.status='OPEN')) THEN 'Crash Recovery req.'
     4  WHEN((b.open_mode='MOUNTED') AND (a.status='CLOSED')) THEN 'NO Crash Recovery req.'
     5  WHEN((b.open_mode='READ WRITE') AND (a.status='OPEN')) THEN 'Instance already open.'
     6  ELSE 'hub?'
     7  END STATUS
     8  FROM v$thread a,
     9  v$database b,
    10  v$instance c
    11  where a.thread#=c.thread#;



####启用archivelog
更改archivelog路径
SQL> alter system set log_archive_dest_1='location=/data/arch';
SQL> shutdown immediate;
SQL> startup mount
SQL> alter database archivelog;
SQL> alter database open;
SQL> archive log list;
Database log mode              Archive Mode
Automatic archival             Enabled
Archive destination            /data/arch
Oldest online log sequence     9
Next log sequence to archive   11
Current log sequence           11
SQL> ! ls /data/arch

SQL> alter system archive log current;

System altered.

SQL> ! ls /data/arch
1_11_1050509836.dbf

SQL> select name from v$archived_log;

NAME
-------------------------------
/data/arch/1_11_1050509836.dbf

SQL> archive log list;
Database log mode              Archive Mode
Automatic archival             Enabled
Archive destination            /data/arch
Oldest online log sequence     10
Next log sequence to archive   12
Current log sequence           12


####手工热备份  前提 启用archivelog
SQL> alter tablespace HOK begin backup;
Tablespace altered.

SQL> ! cp /data/oradata/CHENSEN/datafile/HOK_DATA01.DBF /data/bkdata/HOK_DATA01.DBF

SQL> alter tablespace HOK end backup;

Tablespace altered.

SQL> ! rm -f /data/oradata/CHENSEN/datafile/HOK_DATA01.DBF

SQL> shutdown immediate;
Database closed.
Database dismounted.
ORACLE instance shut down.
SQL> startup
ORACLE instance started.

Total System Global Area 3991842816 bytes
Fixed Size                  2259400 bytes
Variable Size            1056966200 bytes
Database Buffers         2919235584 bytes
Redo Buffers               13381632 bytes
Database mounted.
ORA-01157: cannot identify/lock data file 5 - see DBWR trace file
ORA-01110: data file 5: '/data/oradata/CHENSEN/datafile/HOK_DATA01.DBF'

SQL> ! cp /data/bkdata/HOK_DATA01.DBF /data/oradata/CHENSEN/datafile/HOK_DATA01.DBF

SQL> alter database open;
alter database open
*
ERROR at line 1:
ORA-01113: file 5 needs media recovery
ORA-01110: data file 5: '/data/oradata/CHENSEN/datafile/HOK_DATA01.DBF'

SQL> recover datafile 5;
Media recovery complete.
SQL> alter database open;

Database altered.
SQL> select * from CHENSEN.player;

ID                   NAME                 LEVEL_TYPE
-------------------- -------------------- --------------------
1                    chensen              qingtong
2                    chenlin              zuanshi

########### redo log
# 更改redo log 大小为200m
alter database drop logfile group 1;
alter database add logfile group 1 ('/data/oradata/CHENSEN/onlinelog/redo01.log') size 200m reuse;
alter system switch logfile;
alter database drop logfile group 3;
alter database add logfile group 3 ('/data/oradata/CHENSEN/onlinelog/redo03.log') size 200m reuse;
alter system switch logfile;
alter database drop logfile group 2;
select * from v$log;
alter database add logfile group 2 ('/data/oradata/CHENSEN/onlinelog/redo02.log') size 200m reuse;
select * from v$log;
alter system switch logfile;
# 添加redo log group member
alter database add logfile member '/data/oradata/CHENSEN/onlinelog/redo01_1.log' to group 1;
alter database add logfile member '/data/oradata/CHENSEN/onlinelog/redo01_2.log' to group 2;
alter database add logfile member '/data/oradata/CHENSEN/onlinelog/redo01_3.log' to group 3;

#redo log改名
shutdown immediate;
! mv /data/oradata/CHENSEN/onlinelog/redo01_2.log /data/oradata/CHENSEN/onlinelog/redo02_1.log
! mv /data/oradata/CHENSEN/onlinelog/redo01_3.log /data/oradata/CHENSEN/onlinelog/redo03_1.log
! ls -lh /data/oradata/CHENSEN/onlinelog
startup mount
alter database rename file '/data/oradata/CHENSEN/onlinelog/redo01_2.log' to '/data/oradata/CHENSEN/onlinelog/redo02_1.log';
alter database rename file '/data/oradata/CHENSEN/onlinelog/redo01_3.log' to '/data/oradata/CHENSEN/onlinelog/redo03_1.log';
alter database open;
select * from v$logfile;

#redo log在线迁移
添加新的redo log组
删除旧的日志组

# redo log损坏或丢失
SQL> shutdown immediate
SQL> startup mount
SQL> recover database until cancel;
SQL> alter database open resetlogs;



######### redo log and undo log ############
重做日志文件（redo log file）对数据库来说至关重要，他们是数据库的事务日志；

Oracle数据库维护着两类重做日志文件：在线重做日志文件（redo）和 归档重做日志文件（archive log），（归档重做日志文件实际上就是已填满的“旧”在线重做日志文件的副本）

这两类重做日志文件都是用于恢复的：

①：如果数据库所在主机掉电，导致实例失败，Oracle会使用在线重做日志将系统恢复到恰好在掉电之前的那个提交点；

②：如果磁盘驱动器出现故障（这是介质失败），Oracle会使用归档重做日志以及在线重做日志，以及之前的一个备份，将原在此驱动器上的数据恢复到某个时间点；

Redo log的日志状态分为4种：

current:指的是当前日志文件，该日志文件是活动的，当前正在被使用的，进行崩溃恢复时，Current日志文件是必须的；

ACTIVE：是活动的非当前日志，可以已经完成归档也可能没有归档，在Crash恢复时会被用到；

inactive：非活动日志，在实例恢复时不再需要，但是在介质恢复时可能会用到，此状态的日志也可能没有被归档。

unused：该日志从未被写入，这类日志可能是刚被添加到数据库或者在resetlogs之后被重置。 

Crash recovery has two pahses : rollforward and rollback

The system monitor will first roll forward and apply to the datafiles any transactions in the online redo files that occured after the most recent checkpoint.
 Crash Recovery uses redo information found in the online redo log files only . After rolling forward, Oracle will rollback any of those transactions that were never committed.
 Oracle uses information stored in the undo segments to rollback (undo) any uncommitted transactions.
 

########### oracle进程 ####################
一、 DBWn
DBWn按极懒算法执行写入：尽可能少，但出现(完全)检查点的情况例外，将所有脏缓冲区尽快写入磁盘。
以下几种情况执行写操作
增量检查点：  将有限数量的脏缓冲区写入数据文件
1 没有任何可用缓冲区
2 脏缓冲区数量过多
3 遇到三秒超时
4 请求的检查点（完全检查点）  将所有的脏缓冲区写入数据文件   - 可能影响性能
局部检查点，强制DBWn写入仅包含一个或多个数据文件的块的所有脏缓冲区
如：
数据文件或表空间脱机时，
在将表空间置入备份模式时
在将表空间设置为只读时
二、 LGWR
以下几种情况执行写操作
1.用户进程提交一个事务（Commit）
2.日志缓冲区达到1/3范围，或者包含了1MB的缓存重做日志数据
3.要求LGWR切换日志文件
4.出现超时（3秒钟内未活动，则进行一次写操作。）
5.DBWR需要写入的数据的SCN号大于LGWR 记录的SCN号，DBWR 触发LGWR写入

RBA （redo block address）online redo log的重做块地址
ckpt进程还会在控制文件当中记录RBA，这个地址用来标志实例恢复的时候需要从日志中的那个位置开始，也就是一个checkpoint对应一个rba，
当instance recovery（实例恢复）的时候oracle就会知道从那个检查点开始在redo的那个rba开始介质恢复！

三、CKPT
分类：
1 Full Checkpoint
Writes block images to the database for all dirty buffers from all instances

Statistics updated:
DBWR checkpoints
DBWR checkpoint buffers written
DBWR thread checkpoint buffers written

Caused by:
Alter system checkpoint [global]
Alter database begin backup
Alter database close
Shutdown

Controlfile and datafile headers are updated
CHECKPOINT_CHANGE#

2 Thread Checkpoint
Writes block images to the database for all dirty buffers from one instance

Statistics updated:
DBWR checkpoints
DBWR checkpoint buffers written
DBWR thread checkpoint buffers written

Caused by:
Alter system checkpoint local

Controlfile and datafile headers are updated
CHECKPOINT_CHANGE#

3 File Checkpoint
Writes block images to the database for all dirty buffers for all files of a tablespace from all instances
Statistics updated:

DBWR tablespace checkpoint buffers written
DBWR checkpoint buffers written
DBWR checkpoints

Caused by:

Alter tablespace XXX offline
Alter tablespace XXX begin backup
Alter tablespace XXX read only

Controlfile and datafile headers are updated
CHECKPOINT_CHANGE#

4 Parallel Query Checkpoint
Writes block images to the database for all dirty buffers belonging to objects accessed by the query from all instances

Statistics updated:
DBWR checkpoint buffers written
DBWR checkpoints

Caused by:
Parallel Query
Parallel Query component of PDML or PDDL
Mandatory for consistency

5 Object “Checkpoint”
Writes block images to the database for all dirty buffers belonging to an object from all instances

Statistics updated:

DBWR object drop buffers written
DBWR checkpoints

Caused by:
Drop table XXX
Drop table XXX purge
Truncate table XXX
Mandatory for media recovery purposes

6 Incremental Checkpoint
Writes the contents of “some” dirty buffers to the database from CKPT-Q
Block images written in SCN order
Checkpoint RBA updated in SGA

Statistics updated:
DBWR checkpoint buffers written

Controlfile is updated every 3 seconds by CKPT
Checkpoint progress record

7 Log Switch Checkpoint(8i 以前 LOG switch checkpoint是FULL CHECKPOINT)
Writes the contents of “some” dirty buffers to the database

Statistics updated:

DBWR checkpoints
DBWR checkpoint buffers written
background checkpoints started
background checkpoints completed

Controlfile and datafile headers are updated
CHECKPOINT_CHANGE#
######### oracle 表空间  ########
表空间的分类
永久表空间                存放永久性数据，如表，索引等。
临时表空间                不能存放永久性对象，用于保存数据库排序，分组时产生的临时数据。
UNDO表空间             保存数据修改前的镜象。
Temp 表空间必须是 uniform 的， undo 必须是 autoallocate 的


表空间的管理方式：
字典管理：全库所有的空间分配都放在数据字典中。容易引起字典争用，而导致性能问题。
使用数据字典管理存储空间的分配, 当表空间分配新的区, 或者回收已分配的区时, ORACLE会对数据字典对应的表进行查询、更新, 且使用单线程, 速度慢, 并且产生回退和重做信息。
本地管理：空间分配不放在数据字典，而在每个数据文件头部的第3到第8个块的位图块，来管理空间分配。
优点:  a) 提高存储管理的速度和并发性。 b) 不产生磁盘碎片。 c) 不产生递归管理。 d) 没有系统回滚段。

表空间状态有下面几种状态：online、offline、read only、read write。

表空间改名
在ORACLE 10g 之前，表空间的名称是不能被修改的。在ORACLE 11G中，通过ALTER TABLESPACE 语句中使用RENAME子句，数据库管理员可以修改表空间的名称。

# 缩小临时表空间
SQL> select * from dba_temp_free_space;

TABLESPACE_NAME                TABLESPACE_SIZE ALLOCATED_SPACE FREE_SPACE
------------------------------ --------------- --------------- ----------
TMP2                                 104857600         2097152  103809024
TEMP                                  20971520        11534336   19922944

SQL> alter tablespace tmp2 shrink space keep 20M;

Tablespace altered.

SQL> select * from dba_temp_free_space;

TABLESPACE_NAME                TABLESPACE_SIZE ALLOCATED_SPACE FREE_SPACE
------------------------------ --------------- --------------- ----------
TMP2                                  20971520         1048576   19922944
TEMP                                  20971520        11534336   19922944


# 临时表空间组
默认临时表空间只有一个
可以设置组包括多个临时表空间
SQL> select group_name,tablespace_name from dba_tablespace_groups;          # 没有组

no rows selected

SQL> alter tablespace temp tablespace group tmpgrp;                         # 用alter tablespace创建临时表空间组,也可以在创建临时表空间时指定组

Tablespace altered.

SQL> select property_name,property_value from database_properties
  2  where property_name='DEFAULT_TEMP_TABLESPACE';

PROPERTY_NAME
------------------------------
PROPERTY_VALUE
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
DEFAULT_TEMP_TABLESPACE
TEMP                                                                        # 默认临时表空间 TEMP

SQL> alter database default temporary tablespace tmpgrp;                     # 更改默认临时表空间为 TMPGRP

Database altered.

SQL> select property_name,property_value from database_properties
  2  where property_name='DEFAULT_TEMP_TABLESPACE';

PROPERTY_NAME
------------------------------
PROPERTY_VALUE
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
DEFAULT_TEMP_TABLESPACE
TMPGRP                                                                     # 默认临时表空间 TMPGRP



SQL> select group_name,tablespace_name from dba_tablespace_groups;          # 组有一个临时表空间

GROUP_NAME                     TABLESPACE_NAME
------------------------------ ------------------------------
TMPGRP                         TEMP


SQL> create temporary tablespace tmp2;                                     # 增加一个临时表空间 tmp2

Tablespace created.

SQL> select * from v$tempfile;

     FILE# CREATION_CHANGE# CREATION_        TS#     RFILE# STATUS  ENABLED         BYTES     BLOCKS CREATE_BYTES BLOCK_SIZE NAME
---------- ---------------- --------- ---------- ---------- ------- ---------- ---------- ---------- ------------ ---------- ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
         1           925770 07-SEP-20          3          1 ONLINE  READ WRITE   20971520       2560     20971520       8192 /data/oradata/CHENSEN/datafile/o1_mf_temp_hth4w51j_.tmp
         2         15875514 17-APR-21         11          1 ONLINE  READ WRITE  104857600      12800    104857600       8192 /data/oradata/CHENSEN/datafile/o1_mf_tmp2_j7o7lybj_.tmp

SQL> alter tablespace tmp2 tablespace group tmpgrp;                       # 将临时表空间tmp2放到tmpgrp组里

Tablespace altered.

SQL> select group_name,tablespace_name from dba_tablespace_groups;

GROUP_NAME                     TABLESPACE_NAME
------------------------------ ------------------------------
TMPGRP                         TEMP
TMPGRP                         TMP2

SQL> select username,temporary_tablespace from dba_users;                # 查看用户使用的临时表空间

USERNAME                       TEMPORARY_TABLESPACE
------------------------------ ------------------------------
CHENSEN                        TMPGRP
SCOTT                          TMPGRP
ORACLE_OCM                     TMPGRP
XS$NULL                        TMPGRP
MDDATA                         TMPGRP
DIP                            TMPGRP
APEX_PUBLIC_USER               TMPGRP
SPATIAL_CSW_ADMIN_USR          TMPGRP
SPATIAL_WFS_ADMIN_USR          TMPGRP
FLOWS_FILES                    TMPGRP
MDSYS                          TMPGRP
ORDSYS                         TMPGRP
EXFSYS                         TMPGRP
DBSNMP                         TMPGRP
WMSYS                          TMPGRP

######### oracle 段空间  ########
区间（Extent）是Oracle的最小空间分配单元，而Block是Oracle的最小IO操作单元，也就是说，
Oracle以区间为单位将空间分配给对象段，而段内则是以Block为单位进行空间使用和管理的。
管理方式
手动管理方式时（MSSM），Oracle是通过Freelist（一个单向链表）来管理段内的空间分配，此时只有HWM的说法；
自动管理方式（ASSM）时，Oracle是通过BITMAP来管理段内的空间分配，此时Oracle引入了LHWM（Low HWM，低高水位）的概念。

#########  oracle区    #######
由于区(extent)是ORACLE创建对象时的最小分配单元, 所以表空间的管理实际上就是针对于区间的管理。 
分配方式： 自动分配、统一尺寸
  create tablespace Think 
  datafile '/u01/app/oracle/oradata/orcl/think.dbf' size 100M
  autoextend on next 10M maxsize 4096M
  extent management local uniform size 256K
  segment space management auto;
  
  
对于任何DML操作来说，必须同时处理数据块和撤销块，并且还会生成重做数据。
ACID的A,C,I要求生成撤销数据，D则要求生成重做数据。  

############# 表分区  ##########
最简单的range分区
CREATE TABLE TEST_RANGE_PARTITION
      (    "EMPNO" NUMBER(4,0),
           "ENAME" VARCHAR2(10),
           "JOB" VARCHAR2(9),
           "MGR" NUMBER(4,0),
           "HIREDATE" DATE,
           "SAL" NUMBER(7,2),
           "COMM" NUMBER(7,2),
           "DEPTNO" NUMBER(2,0)
      )
     PARTITION BY RANGE ("SAL")
      (PARTITION "TEST_RANGE_SAL_01" VALUES LESS THAN (1000),
       PARTITION "TEST_RANGE_SAL_02" VALUES LESS THAN (2000),
       PARTITION "TEST_RANGE_SAL_03" VALUES LESS THAN (3000),
       PARTITION "TEST_RANGE_SAL_MAX" VALUES LESS THAN (MAXVALUE)  
      );
SQL> insert into TEST_RANGE_PARTITION select * from emp;
SQL> select a.TABLE_NAME,PARTITIONING_TYPE,PARTITION_NAME,PARTITION_POSITION,HIGH_VALUE,NUM_ROWS from user_part_tables a,user_tab_partitions b where a.TABLE_NAME=b.TABLE_NAME and a.table_                                      name='TEST_RANGE_PARTITION';

TABLE_NAME                     PARTITION PARTITION_NAME                 PARTITION_POSITION HIGH_VALUE                                                                         NUM_ROWS
------------------------------ --------- ------------------------------ ------------------ -------------------------------------------------------------------------------- ----------
TEST_RANGE_PARTITION           RANGE     TEST_RANGE_SAL_01                               1 1000
TEST_RANGE_PARTITION           RANGE     TEST_RANGE_SAL_02                               2 2000
TEST_RANGE_PARTITION           RANGE     TEST_RANGE_SAL_03                               3 3000
TEST_RANGE_PARTITION           RANGE     TEST_RANGE_SAL_MAX                              4 MAXVALUE

SQL> analyze table TEST_RANGE_PARTITION compute statistics;

Table analyzed.

SQL> select a.TABLE_NAME,PARTITIONING_TYPE,PARTITION_NAME,PARTITION_POSITION,HIGH_VALUE,NUM_ROWS from user_part_tables a,user_tab_partitions b where a.TABLE_NAME=b.TABLE_NAME and a.table_                                      name='TEST_RANGE_PARTITION';

TABLE_NAME                     PARTITION PARTITION_NAME                 PARTITION_POSITION HIGH_VALUE                                                                         NUM_ROWS
------------------------------ --------- ------------------------------ ------------------ -------------------------------------------------------------------------------- ----------
TEST_RANGE_PARTITION           RANGE     TEST_RANGE_SAL_01                               1 1000                                                                                      2
TEST_RANGE_PARTITION           RANGE     TEST_RANGE_SAL_02                               2 2000                                                                                      6
TEST_RANGE_PARTITION           RANGE     TEST_RANGE_SAL_03                               3 3000                                                                                      3
TEST_RANGE_PARTITION           RANGE     TEST_RANGE_SAL_MAX                              4 MAXVALUE                                                                                  3

# alter table disable table lock
可以add 没有默认值的列，不可以modify, drop列及add有默认值的列
不可以drop table, rename table
-------------------------------------------------------
SQL> alter table PP disable table lock;

Table altered.

SQL> alter table PP add PNUMBER3 NUMBER(4);

Table altered.

SQL> alter table PP add PNUMBER5 NUMBER(5) default 1;
alter table PP add PNUMBER5 NUMBER(5) default 1
*
ERROR at line 1:
ORA-00069: cannot acquire lock -- table locks disabled for PP

SQL> alter table PP drop column PNUMBER4;
alter table PP drop column PNUMBER4
*
ERROR at line 1:
ORA-00069: cannot acquire lock -- table locks disabled for PP
SQL> rename PP to PPP;
rename PP to PPP
*
ERROR at line 1:
ORA-00069: cannot acquire lock -- table locks disabled for PP


SQL> drop table PP;
drop table PP
           *
ERROR at line 1:
ORA-00069: cannot acquire lock -- table locks disabled for PP

SQL> alter table PP modify PNUMBER4 NUMBER(5);
alter table PP modify PNUMBER4 NUMBER(5)
*
ERROR at line 1:
ORA-00069: cannot acquire lock -- table locks disabled for PP

--------------------------------------------------------------------

# 未使用的列
SQL> alter table CAILAMEI set unused column CREATED;

Table altered.

Elapsed: 00:00:00.13
SQL> select object_name,object_id from dba_objects where
  2  object_name='CAILAMEI';

OBJECT_NAME                                                                                                                       OBJECT_ID
-------------------------------------------------------------------------------------------------------------------------------- ----------
CAILAMEI                                                                                                                              87440

Elapsed: 00:00:00.04
SQL> select obj#,col#,name from sys.col$ where obj#='87440';

      OBJ#       COL# NAME
---------- ---------- ------------------------------
     87440          1 OWNER
     87440          2 OBJECT_NAME
     87440          3 SUBOBJECT_NAME
     87440          4 OBJECT_ID
     87440          5 DATA_OBJECT_ID
     87440          6 OBJECT_TYPE
     87440          0 SYS_C00007_21021810:44:24$
     87440          7 LAST_DDL_TIME
     87440          8 TIMESTAMP
     87440          9 STATUS
     87440         10 GENERATED
     87440         11 NAMESPACE
     87440          0 SYS_C00013_21021809:53:42$

13 rows selected.

Elapsed: 00:00:00.02
SQL> alter table CAILAMEI drop unused columns checkpoint 1000;

Table altered.

Elapsed: 00:00:03.29
SQL> select obj#,col#,name from sys.col$ where obj#='87440';

      OBJ#       COL# NAME
---------- ---------- ------------------------------
     87440          1 OWNER
     87440          2 OBJECT_NAME
     87440          3 SUBOBJECT_NAME
     87440          4 OBJECT_ID
     87440          5 DATA_OBJECT_ID
     87440          6 OBJECT_TYPE
     87440          7 LAST_DDL_TIME
     87440          8 TIMESTAMP
     87440          9 STATUS
     87440         10 GENERATED
     87440         11 NAMESPACE

# 全局临时表
临时表的定义对所有会话都是可见的，但表中的资料支队当前的会话或事务可见。
默认基于事务
基于会话的临时表
create global temporary table emp_tmp1 on commit preserve rows as select * from scott.emp;	 
基于事务的临时表
create global temporary table emp_tmp2 on commit delete rows as select * from scott.emp;	

# 外部表
datapump做驱动
SQL> create table emp_50
 organization external
 (
 type oracle_datapump
 default directory DATA_PUMP_DIR
 location('emp_50.dmp')
 )
 as select * from scott.emp;

sqloader做驱动
 create table emp_load3
  (e_lname char(20),
   e_fname char(20),
   hiredate date)
  organization external
  (type oracle_loader
  default directory DATA_PUMP_DIR
  access parameters
  (records delimited by newline
  fields terminated by ','
  (e_lname char(20),
   e_fname char(20),
   hiredate char(10) date_format DATE mask "mm/dd/yyyy"
           )
     )
   location ('emp.dat')
  );
 
 
#  子查询
什麼是非關聯子查詢
而子查詢也可以分成關聯子查詢和非關聯子查詢,  上面那條sql 語句就是非關聯子查詢.

所謂非關聯子查詢就是指子查詢可以脫離主查詢獨立執行.

再舉個例子:

我想找出每個部門中最高工資的人.

sql語句可以寫成如下:

select a.deptno,a.* from emp a
where (a.deptno, a.sal) in (select deptno, max(sal) from emp group by deptno)

其中的 子查詢
select deptno, max(sal) from emp group by deptno
是可以獨立執行的.

而且對於整個查詢來講, 是執行一次子查詢先, 再執行主查詢.

3. 什麼是關聯子查詢
所謂關聯子查詢就是指子查詢與主查詢之間有條件關聯,  不能獨自執行.

看回上面的需求, 我們換一種寫法:

select a.deptno, a.* from emp a
where a.sal = (select max(b.sal) from emp b where b.deptno =  a.deptno)
上面的例子就是用到關聯子查詢了,  其中的子查詢因為條件關聯了主查詢的表. 所以子查詢不能單獨執行.

對於關聯子查詢來講,  是自外到內的, 先執行外查詢,.

例如上面的例子,   對於主表a來間,  對於每1個deptno,  都要執行一次子查詢.

關聯子查詢還有1個限制, 就是子查詢不能返回多於1行的資料.

-- 集合運算注意事項
/*
   1.列的數量要一致
   2.列的型別要保持一致
   3.列的順序要一致

   如果不足,可以用null補齊
*/

You can combine multiple queries using the set operators UNION, UNION ALL, INTERSECT, and MINUS. All set operators have equal precedence.
 If a SQL statement contains multiple set operators, then Oracle Database evaluates them from the left to right unless parentheses explicitly specify another order.
The corresponding expressions in the select lists of the component queries of a compound query must match in number and must be in the same data type group (such as numeric or character).
If component queries select character data, then the data type of the return values are determined as follows:
If both queries select values of data type CHAR of equal length, then the returned values have data type CHAR of that length. If the queries select values of CHAR with 
different lengths, then the returned value is VARCHAR2 with the length of the larger CHAR value.
If either or both of the queries select values of data type VARCHAR2, then the returned values have data type VARCHAR2.
If component queries select numeric data, then the data type of the return values is determined by numeric precedence:
If any query selects values of type BINARY_DOUBLE, then the returned values have data type BINARY_DOUBLE.
If no query selects values of type BINARY_DOUBLE but any query selects values of type BINARY_FLOAT, then the returned values have data type BINARY_FLOAT.
If all queries select values of type NUMBER, then the returned values have data type NUMBER.
In queries using set operators, Oracle does not perform implicit conversion across data type groups. Therefore, if the corresponding expressions of component queries resolve to both character data and numeric data, Oracle returns an error.

Restrictions on the Set Operators 
The set operators are subject to the following restrictions:
The set operators are not valid on columns of type BLOB, CLOB, BFILE, VARRAY, or nested table.
The UNION, INTERSECT, and MINUS operators are not valid on LONG columns.
If the select list preceding the set operator contains an expression, then you must provide a column alias for the expression in order to refer to it in the order_by_clause.
You cannot also specify the for_update_clause with the set operators.
You cannot specify the order_by_clause in the subquery of these operators.
You cannot use these operators in SELECT statements containing TABLE collection expressions.


在oracle中：

1）where/group by/having子句中只能直接使用栏位或者常量，而不能使用栏位的别名，除非这个别名来自子查询之中，如：select .... from (select col1 ccc from table) where ccc > 1 
2）而order by 则可以直接使用别名，如select col1 ccc from table order by ccc 

这和sql 的执行顺序是有关的，where中的部分先执行 －> 如果有group by，接着执行group by －> select中的函数计算、别名指定再运行－> 最后order by 
因此，字段、表达式的别名在where子句和group by子句都是不能使用的，而在order by中不仅可以使用别名，甚至可以直接使用栏位的下标来进行排序，如：order by 1 desc,2 asc

# 同义词

object_name: 要创建同义词的对象，它可以是以下几种类型：

TABLE
VIEW
SEQUENCE
STORED PROCEDURE
FUNCTION
PACKAGE
MATERIALIZED VIEW
JAVA CLASS SCHEMA OBJECT
USER-DEFINED OBJECT
SYNONYM

# where 1=1
用于防止SQL语句出错，并且简化语句(不用做那么多判断)
# where 1<>1
用于使用另一张表的定义建表

###   read only模式
In read-only mode, the following operations are permitted on the table:

 Select
 Management indexes, constraints, supplemental log
 Dropping and deallocation of unused columns
 Renaming and moving of the table
 Altering the table for physical property changes, row movement, and shrinking the segment
 Drop table
The following operations are disabled on a table in read-only mode:

 DML on table or any table partitions
 Truncation of table
 Select for update
 Adding, removing, renaming, dropping, or setting a column to unused
 Dropping a partition or sub partition belonging to the table
 Online redefinition
 Flashback on the table
 
 
###   约束 
 A CONSTRAINT can be one of the following:
a column-level constraint
Column-level constraints refer to a single column in the table and do not specify a column name (except check constraints). They refer to the column that they follow.

a table-level constraint
Table-level constraints refer to one or more columns in the table. Table-level constraints specify the names of the columns to which they apply. Table-level CHECK constraints can refer to 0 or more columns in the table.

Column constraints include:
NOT NULL
Specifies that this column cannot hold NULL values (constraints of this type are not nameable).

PRIMARY KEY
Specifies the column that uniquely identifies a row in the table. The identified columns must be defined as NOT NULL.

Note: If you attempt to add a primary key using ALTER TABLE and any of the columns included in the primary key contain null values, an error will be generated and the primary key will not be added. See ALTER TABLE statement for more information.
UNIQUE
Specifies that values in the column must be unique.

FOREIGN KEY
Specifies that the values in the column must correspond to values in a referenced primary key or unique key column or that they are NULL.

CHECK
Specifies rules for values in the column.

Table constraints include:
PRIMARY KEY
Specifies the column or columns that uniquely identify a row in the table. NULL values are not allowed.

UNIQUE
Specifies that values in the columns must be unique.

FOREIGN KEY
Specifies that the values in the columns must correspond to values in referenced primary key or unique columns or that they are NULL.

Note: If the foreign key consists of multiple columns, and any column is NULL, the whole key is considered NULL. The insert is permitted no matter what is on the non-null columns.
CHECK
Specifies a wide range of rules for values in the table.

Column constraints and table constraints have the same function; the difference is in where you specify them. 
Table constraints allow you to specify more than one column in a PRIMARY KEY, UNIQUE, CHECK, or FOREIGN KEY constraint definition. 
 Column-level constraints (except for check constraints) refer to only one column.
 

######## Restrictions on the FOR UPDATE Clause 
This clause is subject to the following restrictions:

You cannot specify this clause with the following other constructs: the DISTINCT operator, CURSOR expression, set operators, group_by_clause, or aggregate functions.
The tables locked by this clause must all be located on the same database and on the same database as any LONG columns and sequences referenced in the same statement. 

######  self join
A self join uses other joins such as inner join and left join.


#   CLOB字段
union all不排序，可以查询clob字段， union排序，查询clob会出错
SQL> select * from test_clob where dbms_lob.instr(a,'VSAN')>0
  2  union all
  3  select * from test_clob where dbms_lob.instr(a,'XSPARAM_REG_SEQUENCE')>0;

A
--------------------------------------------------------------------------------
#!/bin/sh
# Script with a set of tool for vSAN troubleshooting
# Author: Jorluis

XSPARAM_REG_SEQUENCE$

SQL> select a from test_clob where dbms_lob.instr(a,'VSAN')>0
  2  union all
  3  select a from test_clob where dbms_lob.instr(a,'XSPARAM_REG_SEQUENCE')>0;

A
--------------------------------------------------------------------------------
#!/bin/sh
# Script with a set of tool for vSAN troubleshooting
# Author: Jorluis

XSPARAM_REG_SEQUENCE$

SQL> select a from test_clob where dbms_lob.instr(a,'VSAN')>0
  2  union
  3  select a from test_clob where dbms_lob.instr(a,'XSPARAM_REG_SEQUENCE')>0;
select a from test_clob where dbms_lob.instr(a,'VSAN')>0
       *
ERROR at line 1:
ORA-00932: inconsistent datatypes: expected - got CLOB

# 查询会话的时间格式
SELECT value
FROM   nls_session_parameters
WHERE  parameter = 'NLS_DATE_FORMAT'
# 查询数据库的时间格式
SELECT value
FROM   nls_database_parameters
WHERE  parameter = 'NLS_DATE_FORMAT'
#  日期和字符串的隐式转换
SQL> select ename,hiredate from scott.emp where hiredate<'28-SEP-81';

ENAME      HIREDATE
---------- ---------
SMITH      17-DEC-80
ALLEN      20-FEB-81
WARD       22-FEB-81
JONES      02-APR-81
BLAKE      01-MAY-81
CLARK      09-JUN-81
TURNER     08-SEP-81

7 rows selected.

SQL> select ename,hiredate from scott.emp where hiredate< to_date('28-SEP-81','DD-MON-RR');

ENAME      HIREDATE
---------- ---------
SMITH      17-DEC-80
ALLEN      20-FEB-81
WARD       22-FEB-81
JONES      02-APR-81
BLAKE      01-MAY-81
CLARK      09-JUN-81
TURNER     08-SEP-81

7 rows selected.

# Object Privileges
An object privilege is a privilege or right to perform a particular action on a specific table, view, sequence, procedure, function, or package. 
For example, the privilege to delete rows from the table DEPT is an object privilege. Depending on the type of object, there are different types of object privileges.

Some schema objects (such as clusters, indexes, triggers, and database links) do not have associated object privileges; their use is controlled with system privileges. 
For example, to alter a cluster, a user must own the cluster or have the ALTER ANY CLUSTER system privilege.

The Mechanisms of Roles
The functionality of database roles includes the following:
A role can be granted system or object privileges.
A role can be granted to other roles. However, a role cannot be granted to itself and cannot be granted circularly (for example, role A cannot be granted to role B if role B 
has previously been granted to role A).
Any role can be granted to any database user.
Each role granted to a user is, at a given time, either enabled or disabled. A user's security domain includes the privileges of all roles currently enabled for the user. 
A user's security domain does not include the privileges of any roles currently disabled for the user. Oracle allows database applications and users to enable and disable roles to
 provide selective availability of privileges.
An indirectly granted role (a role granted to a role) can be explicitly enabled or disabled for a user. However, by enabling a role that contains other roles, you implicitly enable
 all indirectly granted roles of the directly granted role.
从role_sys_privs中看ORACLE resource角色的权限
SQL> select PRIVILEGE from role_sys_privs where role='RESOURCE';  

# 数据字典相关权限
select_catalog_role      此角色授予数据字典视图的select权限 
execute_catalog_role     此角色授予数据字典视图的execute权限
delete_catalog_role      此角色允许用户从审计表(SYS.AUD$)删除记录
select any dictionary    此系统权限授予用户从sys模式的任何对象中选择数据的权限

#sysdba和sysoper的区别
sysdba可以create database,  sysoper不能

# shrink space
首先oracle shrink 是10g之后才引出的，有shrink table 和shrink space两种，这里介绍shrink space

压缩分两个阶段：
1、数据重组：这个过程是通过一系列的insert delete操作，将数据尽量排在列的前面进行重新组合。
2、HWM调整：这个过程是对HWM的调整，释放空闲数据库。
PS：shrink之前必须开启行移动功能
alter table table_name enable row movement;

基本语法：
alter table <table_name> shrink space [ <null> | cascade | compact  ];
--alter table <table_name> shrink space compact;
只收缩表，这个实际上是只执行了第一个阶段，HWM保持不变。

--alter table <table_name>  shrink space cascade;
收缩表并且相关索引也会被收缩，HWM会降低

--alter table <table_name> shrink space;
收缩表，降低HWM(High Water Mark)

限制条件：
1、不能对cluster、clustered  table 或者任何有LONG列的对象使用这个语句
2、压缩段不支持有函数索引、位图链接索引的表
3、这语句不能压缩二级索引表的映射表，即使设置了CASCADE
4、不能对压缩表使用该语句
5、不能压缩on commit 类型的物化视图的主表，rowid物化视图必须在压缩操作之后重建

不能实现收缩的表
        群集表
        具有LONG类型列的表
        LOB段(尽管表本身可以被缩小)，注，10gR2以后版本支持对LOB段的收缩
        具有基于提交的物化视图的表(因为禁用了触发器)
        具有rowid物化视图的表(因为rowid发生了变化)
        IOT映射表IOT溢出段
        索引基于函数的表
        未启用行记录转移的堆表

 
详解：
oracle10g开始提供shrink的命令，要求表空间是自动段空间管理（ASSM），降低HWM。 
segment shrink 分为两个阶段： 
1、数据重组（compact）：通过一系列insert、delete操作，将数据尽量排在段的前面，这个过程中需要在表上加RX锁，及只需要移动的行上加锁。由于涉及到rowid的改变，需要enable row movement。同时要distable基于rowid的triggers，这个过程对业务影响比较小（--由于采用compact，只有涉及移动的行才加锁，所以不会锁定整个表，其他的DML操作有部分可以进行，进而减小系统高峰期的性能开销）
 
2、HWM调整：第二阶段是调整HWM位置，释放空闲数据块，此过程需要在表上加X锁（独享锁，因此这个表都被锁定，如果系统处在高峰期的时候，其他在此表的DML被挂起，会产生严重阻塞），会造成表上所有DML语句阻塞，系统忙时影响较大，
锁的内容参考：http://docs.oracle.com/cd/B19306_01/server.102/b14220/consist.htm
 
shrink space语句两个阶段都执行
shrink space compact语句只执行第一个阶段。
在业务繁忙的时候，可以先执行shrink space compact重组数据，然后不满的时候执行shrink space降低HWM释放空闲数据块。
shrink必须开启对象的row movement功能（shrink index 不需要），alter table table_name enable row movement.但是要注意，该语句会造成引用table_name的对象（如存储过程、包、试图等）变为无效，执行完最好由utlrp.sql来编译无效对象。
shrink不会使表的索引失效。但是move会，因此，move后必须重建索引，（alter table table_name move;alter index index_name rebuild）
 
语法：
alter table shrink space[|cpmpact|cascade];
alter table shrink space compcat; 把块中的数据堆到一起，但会保持high water mark
alter table shrink space;收缩表，降低high water mark
alter table shrink space cascade;收缩表，降低high water mark，并相关索引也要收缩。
alter index indexname shrink space;收缩索引

补充：
--编译无效对象脚本utlrp.sql 

　　>$ sqlplus /no log
    SQL>connect sys/pwd@sid AS sysdba
    SQL>@?/rdbms/admin/utlrp.sql 

　　utlrp.sql脚本可以在数据库运行的状态下执行以编译、数据库中的invalid对象. 
　　oracle建议在对数据库进行迁移、升级、降级后都运行一遍utlrp.sql以编译无效对象。 

--打完patch后重建数据字典视图脚本catpatch.sql 

　　为了保证系统的的数据词典的完整性和有效性，最好的打patch后在migrate状态下运行catpatch.sql 
　　sql> shutdown immediate 
　　sql> startup migrate 
　　sql> @?/rdbms/admin/catpatch.sql 
　　sql> shutdown immediate 
　　sql> startup 

　　为加快速度，可临时调大这２个参数： 
　　show parameter shared_pool_size 
　　show parameter large_pool_size 

# 延迟段创建  sys用户不生效，默认会分配一个extend
普通用户生效

# dump logfile
SQL> alter system dump logfile '/data/oradata/CHENSEN/onlinelog/redo02.log';
select value from v$diag_info where name='Default Trace File';

# dump datafile的一个块
alter system dump datafile 1 block 100096;
select value from v$diag_info where name='Default Trace File';


# scheduler 高级
job包含program和schedule

window与schedule的比较
它们都允许制定作业的开始和结束时间以及重复时间间隔
但是window与resource plan能关联在一起
下面的例子window指定shcedule和resource plan做参数
SQL> BEGIN
     DMBS_SCHEDULER.CREATE_WINDOW(
	 WINDOW_NAME       => 'Test_Window',
	 SCHEDULE_NAME     => 'Test_Schedule',
	 RESOURCE_PLAN     => 'Test_ResourcePlan',
	 DURATION          => interval '180' minute,
	 COMMENTS          => 'Test Window');
	 END;
	 
创建基于CPU使用率的resource plan
plan都必须包含一条other_groups的指令
如果CPU使用率不到100%，那么这些计划将不起作用，只有当CPU
处理能力不足时，计划才会产生影响。
plan如下:
----------------------------
优先级       组       CPU%  |
1        SYS_GROUP    100   |
2        BATCH        100   |
3        DSS & OLTP   50    |
4        OTHER_GROUPS 100   |
-----------------------------
1 创建挂起区域，用于挂起plan
SQL> exec dbms_resource_manager.create_pending_area;
2 创建计划
SQL> exec dbms_resource_manager.create_plan(-
plan=>'DAY',comment=>'plan for normal working hours');
3 创建计划指令
SQL> exec dbms_resource_manager.crate_plan_directive(-
plan=>'DAY',group_or_subplan=>'SYS_GROUP',mgmt_pl=>100,-
comment=>'give sys_group users top priority');

SQL> exec dbms_resource_manager.crate_plan_directive(-
plan=>'DAY',group_or_subplan=>'OLTP',mgmt_p2=>100,-
comment=>'give oltp users next priority');

SQL> exec dbms_resource_manager.crate_plan_directive(-
plan=>'DAY',group_or_subplan=>'DSS',mgmt_p3=>50,-
comment=>'dss users have half at level 3');

SQL> exec dbms_resource_manager.crate_plan_directive(-
plan=>'DAY',group_or_subplan=>'BATCH',mgmt_p3=>50,-
comment=>'batch users have half at level 3');

SQL> exec dbms_resource_manager.crate_plan_directive(-
plan=>'DAY',group_or_subplan=>'OTHER_GROUPS',mgmt_p4=>100,-
comment=>'if there is anything left,others can have it');

4 验证挂起区域，如验证成功返回，讲计划保存到数据字典中：
SQL> exec dbms_resource_manager.validate_pending_area;
SQL> exec dbms_resource_manager.submit_pending_area;

5 激活计划：
SQL> alter system set resource_manager_plan=day;



SQL> col property_value for a40
SQL> select property_name,property_value from database_properties;

PROPERTY_NAME                  PROPERTY_VALUE
------------------------------ ----------------------------------------
DICT.BASE                      2
DEFAULT_TEMP_TABLESPACE        TMPGRP
DEFAULT_PERMANENT_TABLESPACE   USERS
DEFAULT_EDITION                ORA$BASE
Flashback Timestamp TimeZone   GMT
TDE_MASTER_KEY_ID
DST_UPGRADE_STATE              NONE
DST_PRIMARY_TT_VERSION         14
DST_SECONDARY_TT_VERSION       0
DEFAULT_TBS_TYPE               SMALLFILE
NLS_LANGUAGE                   AMERICAN
NLS_TERRITORY                  AMERICA
NLS_CURRENCY                   $
NLS_ISO_CURRENCY               AMERICA
NLS_NUMERIC_CHARACTERS         .,
NLS_CHARACTERSET               AL32UTF8
NLS_CALENDAR                   GREGORIAN
NLS_DATE_FORMAT                DD-MON-RR
NLS_DATE_LANGUAGE              AMERICAN
NLS_SORT                       BINARY
NLS_TIME_FORMAT                HH.MI.SSXFF AM
NLS_TIMESTAMP_FORMAT           DD-MON-RR HH.MI.SSXFF AM
NLS_TIME_TZ_FORMAT             HH.MI.SSXFF AM TZR
NLS_TIMESTAMP_TZ_FORMAT        DD-MON-RR HH.MI.SSXFF AM TZR
NLS_DUAL_CURRENCY              $
NLS_COMP                       BINARY
NLS_LENGTH_SEMANTICS           BYTE
NLS_NCHAR_CONV_EXCP            FALSE
NLS_NCHAR_CHARACTERSET         AL16UTF16
NLS_RDBMS_VERSION              11.2.0.4.0
GLOBAL_DB_NAME                 CHENSEN
EXPORT_VIEWS_VERSION           8
WORKLOAD_CAPTURE_MODE
WORKLOAD_REPLAY_MODE
NO_USERID_VERIFIER_SALT        61FE9A498A8FB6995B77028E02D6C276
DBTIMEZONE                     00:00



# 物化视图
物化視圖可以分為以下三種類型：包含聚集的物化視圖；只包含連接的物化視圖；嵌套物化視圖。
两种刷新方式
on commit,  on demand     默认on demand
四种刷新类型
complete, fast, force, never    默认force
查詢重寫(Query Rewrite)：包括ENABLE QUERY REWRITE和DISABLE QUERY REWRITE兩種。分別指出創建的物化視圖是否支持查詢重寫。
查詢重寫是指當對物化視圖的基表進行查詢時，Oracle會自動判斷能否通過查詢物化視圖來得到結果，如果可以，則避免了聚集或連接操作，
而直接從已經計算好的物化視圖中讀取數據。默認為DISABLE QUERY REWRITE。

创建MV的过程
授权给scott
SQL> grant create materialized view to scott;

Grant succeeded.

SQL> grant query rewrite to scott;

Grant succeeded.

创建MV LOG
SQL> create materialized view log on emp
  2  with sequence,rowid
  3  (empno,ename,sal,deptno)
  4  including new values;

Materialized view log created.

创建MV，默认是on demand
SQL> create materialized view emp_mv1 build immediate
    refresh fast
    enable query rewrite
    as select deptno,sum(sal) from emp where deptno in (20,30) group by deptno;

Materialized view created.

SQL> select * from emp_mv1;

    DEPTNO   SUM(SAL)
---------- ----------
        30       9400
        20      10875

SQL> insert into emp values(8000,'SAM','TECH',7566,'23-MAY-90',6000,500,20);

1 row created.
SQL> commit;

Commit complete.

SQL> select * from emp_mv1;             因为是on demand，没有自动刷新

    DEPTNO   SUM(SAL)
---------- ----------
        30       9400
        20      10875

手动刷新
SQL> begin
  2  dbms_mview.refresh(
  3  list => 'emp_mv1',
  4  Method => 'C',
  5  refresh_after_errors => True);
  6  end;
  7  /

PL/SQL procedure successfully completed.

SQL> select * from emp_mv1;

    DEPTNO   SUM(SAL)
---------- ----------
        30       9400
        20      16875
创建on commit的MV
SQL> create materialized view emp_mv2 build immediate
  2  refresh fast
  3  on commit
  4  enable query rewrite
  5  as select deptno,sum(sal) from emp where deptno in (20,30) group by deptno;

Materialized view created.

SQL> insert into emp values(9000,'LL','TECH',7566,'22-MAY-90',8000,1000,20);

1 row created.

SQL> commit;

Commit complete.

SQL> select * from emp_mv2;

    DEPTNO   SUM(SAL)
---------- ----------
        30       9400
        20      24875
創建定時刷新的物化視圖(指定物化視圖每天刷新一次)：
SQL> create materialized view mv_name refresh force on demand start with sysdate next sysdate+1;