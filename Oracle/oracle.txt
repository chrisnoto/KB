########### Oracle启动/关闭过程 ###############

启动模式
1 startup nomount
启动实例 shutdown --> nomount
总体来说，启动数据库实例包括以下操作：
读取参数文件 SPFILE
分配 SGA
启动后台进程
打开告警文件和跟踪文件

*nomount 状态不打开任何的控制文件及数据文件，所以我们可以在此阶段进行数据库创建、控制文件重建、特定的备份恢复等操作。
*nomount 状态下可以通过参数文件获得控制文件的位置，因为此时参数文件已经打开：
SQL> show parameter control_files;

2 alter database mount/startup mount
装载数据库 nomunt --> mount
3.3.1 装载数据库概述
装载数据库就是把数据库文件和实例关联起来，包括以下三个步骤：
Oracle根据参数文件 SPFILE 中的参数找到控制文件
打开控制文件
从控制文件获得数据字典和重做日志文件的名字及位置
完成以上三步，没有任何错误的情况下，Oracle 就已经把实例和数据库关联起来了。
装载数据库有两种方式：
一是直接启动数据库到 mount 状态：startup mount
二是如果数据库已经启动到 nomount 状态，使用 alter database mount 把数据库切换到mount 状态

我们就可以查询控制文件、数据文件和重做日志文件
SQL> select status from v$instance;

SQL> select name from v$controlfile;

SQL> select name from v$datafile;

SQL> select member from v$logfile;
但此时还不能查询数据库文件，如表和视图。所以对于普通用户而言，这个时候数据库还是不可用的。只有等到经历了最后一步 打开数据库 之后，才能使用数据库
*在mount阶段我们可以：
*重命名数据文件，移动数据文件位置等
*启用或关闭重做日志文件的归档及非归档模式
*实现数据库的完全恢复

3 alter database open或startup
打开数据库 mount --> open
打开数据库时，实例将打开所有处于联机状态的数据文件和重做日志文件。

在此期间，Oracle 服务器将校验所有的数据文件和联机日志文件能否打开，并对数据库作一致性检查。

如果出现一致性错误，SMON 进程将启动实例恢复
如果任一数据文件或联机日志文件丢失，Oracle 服务器将报错
只有将数据库设置为打开状态后，数据库才处于正常状态，这时普通用户才能够访问数据库。

4 startup restrict
限制模式下打开数据库。可以做的操作包括 数据import/export,  data load(with SQL*Loader),暂时禁用用户访问数据，执行迁移、升级操作

关闭数据库
与启动数据库顺序相反，也分三个步骤：
CLOSE 关闭数据库（关闭数据文件）
DISMOUNT 卸载数据库（关闭控制文件）
SHUTDOWN 关闭 Oracle 实例
关闭模式
1）shutdown NORMAL
//缺省值，与shutdown效果相同，等所有用户写入完毕后，退出数据库并关闭
2）shutdown IMMEDIATE
//回滚未提交所有事务操作，退出数据库并关闭；较常用
3）shutdown TRANSCACTION
//等待所有用户操作完毕后，再退出据库并关闭；一般用于定期关闭数据库
4）shutdown ABORT
//强制断开所有用户，数据全部不保存，会造成数据丢失，一般不建议使用

数据库关闭阶段做的工作：
终止所有会话
PMON进程回滚活动的事务
通过DBWn进程将已完成的失误转储至磁盘
LGWR进程将内存中的所有变更向量转储只redo log文件
同时关闭数据文件和重做日志文件(更新文件头，关闭文件句柄)
在数据库卸载阶段关闭控制文件
随后，通过解除分配SGA和终止后台进程，停止实例

数据库出现损坏的定义：
可能丢失了已提交的事务
也可能存储了未提交的事务

SYS@poc1> shutdown immediate;
Database closed.
Database dismounted.
ORACLE instance shut down.
SYS@poc1> @$ORACLE_HOME/mode.sql;
select a.thread#,b.open_mode,a.status,
*
ERROR at line 1:
ORA-01034: ORACLE not available                            # 状态
Process ID: 2899
Session ID: 923 Serial number: 2899


SYS@poc1> startup nomount;
ORACLE instance started.

Total System Global Area 4275781632 bytes
Fixed Size                  2260088 bytes
Variable Size            1107297160 bytes
Database Buffers         3154116608 bytes
Redo Buffers               12107776 bytes
SYS@poc1> @$ORACLE_HOME/mode.sql;
FROM v$thread a,
     *
ERROR at line 8:
ORA-01507: database not mounted                              # 状态


SYS@poc1> startup mount;
ORA-01081: cannot start already-running ORACLE - shut it down first
SYS@poc1> alter database mount;

Database altered.

SYS@poc1> @$ORACLE_HOME/mode.sql;

   THREAD# OPEN_MODE            STATUS STATUS
---------- -------------------- ------ ----------------------
         1 MOUNTED              CLOSED NO Crash Recovery req.             # 状态

SYS@poc1> alter database open;

Database altered.

SYS@poc1> @$ORACLE_HOME/mode.sql;

   THREAD# OPEN_MODE            STATUS STATUS
---------- -------------------- ------ ----------------------
         1 READ WRITE           OPEN   Instance already open.              # 状态
SYS@poc1> startup restrict;
ORACLE instance started.

Total System Global Area 4275781632 bytes
Fixed Size                  2260088 bytes
Variable Size            1107297160 bytes
Database Buffers         3154116608 bytes
Redo Buffers               12107776 bytes
Database mounted.
Database opened.
SYS@poc1> @$ORACLE_HOME/mode.sql;

   THREAD# OPEN_MODE            STATUS STATUS
---------- -------------------- ------ ----------------------
         1 READ WRITE           OPEN   Instance already open.                # 状态

SYS@poc1> shutdown abort;
ORACLE instance shut down.
SYS@poc1> startup mount;
ORACLE instance started.

Total System Global Area 4275781632 bytes
Fixed Size                  2260088 bytes
Variable Size            1107297160 bytes
Database Buffers         3154116608 bytes
Redo Buffers               12107776 bytes
Database mounted.
SYS@poc1> @$ORACLE_HOME/mode.sql;

   THREAD# OPEN_MODE            STATUS STATUS
---------- -------------------- ------ ----------------------
         1 MOUNTED              OPEN   Crash Recovery req.
SYS@poc1> alter database open;

Database altered.

SYS@poc1> @$ORACLE_HOME/mode.sql;

   THREAD# OPEN_MODE            STATUS STATUS
---------- -------------------- ------ ----------------------
         1 READ WRITE           OPEN   Instance already open.

[oracle@ora6 dbhome_1]$ cat -n mode.sql
     1  select a.thread#,b.open_mode,a.status,
     2  CASE
     3  WHEN((b.open_mode='MOUNTED') AND (a.status='OPEN')) THEN 'Crash Recovery req.'
     4  WHEN((b.open_mode='MOUNTED') AND (a.status='CLOSED')) THEN 'NO Crash Recovery req.'
     5  WHEN((b.open_mode='READ WRITE') AND (a.status='OPEN')) THEN 'Instance already open.'
     6  ELSE 'hub?'
     7  END STATUS
     8  FROM v$thread a,
     9  v$database b,
    10  v$instance c
    11  where a.thread#=c.thread#;



####启用archivelog
更改archivelog路径
SQL> alter system set log_archive_dest_1='location=/data/arch';
SQL> shutdown immediate;
SQL> startup mount
SQL> alter database archivelog;
SQL> alter database open;
SQL> archive log list;
Database log mode              Archive Mode
Automatic archival             Enabled
Archive destination            /data/arch
Oldest online log sequence     9
Next log sequence to archive   11
Current log sequence           11
SQL> ! ls /data/arch

SQL> alter system archive log current;

System altered.

SQL> ! ls /data/arch
1_11_1050509836.dbf

SQL> select name from v$archived_log;

NAME
-------------------------------
/data/arch/1_11_1050509836.dbf

SQL> archive log list;
Database log mode              Archive Mode
Automatic archival             Enabled
Archive destination            /data/arch
Oldest online log sequence     10
Next log sequence to archive   12
Current log sequence           12


####手工热备份  前提 启用archivelog
SQL> alter tablespace HOK begin backup;
Tablespace altered.

SQL> ! cp /data/oradata/CHENSEN/datafile/HOK_DATA01.DBF /data/bkdata/HOK_DATA01.DBF

SQL> alter tablespace HOK end backup;

Tablespace altered.

SQL> ! rm -f /data/oradata/CHENSEN/datafile/HOK_DATA01.DBF

SQL> shutdown immediate;
Database closed.
Database dismounted.
ORACLE instance shut down.
SQL> startup
ORACLE instance started.

Total System Global Area 3991842816 bytes
Fixed Size                  2259400 bytes
Variable Size            1056966200 bytes
Database Buffers         2919235584 bytes
Redo Buffers               13381632 bytes
Database mounted.
ORA-01157: cannot identify/lock data file 5 - see DBWR trace file
ORA-01110: data file 5: '/data/oradata/CHENSEN/datafile/HOK_DATA01.DBF'

SQL> ! cp /data/bkdata/HOK_DATA01.DBF /data/oradata/CHENSEN/datafile/HOK_DATA01.DBF

SQL> alter database open;
alter database open
*
ERROR at line 1:
ORA-01113: file 5 needs media recovery
ORA-01110: data file 5: '/data/oradata/CHENSEN/datafile/HOK_DATA01.DBF'

SQL> recover datafile 5;
Media recovery complete.
SQL> alter database open;

Database altered.
SQL> select * from CHENSEN.player;

ID                   NAME                 LEVEL_TYPE
-------------------- -------------------- --------------------
1                    chensen              qingtong
2                    chenlin              zuanshi

########### redo log
# 更改redo log 大小为200m
alter database drop logfile group 1;
alter database add logfile group 1 ('/data/oradata/CHENSEN/onlinelog/redo01.log') size 200m reuse;
alter system switch logfile;
alter database drop logfile group 3;
alter database add logfile group 3 ('/data/oradata/CHENSEN/onlinelog/redo03.log') size 200m reuse;
alter system switch logfile;
alter database drop logfile group 2;
select * from v$log;
alter database add logfile group 2 ('/data/oradata/CHENSEN/onlinelog/redo02.log') size 200m reuse;
select * from v$log;
alter system switch logfile;
# 添加redo log group member
alter database add logfile member '/data/oradata/CHENSEN/onlinelog/redo01_1.log' to group 1;
alter database add logfile member '/data/oradata/CHENSEN/onlinelog/redo01_2.log' to group 2;
alter database add logfile member '/data/oradata/CHENSEN/onlinelog/redo01_3.log' to group 3;

#redo log改名
shutdown immediate;
! mv /data/oradata/CHENSEN/onlinelog/redo01_2.log /data/oradata/CHENSEN/onlinelog/redo02_1.log
! mv /data/oradata/CHENSEN/onlinelog/redo01_3.log /data/oradata/CHENSEN/onlinelog/redo03_1.log
! ls -lh /data/oradata/CHENSEN/onlinelog
startup mount
alter database rename file '/data/oradata/CHENSEN/onlinelog/redo01_2.log' to '/data/oradata/CHENSEN/onlinelog/redo02_1.log';
alter database rename file '/data/oradata/CHENSEN/onlinelog/redo01_3.log' to '/data/oradata/CHENSEN/onlinelog/redo03_1.log';
alter database open;
select * from v$logfile;

#redo log在线迁移
添加新的redo log组
删除旧的日志组

# redo log损坏或丢失
SQL> shutdown immediate
SQL> startup mount
SQL> recover database until cancel;
SQL> alter database open resetlogs;



######### redo log and undo log ############
重做日志文件（redo log file）对数据库来说至关重要，他们是数据库的事务日志；

Oracle数据库维护着两类重做日志文件：在线重做日志文件（redo）和 归档重做日志文件（archive log），（归档重做日志文件实际上就是已填满的“旧”在线重做日志文件的副本）

这两类重做日志文件都是用于恢复的：

①：如果数据库所在主机掉电，导致实例失败，Oracle会使用在线重做日志将系统恢复到恰好在掉电之前的那个提交点；

②：如果磁盘驱动器出现故障（这是介质失败），Oracle会使用归档重做日志以及在线重做日志，以及之前的一个备份，将原在此驱动器上的数据恢复到某个时间点；

Redo log的日志状态分为4种：

current:指的是当前日志文件，该日志文件是活动的，当前正在被使用的，进行崩溃恢复时，Current日志文件是必须的；

ACTIVE：是活动的非当前日志，可以已经完成归档也可能没有归档，在Crash恢复时会被用到；

inactive：非活动日志，在实例恢复时不再需要，但是在介质恢复时可能会用到，此状态的日志也可能没有被归档。

unused：该日志从未被写入，这类日志可能是刚被添加到数据库或者在resetlogs之后被重置。 

Crash recovery has two pahses : rollforward and rollback

The system monitor will first roll forward and apply to the datafiles any transactions in the online redo files that occured after the most recent checkpoint.
 Crash Recovery uses redo information found in the online redo log files onlu . After rolling forward, Oracle will rollback any of those transactions that were never committed.
 Oracle uses information stored in the undo segments to rollback (undo) any uncommitted transactions.
 

########### oracle进程 ####################
一、 DBWn
DBWn按极懒算法执行写入：尽可能少，但出现(完全)检查点的情况例外，将所有脏缓冲区尽快写入磁盘。
以下几种情况执行写操作
增量检查点：  将有限数量的脏缓冲区写入数据文件
1 没有任何可用缓冲区
2 脏缓冲区数量过多
3 遇到三秒超时
4 请求的检查点（完全检查点）  将所有的脏缓冲区写入数据文件   - 可能影响性能
局部检查点，强制DBWn写入仅包含一个或多个数据文件的块的所有脏缓冲区
如：
数据文件或表空间脱机时，
在将表空间置入备份模式时
在将表空间设置为只读时
二、 LGWR
以下几种情况执行写操作
1.用户进程提交一个事务（Commit）
2.日志缓冲区达到1/3范围，或者包含了1MB的缓存重做日志数据
3.要求LGWR切换日志文件
4.出现超时（3秒钟内未活动，则进行一次写操作。）
5.DBWR需要写入的数据的SCN号大于LGWR 记录的SCN号，DBWR 触发LGWR写入

RBA （redo block address）onlin redo log的重做块地址
ckpt进程还会在控制文件当中记录RBA，这个地址用来标志实例恢复的时候需要从日志中的那个位置开始，也就是一个checkpoint对应一个rba，
当instance recovery（实例恢复）的时候oracle就会知道从那个检查点开始在redo的那个rba开始介质恢复！