########### Oracle启动/关闭过程 ###############

启动模式
1 startup nomount
启动实例 shutdown --> nomount
总体来说，启动数据库实例包括以下操作：
读取参数文件 SPFILE
分配 SGA
启动后台进程
打开告警文件和跟踪文件

*nomount 状态不打开任何的控制文件及数据文件，所以我们可以在此阶段进行数据库创建、控制文件重建、特定的备份恢复等操作。
*nomount 状态下可以通过参数文件获得控制文件的位置，因为此时参数文件已经打开：
SQL> show parameter control_files;

2 alter database mount/startup mount
装载数据库 nomunt --> mount
3.3.1 装载数据库概述
装载数据库就是把数据库文件和实例关联起来，包括以下三个步骤：
Oracle根据参数文件 SPFILE 中的参数找到控制文件
打开控制文件
从控制文件获得数据字典和重做日志文件的名字及位置
完成以上三步，没有任何错误的情况下，Oracle 就已经把实例和数据库关联起来了。
装载数据库有两种方式：
一是直接启动数据库到 mount 状态：startup mount
二是如果数据库已经启动到 nomount 状态，使用 alter database mount 把数据库切换到mount 状态

我们就可以查询控制文件、数据文件和重做日志文件
SQL> select status from v$instance;

SQL> select name from v$controlfile;

SQL> select name from v$datafile;

SQL> select member from v$logfile;
但此时还不能查询数据库文件，如表和视图。所以对于普通用户而言，这个时候数据库还是不可用的。只有等到经历了最后一步 打开数据库 之后，才能使用数据库
*在mount阶段我们可以：
*重命名数据文件，移动数据文件位置等
*启用或关闭重做日志文件的归档及非归档模式
*实现数据库的完全恢复

3 alter database open或startup
打开数据库 mount --> open
打开数据库时，实例将打开所有处于联机状态的数据文件和重做日志文件。

在此期间，Oracle 服务器将校验所有的数据文件和联机日志文件能否打开，并对数据库作一致性检查。

如果出现一致性错误，SMON 进程将启动实例恢复
如果任一数据文件或联机日志文件丢失，Oracle 服务器将报错
只有将数据库设置为打开状态后，数据库才处于正常状态，这时普通用户才能够访问数据库。

4 startup restrict
限制模式下打开数据库。可以做的操作包括 数据import/export,  data load(with SQL*Loader),暂时禁用用户访问数据，执行迁移、升级操作

关闭数据库
与启动数据库顺序相反，也分三个步骤：
CLOSE 关闭数据库（关闭数据文件）
DISMOUNT 卸载数据库（关闭控制文件）
SHUTDOWN 关闭 Oracle 实例
关闭模式
1）shutdown NORMAL
//缺省值，与shutdown效果相同，等所有用户写入完毕后，退出数据库并关闭
2）shutdown IMMEDIATE
//回滚未提交所有事务操作，退出数据库并关闭；较常用
3）shutdown TRANSCACTION
//等待所有用户操作完毕后，再退出据库并关闭；一般用于定期关闭数据库
4）shutdown ABORT
//强制断开所有用户，数据全部不保存，会造成数据丢失，一般不建议使用

数据库关闭阶段做的工作：
终止所有会话
PMON进程回滚活动的事务
通过DBWn进程将已完成的失误转储至磁盘
LGWR进程将内存中的所有变更向量转储只redo log文件
同时关闭数据文件和重做日志文件(更新文件头，关闭文件句柄)
在数据库卸载阶段关闭控制文件
随后，通过解除分配SGA和终止后台进程，停止实例

数据库出现损坏的定义：
可能丢失了已提交的事务
也可能存储了未提交的事务

SYS@poc1> shutdown immediate;
Database closed.
Database dismounted.
ORACLE instance shut down.
SYS@poc1> @$ORACLE_HOME/mode.sql;
select a.thread#,b.open_mode,a.status,
*
ERROR at line 1:
ORA-01034: ORACLE not available                            # 状态
Process ID: 2899
Session ID: 923 Serial number: 2899


SYS@poc1> startup nomount;
ORACLE instance started.

Total System Global Area 4275781632 bytes
Fixed Size                  2260088 bytes
Variable Size            1107297160 bytes
Database Buffers         3154116608 bytes
Redo Buffers               12107776 bytes
SYS@poc1> @$ORACLE_HOME/mode.sql;
FROM v$thread a,
     *
ERROR at line 8:
ORA-01507: database not mounted                              # 状态


SYS@poc1> startup mount;
ORA-01081: cannot start already-running ORACLE - shut it down first
SYS@poc1> alter database mount;

Database altered.

SYS@poc1> @$ORACLE_HOME/mode.sql;

   THREAD# OPEN_MODE            STATUS STATUS
---------- -------------------- ------ ----------------------
         1 MOUNTED              CLOSED NO Crash Recovery req.             # 状态

SYS@poc1> alter database open;

Database altered.

SYS@poc1> @$ORACLE_HOME/mode.sql;

   THREAD# OPEN_MODE            STATUS STATUS
---------- -------------------- ------ ----------------------
         1 READ WRITE           OPEN   Instance already open.              # 状态
SYS@poc1> startup restrict;
ORACLE instance started.

Total System Global Area 4275781632 bytes
Fixed Size                  2260088 bytes
Variable Size            1107297160 bytes
Database Buffers         3154116608 bytes
Redo Buffers               12107776 bytes
Database mounted.
Database opened.
SYS@poc1> @$ORACLE_HOME/mode.sql;

   THREAD# OPEN_MODE            STATUS STATUS
---------- -------------------- ------ ----------------------
         1 READ WRITE           OPEN   Instance already open.                # 状态

SYS@poc1> shutdown abort;
ORACLE instance shut down.
SYS@poc1> startup mount;
ORACLE instance started.

Total System Global Area 4275781632 bytes
Fixed Size                  2260088 bytes
Variable Size            1107297160 bytes
Database Buffers         3154116608 bytes
Redo Buffers               12107776 bytes
Database mounted.
SYS@poc1> @$ORACLE_HOME/mode.sql;

   THREAD# OPEN_MODE            STATUS STATUS
---------- -------------------- ------ ----------------------
         1 MOUNTED              OPEN   Crash Recovery req.
SYS@poc1> alter database open;

Database altered.

SYS@poc1> @$ORACLE_HOME/mode.sql;

   THREAD# OPEN_MODE            STATUS STATUS
---------- -------------------- ------ ----------------------
         1 READ WRITE           OPEN   Instance already open.

[oracle@ora6 dbhome_1]$ cat -n mode.sql
     1  select a.thread#,b.open_mode,a.status,
     2  CASE
     3  WHEN((b.open_mode='MOUNTED') AND (a.status='OPEN')) THEN 'Crash Recovery req.'
     4  WHEN((b.open_mode='MOUNTED') AND (a.status='CLOSED')) THEN 'NO Crash Recovery req.'
     5  WHEN((b.open_mode='READ WRITE') AND (a.status='OPEN')) THEN 'Instance already open.'
     6  ELSE 'hub?'
     7  END STATUS
     8  FROM v$thread a,
     9  v$database b,
    10  v$instance c
    11  where a.thread#=c.thread#;



####启用archivelog
更改archivelog路径
SQL> alter system set log_archive_dest_1='location=/data/arch';
SQL> shutdown immediate;
SQL> startup mount
SQL> alter database archivelog;
SQL> alter database open;
SQL> archive log list;
Database log mode              Archive Mode
Automatic archival             Enabled
Archive destination            /data/arch
Oldest online log sequence     9
Next log sequence to archive   11
Current log sequence           11
SQL> ! ls /data/arch

SQL> alter system archive log current;

System altered.

SQL> ! ls /data/arch
1_11_1050509836.dbf

SQL> select name from v$archived_log;

NAME
-------------------------------
/data/arch/1_11_1050509836.dbf

SQL> archive log list;
Database log mode              Archive Mode
Automatic archival             Enabled
Archive destination            /data/arch
Oldest online log sequence     10
Next log sequence to archive   12
Current log sequence           12


####手工热备份  前提 启用archivelog
SQL> alter tablespace HOK begin backup;
Tablespace altered.

SQL> ! cp /data/oradata/CHENSEN/datafile/HOK_DATA01.DBF /data/bkdata/HOK_DATA01.DBF

SQL> alter tablespace HOK end backup;

Tablespace altered.

SQL> ! rm -f /data/oradata/CHENSEN/datafile/HOK_DATA01.DBF

SQL> shutdown immediate;
Database closed.
Database dismounted.
ORACLE instance shut down.
SQL> startup
ORACLE instance started.

Total System Global Area 3991842816 bytes
Fixed Size                  2259400 bytes
Variable Size            1056966200 bytes
Database Buffers         2919235584 bytes
Redo Buffers               13381632 bytes
Database mounted.
ORA-01157: cannot identify/lock data file 5 - see DBWR trace file
ORA-01110: data file 5: '/data/oradata/CHENSEN/datafile/HOK_DATA01.DBF'

SQL> ! cp /data/bkdata/HOK_DATA01.DBF /data/oradata/CHENSEN/datafile/HOK_DATA01.DBF

SQL> alter database open;
alter database open
*
ERROR at line 1:
ORA-01113: file 5 needs media recovery
ORA-01110: data file 5: '/data/oradata/CHENSEN/datafile/HOK_DATA01.DBF'

SQL> recover datafile 5;
Media recovery complete.
SQL> alter database open;

Database altered.
SQL> select * from CHENSEN.player;

ID                   NAME                 LEVEL_TYPE
-------------------- -------------------- --------------------
1                    chensen              qingtong
2                    chenlin              zuanshi

########### redo log
# 更改redo log 大小为200m
alter database drop logfile group 1;
alter database add logfile group 1 ('/data/oradata/CHENSEN/onlinelog/redo01.log') size 200m reuse;
alter system switch logfile;
alter database drop logfile group 3;
alter database add logfile group 3 ('/data/oradata/CHENSEN/onlinelog/redo03.log') size 200m reuse;
alter system switch logfile;
alter database drop logfile group 2;
select * from v$log;
alter database add logfile group 2 ('/data/oradata/CHENSEN/onlinelog/redo02.log') size 200m reuse;
select * from v$log;
alter system switch logfile;
# 添加redo log group member
alter database add logfile member '/data/oradata/CHENSEN/onlinelog/redo01_1.log' to group 1;
alter database add logfile member '/data/oradata/CHENSEN/onlinelog/redo01_2.log' to group 2;
alter database add logfile member '/data/oradata/CHENSEN/onlinelog/redo01_3.log' to group 3;

#redo log改名
shutdown immediate;
! mv /data/oradata/CHENSEN/onlinelog/redo01_2.log /data/oradata/CHENSEN/onlinelog/redo02_1.log
! mv /data/oradata/CHENSEN/onlinelog/redo01_3.log /data/oradata/CHENSEN/onlinelog/redo03_1.log
! ls -lh /data/oradata/CHENSEN/onlinelog
startup mount
alter database rename file '/data/oradata/CHENSEN/onlinelog/redo01_2.log' to '/data/oradata/CHENSEN/onlinelog/redo02_1.log';
alter database rename file '/data/oradata/CHENSEN/onlinelog/redo01_3.log' to '/data/oradata/CHENSEN/onlinelog/redo03_1.log';
alter database open;
select * from v$logfile;

#redo log在线迁移
添加新的redo log组
删除旧的日志组

# redo log损坏或丢失
SQL> shutdown immediate
SQL> startup mount
SQL> recover database until cancel;
SQL> alter database open resetlogs;



######### redo log and undo log ############
重做日志文件（redo log file）对数据库来说至关重要，他们是数据库的事务日志；

Oracle数据库维护着两类重做日志文件：在线重做日志文件（redo）和 归档重做日志文件（archive log），（归档重做日志文件实际上就是已填满的“旧”在线重做日志文件的副本）

这两类重做日志文件都是用于恢复的：

①：如果数据库所在主机掉电，导致实例失败，Oracle会使用在线重做日志将系统恢复到恰好在掉电之前的那个提交点；

②：如果磁盘驱动器出现故障（这是介质失败），Oracle会使用归档重做日志以及在线重做日志，以及之前的一个备份，将原在此驱动器上的数据恢复到某个时间点；

Redo log的日志状态分为4种：

current:指的是当前日志文件，该日志文件是活动的，当前正在被使用的，进行崩溃恢复时，Current日志文件是必须的；

ACTIVE：是活动的非当前日志，可以已经完成归档也可能没有归档，在Crash恢复时会被用到；

inactive：非活动日志，在实例恢复时不再需要，但是在介质恢复时可能会用到，此状态的日志也可能没有被归档。

unused：该日志从未被写入，这类日志可能是刚被添加到数据库或者在resetlogs之后被重置。 

Crash recovery has two pahses : rollforward and rollback

The system monitor will first roll forward and apply to the datafiles any transactions in the online redo files that occured after the most recent checkpoint.
 Crash Recovery uses redo information found in the online redo log files onlu . After rolling forward, Oracle will rollback any of those transactions that were never committed.
 Oracle uses information stored in the undo segments to rollback (undo) any uncommitted transactions.
 

########### oracle进程 ####################
一、 DBWn
DBWn按极懒算法执行写入：尽可能少，但出现(完全)检查点的情况例外，将所有脏缓冲区尽快写入磁盘。
以下几种情况执行写操作
增量检查点：  将有限数量的脏缓冲区写入数据文件
1 没有任何可用缓冲区
2 脏缓冲区数量过多
3 遇到三秒超时
4 请求的检查点（完全检查点）  将所有的脏缓冲区写入数据文件   - 可能影响性能
局部检查点，强制DBWn写入仅包含一个或多个数据文件的块的所有脏缓冲区
如：
数据文件或表空间脱机时，
在将表空间置入备份模式时
在将表空间设置为只读时
二、 LGWR
以下几种情况执行写操作
1.用户进程提交一个事务（Commit）
2.日志缓冲区达到1/3范围，或者包含了1MB的缓存重做日志数据
3.要求LGWR切换日志文件
4.出现超时（3秒钟内未活动，则进行一次写操作。）
5.DBWR需要写入的数据的SCN号大于LGWR 记录的SCN号，DBWR 触发LGWR写入

RBA （redo block address）onlin redo log的重做块地址
ckpt进程还会在控制文件当中记录RBA，这个地址用来标志实例恢复的时候需要从日志中的那个位置开始，也就是一个checkpoint对应一个rba，
当instance recovery（实例恢复）的时候oracle就会知道从那个检查点开始在redo的那个rba开始介质恢复！


######### oracle 表空间  ########
表空间的分类
永久表空间                存放永久性数据，如表，索引等。
临时表空间                不能存放永久性对象，用于保存数据库排序，分组时产生的临时数据。
UNDO表空间             保存数据修改前的镜象。

表空间的管理方式：
字典管理：全库所有的空间分配都放在数据字典中。容易引起字典争用，而导致性能问题。
使用数据字典管理存储空间的分配, 当表空间分配新的区, 或者回收已分配的区时, ORACLE会对数据字典对应的表进行查询、更新, 且使用单线程, 速度慢, 并且产生回退和重做信息。
本地管理：空间分配不放在数据字典，而在每个数据文件头部的第3到第8个块的位图块，来管理空间分配。
优点:  a) 提高存储管理的速度和并发性。 b) 不产生磁盘碎片。 c) 不产生递归管理。 d) 没有系统回滚段。

表空间状态有下面几种状态：online、offline、read only、read write。

表空间改名
在ORACLE 10g 之前，表空间的名称是不能被修改的。在ORACLE 11G中，通过ALTER TABLESPACE 语句中使用RENAME子句，数据库管理员可以修改表空间的名称。

######### oracle 段空间  ########
区间（Extent）是Oracle的最小空间分配单元，而Block是Oracle的最小IO操作单元，也就是说，
Oracle以区间为单位将空间分配给对象段，而段内则是以Block为单位进行空间使用和管理的。
管理方式
手动管理方式时（MSSM），Oracle是通过Freelist（一个单向链表）来管理段内的空间分配，此时只有HWM的说法；
自动管理方式（ASSM）时，Oracle是通过BITMAP来管理段内的空间分配，此时Oracle引入了LHWM（Low HWM，低高水位）的概念。

#########  oracle区    #######
由于区(extent)是ORACLE创建对象时的最小分配单元, 所以表空间的管理实际上就是针对于区间的管理。 
分配方式： 自动分配、统一尺寸
  create tablespace Think 
  datafile '/u01/app/oracle/oradata/orcl/think.dbf' size 100M
  autoextend on next 10M maxsize 4096M
  extent management local uniform size 256K
  segment space management auto;
  
  
对于任何DML操作来说，必须同时处理数据块和撤销块，并且还会生成重做数据。
ACID的A,C,I要求生成撤销数据，D则要求生成重做数据。  

############# 表分区  ##########
最简单的range分区
CREATE TABLE TEST_RANGE_PARTITION
      (    "EMPNO" NUMBER(4,0),
           "ENAME" VARCHAR2(10),
           "JOB" VARCHAR2(9),
           "MGR" NUMBER(4,0),
           "HIREDATE" DATE,
           "SAL" NUMBER(7,2),
           "COMM" NUMBER(7,2),
           "DEPTNO" NUMBER(2,0)
      )
     PARTITION BY RANGE ("SAL")
      (PARTITION "TEST_RANGE_SAL_01" VALUES LESS THAN (1000),
       PARTITION "TEST_RANGE_SAL_02" VALUES LESS THAN (2000),
       PARTITION "TEST_RANGE_SAL_03" VALUES LESS THAN (3000),
       PARTITION "TEST_RANGE_SAL_MAX" VALUES LESS THAN (MAXVALUE)  
      );
SQL> insert into TEST_RANGE_PARTITION select * from emp;
SQL> select a.TABLE_NAME,PARTITIONING_TYPE,PARTITION_NAME,PARTITION_POSITION,HIGH_VALUE,NUM_ROWS from user_part_tables a,user_tab_partitions b where a.TABLE_NAME=b.TABLE_NAME and a.table_                                      name='TEST_RANGE_PARTITION';

TABLE_NAME                     PARTITION PARTITION_NAME                 PARTITION_POSITION HIGH_VALUE                                                                         NUM_ROWS
------------------------------ --------- ------------------------------ ------------------ -------------------------------------------------------------------------------- ----------
TEST_RANGE_PARTITION           RANGE     TEST_RANGE_SAL_01                               1 1000
TEST_RANGE_PARTITION           RANGE     TEST_RANGE_SAL_02                               2 2000
TEST_RANGE_PARTITION           RANGE     TEST_RANGE_SAL_03                               3 3000
TEST_RANGE_PARTITION           RANGE     TEST_RANGE_SAL_MAX                              4 MAXVALUE

SQL> analyze table TEST_RANGE_PARTITION compute statistics;

Table analyzed.

SQL> select a.TABLE_NAME,PARTITIONING_TYPE,PARTITION_NAME,PARTITION_POSITION,HIGH_VALUE,NUM_ROWS from user_part_tables a,user_tab_partitions b where a.TABLE_NAME=b.TABLE_NAME and a.table_                                      name='TEST_RANGE_PARTITION';

TABLE_NAME                     PARTITION PARTITION_NAME                 PARTITION_POSITION HIGH_VALUE                                                                         NUM_ROWS
------------------------------ --------- ------------------------------ ------------------ -------------------------------------------------------------------------------- ----------
TEST_RANGE_PARTITION           RANGE     TEST_RANGE_SAL_01                               1 1000                                                                                      2
TEST_RANGE_PARTITION           RANGE     TEST_RANGE_SAL_02                               2 2000                                                                                      6
TEST_RANGE_PARTITION           RANGE     TEST_RANGE_SAL_03                               3 3000                                                                                      3
TEST_RANGE_PARTITION           RANGE     TEST_RANGE_SAL_MAX                              4 MAXVALUE                                                                                  3


# 未使用的列
SQL> alter table CAILAMEI set unused column CREATED;

Table altered.

Elapsed: 00:00:00.13
SQL> select object_name,object_id from dba_objects where
  2  object_name='CAILAMEI';

OBJECT_NAME                                                                                                                       OBJECT_ID
-------------------------------------------------------------------------------------------------------------------------------- ----------
CAILAMEI                                                                                                                              87440

Elapsed: 00:00:00.04
SQL> select obj#,col#,name from sys.col$ where obj#='87440';

      OBJ#       COL# NAME
---------- ---------- ------------------------------
     87440          1 OWNER
     87440          2 OBJECT_NAME
     87440          3 SUBOBJECT_NAME
     87440          4 OBJECT_ID
     87440          5 DATA_OBJECT_ID
     87440          6 OBJECT_TYPE
     87440          0 SYS_C00007_21021810:44:24$
     87440          7 LAST_DDL_TIME
     87440          8 TIMESTAMP
     87440          9 STATUS
     87440         10 GENERATED
     87440         11 NAMESPACE
     87440          0 SYS_C00013_21021809:53:42$

13 rows selected.

Elapsed: 00:00:00.02
SQL> alter table CAILAMEI drop unused columns checkpoint 1000;

Table altered.

Elapsed: 00:00:03.29
SQL> select obj#,col#,name from sys.col$ where obj#='87440';

      OBJ#       COL# NAME
---------- ---------- ------------------------------
     87440          1 OWNER
     87440          2 OBJECT_NAME
     87440          3 SUBOBJECT_NAME
     87440          4 OBJECT_ID
     87440          5 DATA_OBJECT_ID
     87440          6 OBJECT_TYPE
     87440          7 LAST_DDL_TIME
     87440          8 TIMESTAMP
     87440          9 STATUS
     87440         10 GENERATED
     87440         11 NAMESPACE

# 全局临时表
临时表的定义对所有会话都是可见的，但表中的资料支队当前的会话或事务可见。
默认基于事务
基于会话的临时表
create global temporary table emp_tmp1 on commit preserve rows as select * from scott.emp;	 
基于事务的临时表
create global temporary table emp_tmp2 on commit delete rows as select * from scott.emp;	

#  子查询
什麼是非關聯子查詢
而子查詢也可以分成關聯子查詢和非關聯子查詢,  上面那條sql 語句就是非關聯子查詢.

所謂非關聯子查詢就是指子查詢可以脫離主查詢獨立執行.

再舉個例子:

我想找出每個部門中最高工資的人.

sql語句可以寫成如下:

select a.deptno,a.* from emp a
where (a.deptno, a.sal) in (select deptno, max(sal) from emp group by deptno)

其中的 子查詢
select deptno, max(sal) from emp group by deptno
是可以獨立執行的.

而且對於整個查詢來講, 是執行一次子查詢先, 再執行主查詢.

3. 什麼是關聯子查詢
所謂關聯子查詢就是指子查詢與主查詢之間有條件關聯,  不能獨自執行.

看回上面的需求, 我們換一種寫法:

select a.deptno, a.* from emp a
where a.sal = (select max(b.sal) from emp b where b.deptno =  a.deptno)
上面的例子就是用到關聯子查詢了,  其中的子查詢因為條件關聯了主查詢的表. 所以子查詢不能單獨執行.

對於關聯子查詢來講,  是自外到內的, 先執行外查詢,.

例如上面的例子,   對於主表a來間,  對於每1個deptno,  都要執行一次子查詢.

關聯子查詢還有1個限制, 就是子查詢不能返回多於1行的資料.

-- 集合運算注意事項
/*
   1.列的數量要一致
   2.列的型別要保持一致
   3.列的順序要一致

   如果不足,可以用null補齊
*/

在oracle中：

1）where/group by/having子句中只能直接使用栏位或者常量，而不能使用栏位的别名，除非这个别名来自子查询之中，如：select .... from (select col1 ccc from table) where ccc > 1 
2）而order by 则可以直接使用别名，如select col1 ccc from table order by ccc 

这和sql 的执行顺序是有关的，where中的部分先执行 －> 如果有group by，接着执行group by －> select中的函数计算、别名指定再运行－> 最后order by 
因此，字段、表达式的别名在where子句和group by子句都是不能使用的，而在order by中不仅可以使用别名，甚至可以直接使用栏位的下标来进行排序，如：order by 1 desc,2 asc

# 同义词

object_name: 要创建同义词的对象，它可以是以下几种类型：

TABLE
VIEW
SEQUENCE
STORED PROCEDURE
FUNCTION
PACKAGE
MATERIALIZED VIEW
JAVA CLASS SCHEMA OBJECT
USER-DEFINED OBJECT
SYNONYM

# where 1=1
用于防止SQL语句出错，并且简化语句(不用做那么多判断)
# where 1<>1
用于使用另一张表的定义建表

###   read only模式
In read-only mode, the following operations are permitted on the table:

 Select
 Management indexes, constraints, supplemental log
 Dropping and deallocation of unused columns
 Renaming and moving of the table
 Altering the table for physical property changes, row movement, and shrinking the segment
 Drop table
The following operations are disabled on a table in read-only mode:

 DML on table or any table partitions
 Truncation of table
 Select for update
 Adding, removing, renaming, dropping, or setting a column to unused
 Dropping a partition or sub partition belonging to the table
 Online redefinition
 Flashback on the table
 
 
###   约束 
 A CONSTRAINT can be one of the following:
a column-level constraint
Column-level constraints refer to a single column in the table and do not specify a column name (except check constraints). They refer to the column that they follow.

a table-level constraint
Table-level constraints refer to one or more columns in the table. Table-level constraints specify the names of the columns to which they apply. Table-level CHECK constraints can refer to 0 or more columns in the table.

Column constraints include:
NOT NULL
Specifies that this column cannot hold NULL values (constraints of this type are not nameable).

PRIMARY KEY
Specifies the column that uniquely identifies a row in the table. The identified columns must be defined as NOT NULL.

Note: If you attempt to add a primary key using ALTER TABLE and any of the columns included in the primary key contain null values, an error will be generated and the primary key will not be added. See ALTER TABLE statement for more information.
UNIQUE
Specifies that values in the column must be unique.

FOREIGN KEY
Specifies that the values in the column must correspond to values in a referenced primary key or unique key column or that they are NULL.

CHECK
Specifies rules for values in the column.

Table constraints include:
PRIMARY KEY
Specifies the column or columns that uniquely identify a row in the table. NULL values are not allowed.

UNIQUE
Specifies that values in the columns must be unique.

FOREIGN KEY
Specifies that the values in the columns must correspond to values in referenced primary key or unique columns or that they are NULL.

Note: If the foreign key consists of multiple columns, and any column is NULL, the whole key is considered NULL. The insert is permitted no matter what is on the non-null columns.
CHECK
Specifies a wide range of rules for values in the table.

Column constraints and table constraints have the same function; the difference is in where you specify them. Table constraints allow you to specify more than one column in a PRIMARY KEY,
 UNIQUE, CHECK, or FOREIGN KEY constraint definition. Column-level constraints (except for check constraints) refer to only one column.
 

######## Restrictions on the FOR UPDATE Clause 
This clause is subject to the following restrictions:

You cannot specify this clause with the following other constructs: the DISTINCT operator, CURSOR expression, set operators, group_by_clause, or aggregate functions.
The tables locked by this clause must all be located on the same database and on the same database as any LONG columns and sequences referenced in the same statement. 

######  self join
A self join uses other joins such as inner join and left join.