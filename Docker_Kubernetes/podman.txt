The best attributes of Podman include:

Podman can run in rootless mode – its containers are more secure since they run without any added privileges.
Podman is daemonless- it has lower resource requirements at idle because if you are not running containers, Podman is not running. Docker, on the other hand, has a daemon always running.
systemd integration -it allows you to run containers as system services.

######## 常用podman命令 ###########
创建pod
podman pod create -n mydb -p 3306:3306

在pod里运行容器
podman run -d --pod mydb --name mysql01 -e MYSQL_ROOT_PASSWORD=vSTJ456  docker.io/library/mysql

导出pod的yaml文件
podman generate kube mydb -f pod_mydb.yaml

用yaml文件创建pod和container
podman play kube pod_mydb.yaml

销毁pod和container
podman play kube --down pod_mydb.yaml

重新创建pod和container
podman play kube --replace pod_mydb.yaml

podman 4.0有了新功能  podman image scp, 适用于没有docker registry的情况下
实现把镜像从本地传到目标机器
1 目标机器 启用podman.socket
[root@docker2 run]# systemctl enable --now podman.socket
Created symlink /etc/systemd/system/sockets.target.wants/podman.socket → /usr/lib/systemd/system/podman.socket.
[root@docker2 run]# systemctl status podman.socket
● podman.socket - Podman API Socket
   Loaded: loaded (/usr/lib/systemd/system/podman.socket; enabled; vendor preset: disabled)
   Active: active (listening) since Wed 2022-06-22 05:26:51 UTC; 6s ago
     Docs: man:podman-system-service(1)
   Listen: /run/podman/podman.sock (Stream)
   CGroup: /system.slice/podman.socket

Jun 22 05:26:51 docker2 systemd[1]: Listening on Podman API Socket.
[root@docker2 run]# ll /run/podman/podman.sock
srw-rw---- 1 root root 0 Jun 22 05:26 /run/podman/podman.sock
[root@docker2 run]# curl --unix-socket /run/podman/podman.sock http://localhost/_ping
OK[root@docker2 run]#
2 本地机器
ssh-copy-id root@10.85.212.146
[root@docker1 ~]# podman system connection add --identity ~/.ssh/id_rsa --port 22 docker2 root@10.85.212.146
[root@docker1 ~]# podman system connection list
Name        URI                                                 Identity           Default
docker2     ssh://root@10.85.212.146:22/run/podman/podman.sock  /root/.ssh/id_rsa  true
[root@docker1 ~]# podman image scp docker.io/library/postgres:13 docker2::
Copying blob ad6562704f37 done
.....
Copying config bb3dc22779 done
Writing manifest to image destination
Storing signatures
Loaded image(s): docker.io/library/postgres:13

将目标机器的镜像拷到本机
[root@docker1 ~]# podman image scp docker2::docker.io/library/mysql:latest
Getting image source signatures
Copying blob e51f7a7d2db0 done
.....
Copying config 20b875c974 done
Writing manifest to image destination
Storing signatures
Loaded image(s): docker.io/library/mysql:latest
[root@docker1 ~]# podman images |grep mysql
docker.io/library/mysql     latest            20b875c97488  3 weeks ago  529 MB

### How to run systemd in a container
There are lots of reasons to run systemd inside a system, such as:

1 Multiservice containers—Lots of people want to take existing multi-service applications out of VMs and run them inside of containers. 
We would prefer that they break apart these applications into microservices, but some people can’t or don’t have time yet.  So running them as services launched out of unit files by systemd makes sense.
2 Systemd unit files—Most applications that run inside of containers are built from code that was run in VMs or on host systems. These applications have a unit file that was written for the application and 
understands how to run the application. It can be better to launch the service via the supported method, rather than to hack up your own init service.
3 Systemd is a process manager—It handles the management of services like reaping, restarting, and shutting down better than any other tool.

That being said, there are also lots of reasons not to run systemd in containers. The main one is that systemd/journald controls the output of containers, whereas tools like Kubernetes and OpenShift 
expect the containers to log directly to stdout and stderr. So, if you are going to manage your containers via Orchestrator like these, then you should think twice about using systemd-based containers. 
Additionally, the upstream community of Docker and Moby were often hostile to the use of systemd in a container.
k8s里避免使用跑着systemd的容器，因为日志输出会有问题

man podman run

…

--systemd=true|false

Run container in systemd mode. The default is true.

If the command you running inside of the container is systemd or init, podman will setup tmpfs mount points in the following directories:

/run, /run/lock, /tmp, /sys/fs/cgroup/systemd, /var/lib/journal

It will also set the default stop signal to SIGRTMIN+3.

podman生成systemd unit file
podman generate systemd --name p13 --files --new

# podman与systemd结合的比较好，远好于docker与systemd的结合
Podman in systemd unit files works better than Docker
When launching containers at boot, you can simply put Podman commands into a systemd unit file, and systemd will launch and monitor the service. Podman is a standard fork and exec model. 
That means the container processes are children of the Podman process, so systemd has an easy time monitoring the processes.

Docker is a client service model and putting the Docker CLI into a unit file is possible. However, as the Docker client connects to the Docker daemon, the Docker client becomes just another 
process handling stdin and stdout. Systemd has no idea of this relationship between the Docker client and the container that is running under the Docker daemon and can't monitor the service in this model.

SD_NOTIFY
Systemd has the ability to hold up secondary services from starting that rely on a containerized service starting. Podman can pass down the SD_NOTIFY Socket to the containerized service, 
so it can notify systemd when it is ready to begin servicing requests. Docker again cannot do this, because of the client/server model.




--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
buildah命令制作镜像
buildah from localhost/centos:7
new=`buildah mount centos-working-container`
rm -f ${new}/etc/yum.repos.d/C*
curl -o ${new}/etc/yum.repos.d/centos7.repo http://10.67.51.164/repofile/centos7.repo
buildah run centos-working-container yum install -y postgresql14 postgresql14-server iproute
buildah config --env PGDATA="/var/lib/pgsql/14/data" centos-working-container
buildah config --user postgres centos-working-container
buildah run --user postgres centos-working-container /usr/pgsql-14/bin/initdb -D /var/lib/pgsql/14/data --data-checksums
echo "host all all all md5" >> ${new}/var/lib/pgsql/14/data/pg_hba.conf
echo "listen_addresses = '*'" >> ${new}/var/lib/pgsql/14/data/postgresql.auto.conf
buildah config --cmd "/usr/pgsql-14/bin/postmaster -D /var/lib/pgsql/14/data" centos-working-container
buildah config --port 5432  centos-working-container
buildah config --volume /var/lib/pgsql/14/data centos-working-container
buildah commit centos-working-container mypg14:1.4
buildah rm centos-working-container

#关掉working container
[root@389dsbak ~]# buildah rm centos-working-container
beee0dc057ef7b7fb46865ca7d4adf5386ed78008b90ed5018a17915a66bf772

######################################  buildah制作标准镜像  ######################################
## 版本1    存在三个问题
[root@389dsbak ~]# cat build2.sh
buildah from localhost/centos:7
new=`buildah mount centos-working-container`
rm -f ${new}/etc/yum.repos.d/C*
curl -o ${new}/etc/yum.repos.d/centos7.repo http://10.67.51.164/repofile/centos7.repo
buildah run centos-working-container yum install -y postgresql14 postgresql14-server postgresql14-contrib iproute
buildah config --env PGDATA="/var/lib/pgsql/14/data" centos-working-container
buildah config --env PGDATABASE="" centos-working-container
buildah config --env PGUSERNAME="" centos-working-container
buildah config --env PGPASSWORD="" centos-working-container
buildah config --env PGADMPWD="" centos-working-container
buildah config --user postgres centos-working-container
buildah config --entrypoint "/usr/bin/entrypoint.sh" centos-working-container
buildah copy centos-working-container /root/entrypoint.sh /usr/bin/entrypoint.sh
buildah run centos-working-container chmod +x /usr/bin/entrypoint.sh
buildah config --port 5432  centos-working-container
buildah config --volume /var/lib/pgsql/14/data centos-working-container
buildah config --stop-signal SIGINT centos-working-container
buildah commit centos-working-container mypg14
buildah rm centos-working-container

[root@389dsbak ~]#
[root@389dsbak ~]#
[root@389dsbak ~]# cat entrypoint.sh
#!/usr/bin/bash

PGDATA="/var/lib/pgsql/14/data"
PGAUTOCONF=${PGDATA}/postgresql.auto.conf
PGDB=${PGDATABASE}
PGUSERNAME=${PGUSERNAME}
PGPASSWD=${PGPASSWORD}
PGADMPWD=${PGADMPWD}
PGBIN="/usr/pgsql-14/bin"


pg_initdb()
{
${PGBIN}/initdb -D ${PGDATA} --data-checksums
}

pg_conf()
{
echo "host all all all md5" >> ${PGDATA}/pg_hba.conf
echo "listen_addresses = '*'" >> ${PGAUTOCONF}
}

pg_prestart()
{
${PGBIN}/pg_ctl -D ${PGDATA} -w start
}

pg_start()
{
# the exec command replaces the shell process with the postmaster process. Now postmaster is PID 1, which means it receives all signals sent to the container!
exec ${PGBIN}/postmaster -D ${PGDATA}       ###更改后加了 exec
}

pg_stop()
{
${PGBIN}/pg_ctl -D ${PGDATA} -m fast -w stop
}

pg_passwd()
{
#/bin/psql -c "create user ${PGUSERNAME} with login password '${PGPASSWD}'" postgres
#/bin/psql -c "alter user postgres password '${PGADMPWD}'" postgres
#/bin/psql -c "create database ${PGDB} with owner = ${PGUSERNAME}" postgres
/bin/psql -v ON_ERROR_STOP=1 --username postgres --dbname postgres <<-EOSQL
  create user ${PGUSERNAME} with login password '${PGPASSWD}';
  alter user postgres password '${PGADMPWD}';
  create database ${PGDB} with owner = ${PGUSERNAME};
  create extension if not exists "postgres_fdw";
EOSQL
}


if [ -e "${PGDATA}/base" ];then
pg_prestart
pg_passwd
pg_stop
pg_start
else
pg_initdb
pg_conf
pg_prestart
pg_passwd
pg_stop
pg_start
fi


问题1  容器db进程pid不是1，SIGNAL传递不到db进程
[root@389dsbak ~]# podman rm -f fc5c090a2b21
WARN[0010] StopSignal SIGTERM failed to stop container musing_galileo in 10 seconds, resorting to SIGKILL
解决
在容器启动命令前加 exec   将pid 1从脚本传递给postmaster进程
exec ${PGBIN}/postmaster -D ${PGDATA}

修改前 entrypoint.sh的PID为1  postmaster为18
[root@389dsbak ~]# podman top 3842
USER        PID         PPID        %CPU        ELAPSED              TTY         TIME        COMMAND
postgres    1           0           0.000       14h55m20.982903046s  ?           0s          /bin/bash /usr/bin/entrypoint.sh
postgres    18          1           0.004       14h55m20.983114597s  ?           2s          /usr/pgsql-14/bin/postmaster -D /var/lib/pgsql/14/data
postgres    19          18          0.000       14h55m20.983252367s  ?           0s          postgres: logger
postgres    21          18          0.000       14h55m20.983348224s  ?           0s          postgres: checkpointer
postgres    22          18          0.000       14h55m20.98344384s   ?           0s          postgres: background writer
postgres    23          18          0.000       14h55m20.983539607s  ?           0s          postgres: walwriter
postgres    24          18          0.002       14h55m20.983660404s  ?           1s          postgres: autovacuum launcher
postgres    25          18          0.004       14h55m20.983761627s  ?           2s          postgres: stats collector
postgres    26          18          0.000       14h55m20.983871237s  ?           0s          postgres: logical replication launcher
postgres    1800        18          0.000       6m50.98398707s       ?           0s          postgres: zabbix zabbix 10.67.50.63(58078) idle
修改后 postmaster的PID为1
[root@389dsbak ~]# podman top fd3e
USER        PID         PPID        %CPU        ELAPSED       TTY         TIME        COMMAND
postgres    1           0           0.000       8.188178619s  ?           0s          /usr/pgsql-14/bin/postmaster -D /var/lib/pgsql/14/data
postgres    18          1           0.000       8.188378969s  ?           0s          postgres: logger
postgres    20          1           0.000       7.188490523s  ?           0s          postgres: checkpointer
postgres    21          1           0.000       7.18858404s   ?           0s          postgres: background writer
postgres    22          1           0.000       7.18867736s   ?           0s          postgres: walwriter
postgres    23          1           0.000       7.188776677s  ?           0s          postgres: autovacuum launcher
postgres    24          1           0.000       7.18886787s   ?           0s          postgres: stats collector
postgres    25          1           0.000       7.188983657s  ?           0s          postgres: logical replication launcher

问题2  日志输出问题，podman logs显示不了日志
podman run -d -e PGDATABASE=zabbix -e PGUSERNAME=zabbix -e PGPASSWORD=Foxconn123 -e PGADMPWD=vSTJ456 -v /data:/var/lib/pgsql/14/data -p 5432:5432 localhost/mypg14:latest
日志输出在容器里log目录底下，需要配置logging_collector = 'off'，日志才会输出到stderr, podman logs 才能看得到

问题3  cmd的参数没有pass给entrypoint，也就是不能传参数
解释：--entrypoint "command" | '["command", "arg1", ...]'

Set the entry point for containers based on any images which will be built using the specified container. buildah supports two formats for entrypoint.
 It can be specified as a simple string, or as an array of commands.

Note: When the entrypoint is specified as a string, container runtimes will ignore the cmd value of the container image. 
However if you use the array form, then the cmd will be appended onto the end of the entrypoint cmd and be executed together.
当我用buildah config --entrypoint "/usr/bin/entrypoint.sh"时，cmd指定 "-c shared_buffers=256MB" 时，cmd不会传递给entrypoint.sh，导致容器run时异常退出
期待的结果  + exec postgres -c shared_buffers=256MB
此时的结果  _main "$@"
            + _main
            /usr/bin/entrypoint.sh: line 47: 1: unbound variable  因为cmd没有传递给entrypoint,导致无变量。这里entrypoint.sh已经修改为第二版，build2.sh为第一版

## 版本2   三个问题都已解决
[root@389dsbak ~]# cat build2.sh
buildah from localhost/centos:7
new=`buildah mount centos-working-container`
rm -f ${new}/etc/yum.repos.d/C*
curl -o ${new}/etc/yum.repos.d/centos7.repo http://10.67.51.164/repofile/centos7.repo
buildah run centos-working-container yum install -y postgresql14 postgresql14-server postgresql14-contrib iproute
buildah config --env PGDATA="/var/lib/pgsql/14/data" centos-working-container
buildah config --env PATH="$PATH:/usr/pgsql-14/bin" centos-working-container
buildah config --env PGDATABASE="" centos-working-container
buildah config --env PGUSERNAME="" centos-working-container
buildah config --env PGPASSWORD="" centos-working-container
buildah config --env PGADMPWD="" centos-working-container
buildah config --user postgres centos-working-container
buildah config --entrypoint '["/usr/bin/entrypoint.sh"]' centos-working-container
buildah copy centos-working-container /root/entrypoint.sh /usr/bin/entrypoint.sh
buildah run centos-working-container chmod +x /usr/bin/entrypoint.sh
buildah config --cmd "postgres" centos-working-container
buildah config --port 5432  centos-working-container
buildah config --volume /var/lib/pgsql/14/data centos-working-container
buildah config --stop-signal SIGINT centos-working-container
buildah commit centos-working-container mypg14:20220701
buildah rm centos-working-container

[root@389dsbak ~]# cat entrypoint.sh
#!/bin/sh

PGDATA="/var/lib/pgsql/14/data"
PGAUTOCONF=${PGDATA}/postgresql.auto.conf
PGDB=${PGDATABASE}
PGUSERNAME=${PGUSERNAME}
PGPASSWD=${PGPASSWORD}
PGADMPWD=${PGADMPWD}


pg_initdb()
{
initdb -D ${PGDATA} --data-checksums
}

pg_conf()
{
echo "host all all all md5" >> ${PGDATA}/pg_hba.conf
echo "listen_addresses = '*'" >> ${PGAUTOCONF}
echo "logging_collector = 'off'" >> ${PGAUTOCONF}
}

pg_prestart()
{
pg_ctl -D ${PGDATA} -w start
}

pg_stop()
{
pg_ctl -D ${PGDATA} -m fast -w stop
}

pg_sql()
{
/bin/psql -v ON_ERROR_STOP=1 --username postgres --dbname postgres <<-EOSQL
  create user ${PGUSERNAME} with login password '${PGPASSWD}';
  alter user postgres password '${PGADMPWD}';
  create database ${PGDB} with owner = ${PGUSERNAME};
  create extension if not exists "postgres_fdw";
EOSQL
}



_main() {
  if [ "${1:0:1}" = '-' ]; then
    set -- postgres "$@"
  fi

  if [ "$1" = 'postgres' ];then
    if [ -e "${PGDATA}/base" ];then
      echo "PostgreSQL appears to contain a database; Skipping initialization"
    else
      pg_initdb
      pg_conf
      pg_prestart
      pg_sql
      pg_stop
      echo "PostgreSQL init process complete; Ready for start up"
    fi
  fi
  exec "$@"
}

_main "$@"

## 现在 run 第二个版本的镜像
podman run -d -e PGDATABASE=zabbix -e PGUSERNAME=zabbix -e PGPASSWORD=Foxconn123 -e PGADMPWD=vSTJ456 \ 
   -v /data:/var/lib/pgsql/14/data -p 5432:5432 localhost/mypg14:20220701 -c shared_buffers=256MB
容器run的结果
1 有日志
[root@389dsbak ~]# podman logs -f 77e6
.......

+ exec postgres -c shared_buffers=256MB
2022-07-04 08:04:51.274 UTC [1] LOG:  starting PostgreSQL 14.2 on x86_64-pc-linux-gnu, compiled by gcc (GCC) 4.8.5 20150623 (Red Hat 4.8.5-44), 64-bit
2022-07-04 08:04:51.275 UTC [1] LOG:  listening on IPv4 address "0.0.0.0", port 5432
2022-07-04 08:04:51.275 UTC [1] LOG:  listening on IPv6 address "::", port 5432
2022-07-04 08:04:51.279 UTC [1] LOG:  listening on Unix socket "/var/run/postgresql/.s.PGSQL.5432"
2022-07-04 08:04:51.283 UTC [1] LOG:  listening on Unix socket "/tmp/.s.PGSQL.5432"
2022-07-04 08:04:51.288 UTC [25] LOG:  database system was shut down at 2022-07-04 08:04:51 UTC
2022-07-04 08:04:51.295 UTC [1] LOG:  database system is ready to accept connections

2 postgres的pid为1 且cmd参数传递给postgres了
podman top 77e6
USER        PID         PPID        %CPU        ELAPSED           TTY         TIME        COMMAND
postgres    1           0           0.000       14m44.468481343s  ?           0s          postgres -c shared_buffers=256MB
postgres    26          1           0.000       14m42.468688549s  ?           0s          postgres: checkpointer
postgres    27          1           0.000       14m42.468808229s  ?           0s          postgres: background writer
postgres    28          1           0.000       14m42.468990833s  ?           0s          postgres: walwriter
postgres    29          1           0.000       14m42.469108753s  ?           0s          postgres: autovacuum launcher
postgres    30          1           0.000       14m42.46922044s   ?           0s          postgres: stats collector
postgres    31          1           0.000       14m42.469348074s  ?           0s          postgres: logical replication launcher
3 